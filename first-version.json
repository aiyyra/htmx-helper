[
 {
 "chapter": "Contents",
 "content": ""
 },
 {
 "chapter": "Hypermedia: A Reintroduction",
 "content": "Hypermedia is a universal technology today, almost as common as\nelectricity.Billions of people use hypermedia-based systems every day, mainly by\ninteracting with the Hypertext Markup Language (HTML) being\nexchanged via the Hypertext Transfer Protocol (HTTP) by using a\nweb browser connected to the World Wide Web.People use these systems to get their news, check in on friends, buy\nthings online, play games, send emails and so forth: the variety and\nsheer number of online services being delivered by hypermedia is truly\nastonishing.And yet, despite this ubiquity, the topic of hypermedia itself is a\nstrangely under-explored concept today, left mainly to specialists. Yes,\nyou can find a lot of tutorials on how to author HTML, create links and\nforms, etc. But it is rare to see a discussion of HTML as a\nhypermedia and, more broadly, on how an entire hypermedia\nsystem fits together.This is in contrast with the early web development era when concepts\nlike Representational State Transfer (REST) and Hypermedia\nAs The Engine of Application State (HATEOAS) were discussed\nfrequently, refined and debated among web developers.In a sad turn of events, today, the world’s most popular hypermedia,\nHTML, is often viewed resentfully: it is an awkward, legacy markup\nlanguage that must be grudgingly used to build user interfaces in what\nare increasingly entirely JavaScript-based web applications.HTML happens to be there, in the browser, and so we have to use\nit.This is a shame and we hope to convince you that hypermedia is\nnot simply a piece of legacy technology that we have to accept\nand deal with. Instead, we aim to show you that hypermedia is a\ntremendously innovative, simple and flexible way to build\nrobust applications: Hypermedia-Driven Applications.We hope that by the end of this book you will feel, as we do, that\nthe hypermedia approach deserves a seat at the table when you, a web\ndeveloper, are considering the architecture of your next application.\nCreating a Hypermedia-Driven Application on top of a hypermedia\nsystem like the web is a viable and, indeed, often excellent choice\nfor modern web applications.(And, as the section on Hyperview will show, not just web\napplications.)Hypertexts: new forms of writing, appearing on computer screens, that\nwill branch or perform at the reader’s command. A hypertext is a\nnon-sequential piece of writing; only the computer display makes it\npractical. Ted Nelson,\nhttps://archive.org/details/SelectedPapers1977/page/n7/mode/2upLet us begin at the beginning: what is hypermedia?Hypermedia is a media, for example a text, that includes\nnon-linear branching from one location in the media to another,\nvia, for example, hyperlinks embedded in the media. The prefix “hyper-”\nderives from the Greek prefix “ὑπερ-” which means “beyond” or “over”,\nindicating that hypermedia goes beyond normal, passively\nconsumed media like magazines and newspapers.Hyperlinks are a canonical example of what is called a hypermedia\ncontrol:A hypermedia control is an element in a hypermedia that describes (or\ncontrols) some sort of interaction, often with a remote server, by\nencoding information about that interaction directly and completely\nwithin itself.Hypermedia controls are what differentiate hypermedia from other\nsorts of media.You may be more familiar with the term hypertext, from whose\nWikipedia page the above quote is taken. Hypertext is a sub-category of\nhypermedia and much of this book is going to discuss how to build modern\napplications using hypertexts such as HTML, the Hypertext Markup\nLanguage, or HXML, a hypertext used by the Hyperview mobile hypermedia\nsystem.Hypertexts like HTML function alongside other technologies crucial\nfor making an entire hypermedia system work: network protocols like\nHTTP, other media types such as images and videos, hypermedia servers\n(i.e., servers providing hypermedia APIs), sophisticated hypermedia\nclients (e.g., web browsers), and so on.Because of this, we prefer the broader term hypermedia\nsystems when describing the underlying architecture of applications\nbuilt using hypertext, to emphasize the system architecture over the\nparticular hypermedia being used.It is the entire hypermedia system architecture that is\nunderappreciated and ignored by many modern web developers.Where did the idea of hypermedia come from?While there were many precursors to the modern idea of hypertext and\nthe more general hypermedia, many people point to the 1945 article\nAs We May Think written by Vannevar Bush in The\nAtlantic as a starting point for looking at what has become modern\nhypermedia.In this article Bush described a device called a Memex, which, using\na complex mechanical system of reels and microfilm, along with an\nencoding system, would allow users to jump between related frames of\ncontent. The Memex was never actually implemented, but it was an\ninspiration for later work on the idea of hypermedia.The terms “hypertext” and “hypermedia” were coined in 1963 by Ted\nNelson, who would go on to work on the Hypertext Editing System\nat Brown University and who later created the File Retrieval and\nEditing System (FRESS), a shockingly advanced hypermedia system for\nits time. (This was perhaps the first digital system to have a notion of\n“undo”.)While Nelson was working on his ideas, Douglas Engelbart was busy at\nwork at the Stanford Research Institute, explicitly attempting to make\nVannevar Bush’s Memex a reality. In 1968, Englebart gave “The Mother of\nAll Demos” in San Francisco, California.Englebart demonstrated an unbelievable amount of technology:Remote, collaborative text editing with his peers in Menlo\nParkVideo and audio chatAn integrated windowing system, with window resizing,\netcA recognizable hypertext, whereby clicking on underlined text\nnavigated to new content.Despite receiving a standing ovation from a shocked audience after\nhis talk, it was decades before the technologies Englebart demonstrated\nbecame mainstream.In 1990, Tim Berners-Lee, working at CERN, published the first\nwebsite. He had been working on the idea of hypertext for a decade and\nhad finally, out of desperation at the fact it was so hard for\nresearchers to share their research, found the right moment and\ninstitutional support to create the World Wide Web:Creating the web was really an act of desperation, because the\nsituation without it was very difficult when I was working at CERN\nlater. Most of the technology involved in the web, like the hypertext,\nlike the Internet, multifont text objects, had all been designed\nalready. I just had to put them together. It was a step of generalising,\ngoing to a higher level of abstraction, thinking about all the\ndocumentation systems out there as being possibly part of a larger\nimaginary documentation system. Tim Berners-Lee,\nhttps://britishheritage.org/tim-berners-lee-the-world-wide-webBy 1994 his creation was taking off so quickly that Berners-Lee\nfounded the W3C, a working group of companies and researchers tasked\nwith improving the web. All standards created by the W3C were\nroyalty-free and could be adopted and implemented by anyone, cementing\nthe open, collaborative nature of the web.In 2000, Roy Fielding, then at U.C. Irvine, published a seminal PhD\ndissertation on the web: “Architectural Styles and the Design of\nNetwork-based Software Architectures.” Fielding had been working on the\nopen source Apache HTTP Server and his thesis was a description of what\nhe felt was a new and distinct networking architecture that had\nemerged in the early web. Fielding had worked on the initial HTTP\nspecifications and, in the paper, defined the web’s hypermedia network\nmodel using the term REpresentational State Transfer\n(REST).Fielding’s work became a major touchstone for early web developers,\ngiving them a language to discuss the new technical medium they were\nbuilding applications in.We will discuss Fielding’s key ideas in depth in Chapter 2, and try\nto correct the record with respect to REST, HATEOAS and hypermedia.In the beginning was the hyperlink, and the hyperlink was with the\nweb, and the hyperlink was the web. And it was good. Rescuing REST From the API Winter,\nhttps://intercoolerjs.org/2016/01/18/rescuing-rest.htmlThe system that Berners-Lee, Fielding and many others had created\nrevolved around a hypermedia: HTML. HTML started as a read-only\nhypermedia, used to publish (at first) academic documents. These\ndocuments were linked together via anchor tags which created\nhyperlinks between them, allowing users to quickly navigate\nbetween documents.When HTML 2.0 was released, it introduced the notion of the\nform tag, joining the anchor tag (i.e., hyperlink) as a\nsecond hypermedia control. The introduction of the form tag made\nbuilding applications on the web viable by providing a\nmechanism for updating resources, rather than just reading\nthem.It was at this point that the web transitioned from an interesting\ndocument-oriented system to a compelling application\narchitecture.Today HTML is the most widely used hypermedia in existence and this\nbook naturally assumes that the reader has a reasonable familiarity with\nit. You do not need to be an HTML (or CSS) expert to understand the code\nin this book, but the better you understand the core tags and concepts\nof HTML, the more you will get out of it.Let us consider these two defining hypermedia elements (that is the\ntwo defining hypermedia controls) of HTML, the anchor tag and\nthe form tag, in a bit of detail.Anchor tags are so familiar as to be boring but, as the original\nhypermedia control, it is worth reviewing the mechanics of hyperlinks to\nget our minds in the right place for developing a deeper understanding\nof hypermedia.Consider a simple anchor tag, embedded within a larger HTML\ndocument:A simple hyperlinkAn anchor tag consists of the tag itself,\n\u003ca\u003e\u003c/a\u003e, as well as the attributes and content\nwithin the tag. Of particular interest is the href\nattribute, which specifies a hypertext reference to another\ndocument or document fragment. It is this attribute that makes the\nanchor tag a hypermedia control.In a typical web browser, this anchor tag would be interpreted to\nmean:Show the text “Hypermedia Systems” in a manner indicating that it\nis clickableWhen the user clicks on that text, issue an HTTP GET\nrequest to the URL https://hypermedia.systems/Take the HTML content in the body of the HTTP response to this\nrequest and replace the entire screen in the browser as a new document,\nupdating the navigation bar to this new URL.Anchors provide the main mechanism we use to navigate around the web\ntoday, by selecting links to navigate from document to document, or from\nresource to resource. [fig-get-in-action] shows what a user interaction with\nan anchor tag/hyperlink looks like in visual form.An HTTP GET In ActionWhen the link is clicked the browser (or, as we sometimes refer to\nit, the hypermedia client) initiates an HTTP GET\nrequest to the URL encoded in the link’s href\nattribute.Note that the HTTP request includes additional data (i.e.,\nmetadata) on what, exactly, the browser wants from the server,\nin the form of headers. We will discuss these headers, and HTTP in more\ndepth in Chapter 2.The hypermedia server then responds to this request with a\nhypermedia response — the HTML — for the new page. This may\nseem like a small and obvious point, but it is an absolutely crucial\naspect of a truly RESTful hypermedia system: the client and\nserver must communicate via hypermedia!Anchor tags provide navigation between documents or\nresources, but don’t allow you to update those resources. That\nfunctionality falls to the form tag.Here is a simple example of a form in HTML:A simple formLike an anchor tag, a form tag consists of the tag itself,\n\u003cform\u003e\u003c/form\u003e, combined with the attributes and\ncontent within the tag. Note that the form tag does not have an\nhref attribute, but rather has an action\nattribute that specifies where to issue an HTTP request.Furthermore, it also has a method attribute, which\nspecifies exactly which HTTP “method” to use. In this example the form\nis asking the browser to issue a POST request.In contrast with anchor tags, the content and tags within a\nform can have an effect on the hypermedia interaction that the form\nmakes with a server. The values of input tags and\nother tags such as select tags will be included with the\nHTTP request when the form is submitted, as URL parameters in the case\nof a GET and as part of the request body in the case of a\nPOST. This allows a form to include an arbitrary amount of\ninformation collected from a user in a request, unlike the anchor\ntag.In a typical browser this form tag and its contents would be\ninterpreted by the browser roughly as follows:Show a text input and a “Sign Up” button to the userWhen the user submits the form by clicking the “Sign Up” button\nor by hitting the enter key while the input element is focused, issue an\nHTTP POST request to the path /signup on the\n“current” serverTake the HTML content in the body of the HTTP response body and\nreplace the entire screen in the browser as a new document, updating the\nnavigation bar to this new URL.This mechanism allows the user to issue requests to update the\nstate of resources on the server. Note that despite this new type\nof request the communication between client and server is still done\nentirely with hypermedia.It is the form tag that makes Hypermedia-Driven Applications\npossible.If you are an experienced web developer you probably recognize that\nwe are omitting a few details and complications here. For example, the\nresponse to a form submission often redirects the client to a\ndifferent URL.This is true, and we will get down into the muck with forms in more\ndetail in later chapters but, for now, this simple example suffices to\ndemonstrate the core mechanism for updating system state purely within\nhypermedia. [fig-post-in-action] is a diagram of the\ninteraction.An HTTP POST In ActionAs someone interested in web development, the above diagrams and\ndiscussion are probably very familiar to you. You may even find this\ncontent boring. But take a step back and consider the fact that these\ntwo hypermedia controls, anchors and forms, are the only native\nways for a user to interact with a server in plain HTML.Only two tags!And yet, armed with only these two tags, the early web was able to\ngrow exponentially and offer a staggeringly large amount of online,\ndynamic functionality to billions of people.This is strong evidence of the power of hypermedia. Even today, in a\nweb development world increasingly dominated by large JavaScript-centric\nfront end frameworks, many people choose to use simple vanilla HTML to\nachieve their application goals and are often perfectly happy with the\nresults.These two tags give a tremendous amount of expressive power to\nHTML.So links and forms are the two main hypermedia-based mechanisms for\ninteracting with a server available in HTML.Now let’s consider a different approach: let’s interact with a server\nby issuing an HTTP request via JavaScript. To do this, we will use the\nfetch()\nAPI, a popular API for issuing an “Asynchronous JavaScript and XML,” or\nAJAX request, available in all modern web browsers:JavaScriptIssue the request.Convert the response to a JavaScript object.Invoke the updateUI() function with the\nobject.This button has an onclick attribute that specifies some\nJavaScript to run when the button is clicked.The JavaScript will issue an AJAX HTTP GET request to\n/api/v1/contacts/1 using fetch(). An AJAX\nrequest is like a “normal” HTTP request, but it is issued “behind the\nscenes” by the browser. The user does not see a request indicator from\nthe browser as they would with normal links and forms. Additionally,\nunlike requests issued by those hypermedia controls, it is up to the\nJavaScript code to handle the response from the server.Despite AJAX having XML as part of its acronym, today the HTTP\nresponse to this request would almost certainly be in the JavaScript\nObject Notation (JSON) format rather than XML.An HTTP response to this request might look something like this:JSONThe start of a JSON object.A property, in this case with the name id and the\nvalue 42.Another property, the email of the contact with this id.The JavaScript code above converts the JSON text received from the\nserver into a JavaScript object by calling the json()\nmethod on it. This new JavaScript object is then handed off to the\nupdateUI() method.The updateUI() method is responsible for updating the UI\nbased on the data encoded in the JavaScript Object, perhaps by\ndisplaying the contact in a bit of HTML generated via a client-side\ntemplate in the JavaScript application.The details of exactly what the updateUI() function does\naren’t important for our discussion.What is important, what is the crucial aspect of\nthis JSON-based server interaction is that it is not using\nhypermedia. The JSON API being used here does not return a hypermedia\nresponse. There are no hyperlinks or other hypermedia-style\ncontrols in it.This JSON API is, rather, a Data API.Because the response is in JSON and is not hypermedia, the\nJavaScript updateUI() method must understand how to turn\nthis contact data into HTML.In particular, the code in updateUI() needs to know\nabout the internal structure and meaning of the data.It needs to know:Exactly how the fields in the JSON data object are structured and\nnamed.How they relate to one another.How to update the local data this new data corresponds\nwith.How to render this data to the browser.What additional actions/API end points can be called with this\ndata.In short, the logic in updateUI() needs to have intimate\nknowledge of the API endpoint at /api/v1/contact/1,\nknowledge provided via some side-channel beyond the response itself. As\na result, the updateUI() code and the API have a strong\nrelationship, known as tight coupling: if the format of the\nJSON response changes, then the code for updateUI() will\nalmost certainly also need to be changed as well.This bit of JavaScript, while very modest, is the organic beginnings\nof a much larger conceptual approach to building web applications. This\nis the beginning of a Single Page Application (SPA). The web\napplication is no longer navigating between pages using\nhypermedia controls as was the case with links and forms.Instead, the application is exchanging plain data with the\nserver and then updating the content within a single page.When this strategy or architecture is adopted for an entire\napplication, everything happens on a “Single Page” and, thus the\napplication becomes a “Single Page Application.”The Single Page Application architecture is extremely popular today\nand has been the dominant approach to building web applications for the\nlast decade. This can be observed by the high level of mind-share and\ndiscussion it has received in the industry.Today the vast majority of Single Page Applications adopt far more\nsophisticated frameworks for managing their user interface than this\nsimple example shows. Popular libraries such as React, Angular, Vue.js,\netc. are now the common — indeed, the standard — way to build web\napplications.With these more complex frameworks developers typically work with an\nelaborate client-side model — that is, with JavaScript objects stored\nlocally in the browser’s memory that represent the “model” or “domain”\nof your application. These JavaScript objects are updated via JavaScript\ncode and the framework then “reacts” to these changes, updating the user\ninterface.When the user interface is updated by a user these changes also flow\ninto the model objects, establishing a “two-way” binding\nmechanism: the model can update the UI, and the UI can update the\nmodel.This is a much more sophisticated approach to a web client than\nhypermedia, and it typically does away almost entirely with the\nunderlying hypermedia infrastructure available in the browser.HTML is still used to build user interfaces, but the\nhypermedia aspect of the two major hypermedia controls, anchors\nand forms, are unused. Neither tag interacts with a server via their\nnative hypermedia mechanism. Rather, they become user interface\nelements that drive local interactions with the in-memory domain model\nvia JavaScript, which is then synchronized with the server using plain\ndata JSON APIs.So, as with our simple button above, the Single Page Application\napproach foregoes the hypermedia architecture. It leaves aside the\nadvantages of the existing RESTful architecture of the web and the\nbuilt-in functionality found in HTML’s native hypermedia controls in\nfavor of JavaScript driven behaviors.SPAs are much more like thick client applications, that is,\nlike the client-server applications of the 1980s — an architecture\npopular before the web came along and that the web was, in many\nways, a reaction to.This approach isn’t necessarily wrong, of course: there are times\nwhen a thick client approach is the appropriate choice for an\napplication. But it is worth thinking about why web developers\nso frequently make this choice without considering other alternatives,\nand if there are reasons not to go down this path.The emerging norm for web development is to build a React single-page\napplication, with server rendering. The two key elements of this\narchitecture are something like:The main UI is built \u0026 updated in JavaScript using React or\nsomething similar.The backend is an API that that application makes requests\nagainst.This idea has really swept the internet. It started with a few major\npopular websites and has crept into corners like marketing sites and\nblogs. Tom MacWright, https://macwright.com/2020/05/10/spa-fatigue.htmlThe JavaScript-based Single Page Application approach has taken the\nweb development world by storm, and if there was one single reason for\nits wild success it was this: The Single Page Application offers a far\nmore interactive and immersive experience than the old, gronky, Web 1.0\nhypermedia-based applications could. SPAs had the ability to smoothly\nupdate elements inline on a page without a dramatic reload of the entire\ndocument, they had the ability to use CSS transitions to create nice\nvisual effects, and the ability to hook into arbitrary events like mouse\nmovements.All of these abilities give JavaScript-based applications a huge\nadvantage in building sophisticated user experiences.Given the popularity, power and success of this modern approach to\nbuilding web applications, why on earth would you consider an older,\nclunkier and less popular approach like hypermedia?We are glad you asked!It turns out that the hypermedia architecture, even in its original\nWeb 1.0 form, has a number of advantages when compared with the Single\nPage Application + JSON Data API approach. Three of the biggest are:It is an extremely simple approach to building web\napplications.It is extremely tolerant of content and API changes. In fact, it\nthrives on them!It leverages tried and true features of web browsers, such as\ncaching.The first two advantages, in particular, address major pain points in\nmodern web development:Single Page Application infrastructure has become extremely\ncomplex, often requiring an entire team to manage.JSON API churn — constant changes made to JSON APIs to support\napplication needs — has become a major pain point for many application\nteams.The combination of these two problems, along with other issues such\nas JavaScript library churn, has led to a phenomenon known as\n“JavaScript Fatigue.” This refers to a general sense of exhaustion with\nall the hoops that are necessary to jump through to get anything done in\nmodern-day web applications.We believe that a hypermedia architecture can help cure JavaScript\nFatigue for many developers and teams.But if hypermedia is so great, and if it addresses so many of the\nproblems that beset the web development industry, why was it set aside\nin the first place? After all, hypermedia was there first. Why didn’t\nweb developers just stick with it?There are two major reasons hypermedia hasn’t made a comeback in web\ndevelopment.The first is this: the expressiveness of HTML as a\nhypermedia hasn’t changed much, if at all, since HTML 2.0, which\nwas released in the mid 1990s. Many new features have\nbeen added to HTML, of course, but there haven’t been any major\nnew ways to interact with a server in HTML in almost three decades.HTML developers still only have anchor tags and forms available as\nhypermedia controls, and those hypermedia controls can still only issue\nGET and POST requests.This baffling lack of progress by HTML leads immediately to the\nsecond, and perhaps more practical reason that HTML-as-hypermedia has\nfallen on hard times: as the interactivity and expressiveness of HTML\nhas remained frozen, the demands of web users have continued to\nincrease, calling for more and more interactive web applications.JavaScript-based applications coupled to data-oriented JSON APIs have\nstepped in as a way to provide these more sophisticated user interfaces.\nIt was the user experience that you could achieve in\nJavaScript, and that you couldn’t achieve in plain HTML, that drove the\nweb development community to the JavaScript-based Single Page\nApplication approach. The shift was not driven by any inherent\nsuperiority of the Single Page Application as a system architecture.It didn’t have to be this way. There is nothing intrinsic to\nthe idea of hypermedia that prevents it from having a richer, more\nexpressive interactivity model than vanilla HTML. Rather than moving\naway from a hypermedia-based approach, the industry could have demanded\nmore interactivity from HTML.Instead, building thick-client style applications within web browsers\nbecame the standard, in an understandable move to a more familiar model\nfor building rich applications.Not everyone set aside hypermedia, of course. There have been heroic\nefforts to continue to advance hypermedia outside of HTML, efforts like\nHyTime, VoiceXML, and HAL.But HTML, the most widely used hypermedia in the world, stopped\nmaking progress as a hypermedia. The web development world moved on,\nsolving the interactivity problems with HTML by adopting\nJavaScript-based SPAs and, mostly inadvertently, a completely different\nsystem architecture.It is interesting to think about how HTML could have\nadvanced. Instead of stalling as a hypermedia, how could HTML have\ncontinued to develop? Could it have kept adding new hypermedia controls\nand increasing the expressiveness of existing ones? Would it have been\npossible to build modern web applications within this original,\nhypermedia-oriented and RESTful model that made the early web so\npowerful, so flexible, so much fun?This might seem like idle speculation, but we have some good news on\nthis score: in the last decade a few idiosyncratic, alternative front\nend libraries have arisen that attempt to get HTML moving again.\nIronically, these libraries are written in JavaScript, the technology\nthat supplanted HTML as the center of web development.However, these libraries use JavaScript not as a replacement\nfor the fundamental hypermedia system of the web.Instead, they use JavaScript to augment HTML itself as a\nhypermedia.These hypermedia-oriented libraries re-center hypermedia as\nthe core technology in web applications.In the web development world there is an ongoing debate between the\nSingle Page Application (SPA) approach and what is now being called the\n“Multi-Page Application” (MPA) approach. MPA is a modern name for the\nold, Web 1.0 way of building web applications, using links and forms\nlocated on multiple web pages, submitting HTTP requests and getting HTML\nresponses.MPA applications, by their nature, are Hypermedia-Driven\nApplications: after all, they are exactly what Roy Fielding was\ndescribing in his dissertation.These applications tend to be clunky, but they work reasonably well.\nMany web developers and teams choose to accept the limitations of plain\nHTML in the interest of simplicity and reliability.Rich Harris, creator of Svelte.js, a popular SPA library, and a\nthought-leader on the SPA side of the debate, has proposed a mix of this\nolder MPA style and the newer SPA style. Harris calls this approach to\nbuilding web applications “transitional,” in that it attempts to blend\nthe MPA approach and the newer SPA approach into a coherent whole. (This\nis somewhat similar to the “transitional” trend in architecture, which\ncombines traditional and modern architectural styles.)“Transitional” is a fitting term for mixed-style applications, and it\noffers a reasonable compromise between the two approaches, using either\none as appropriate on a case-by-case basis.But this compromise still feels unsatisfactory.Must we default to having these two very different architectural\nmodels in our applications?Recall that the crux of the trade-off between SPAs and MPAs is the\nuser experience, or interactivity of the application. This\ntypically drives the decision to choose one approach versus the other\nfor an application or — in the case of a “transitional” application —\nfor a particular feature.It turns out that by adopting a hypermedia-oriented library, the\ninteractivity gap between the MPA and the SPA approach closes\ndramatically. You can use the MPA approach, that is, the hypermedia\napproach, for much more of your application without compromising your\nuser interface. You might even be able to use the hypermedia approach\nfor all your application needs.Rather than having an SPA with a bit of hypermedia around the edges,\nor some mix of the two approaches, you can often create a web\napplication that is primarily or entirely\nhypermedia-driven, and that still satisfies the interactivity that your\nusers require.This can tremendously simplify your web application and\nproduce a much more coherent and understandable piece of software. While\nthere are still times and places for the more complex SPA approach,\nwhich we will discuss later in the book, by adopting a hypermedia-first\napproach and using a hypermedia-oriented library to push HTML as far as\npossible, your web application can be powerful, interactive and\nsimple.One such hypermedia oriented library is htmx. Htmx will be the focus of Part Two of\nthis book. We show that you can, in fact, create many common “modern” UI\nfeatures found in sophisticated Single Page Applications by instead\nusing the hypermedia model.And, it is refreshingly fun and simple to do so.When building a web application with htmx the term Multi-Page\nApplication applies roughly, but it doesn’t fully characterize\nthe core of the application architecture. As you will see, htmx doesn’t\nneed to replace entire pages, and, in fact, an htmx-based\napplication can reside entirely within a single page. We don’t recommend\nthis practice, but it is possible!So it isn’t quite right to call web applications built with htmx\n“Multi-Page Applications.” What the older Web 1.0 MPA approach and the\nnewer hypermedia-oriented library powered applications have in common is\ntheir use of hypermedia as their core technology and\narchitecture.Therefore, we use the term Hypermedia-Driven Applications\n(HDAs) to describe both.This clarifies that the core distinction between these two approaches\nand the SPA approach isn’t the number of pages in the\napplication, but rather the underlying system architecture.A web application that uses hypermedia and hypermedia\nexchanges as its primary mechanism for communicating with a\nserver.So, what does an HDA look like up close?Let’s look at an htmx-powered implementation of the simple\nJavaScript-powered button above:An htmx implementationissues a GET request to /contacts/1,\nreplacing the contact-ui.As with the JavaScript powered button, this button has been annotated\nwith some attributes. However, in this case we do not have any\n(explicit) JavaScript scripting.Instead, we have declarative attributes much like the\nhref attribute on anchor tags and the action\nattribute on form tags. The hx-get attribute tells htmx:\n“When the user clicks this button, issue a GET request to\n/contacts/1.” The hx-target attribute tells\nhtmx: “When the response returns, take the resulting HTML and place it\ninto the element with the id contact-ui.”Here we get to the crux of htmx and how it allows you to build\nHypermedia-Driven Applications:The HTTP response from the server is expected to be in HTML\nformat, not JSON.An HTTP response to this htmx-driven request might look something\nlike this:HTMLThis small bit of HTML would be placed into the element in the DOM\nwith the id contact-ui.Thus, this htmx-powered button is exchanging hypermedia with\nthe server, just like an anchor tag or form might, and thus the\ninteraction is still using the basic hypermedia model of the web. Htmx\nis adding functionality to this button (via JavaScript), but\nthat functionality is augmenting HTML as a hypermedia. Htmx\nextends the hypermedia system of the web, rather than replacing\nthat hypermedia system with a totally different architecture.Despite looking superficially similar to one another it turns out\nthat this htmx-powered button and the JavaScript-based button are using\nextremely different system architectures and, thus, approaches to web\ndevelopment.As we walk through building a Hypermedia-Driven Application in this\nbook, the differences between the two approaches will become more and\nmore apparent.Hypermedia is often, though not always, a great choice for a\nweb application.Perhaps you are building a website or application that simply doesn’t\nneed a huge amount of user-interactivity. There are many useful\nweb applications like this, and there is no shame in it! Applications\nlike Amazon, eBay, any number of news sites, shopping sites, message\nboards and so on don’t need a massive amount of interactivity to be\neffective: they are mainly text and images, which is exactly what the\nweb was designed for.Perhaps your application adds most of its value on the server\nside, by coordinating users or by applying sophisticated data\nanalysis and then presenting it to a user. Perhaps your application adds\nvalue by simply sitting in front of a well-designed database, with\nsimple Create-Read-Update-Delete (CRUD) operations. Again, there is no\nshame in this!In any of these cases, using a hypermedia approach would likely be a\ngreat choice: the interactivity needs of these applications are not\ndramatic, and much of the value of these applications lives on the\nserver side, rather than on the client side.All of these applications are amenable to what Roy Fielding called\n“large-grain hypermedia data transfers”: you can simply use anchor tags\nand forms, with responses that return entire HTML documents from\nrequests, and things will work just fine. This is exactly what the web\nwas designed to do!By adopting the hypermedia approach for these applications, you will\nsave yourself a huge amount of client-side complexity that comes with\nadopting the Single Page Application approach: there is no need for\nclient-side routing, for managing a client-side model, for hand-wiring\nin JavaScript logic, and so forth. The back button will “just work.”\nDeep linking will “just work.” You will be able to focus your efforts on\nyour server, where your application is actually adding value.And, by layering htmx or another hypermedia-oriented library on top\nof this approach, you can address many of the usability issues that come\nwith vanilla HTML and take advantage of finer-grained hypermedia\ntransfers. This opens up a whole slew of new user interface and\nexperience possibilities, making the set of applications that can be\nbuilt using hypermedia much larger.But more on that later.So, what about that not always? When isn’t hypermedia going\nto work well for an application?One example that springs immediately to mind is an online spreadsheet\napplication. In the case of a spreadsheet, updating one cell could have\na large number of cascading changes that need to be made across the\nentire sheet. Worse, this might need to happen on every\nkeystroke.In this case we have a highly dynamic user interface without clear\nboundaries as to what might need to be updated given a particular\nchange. Introducing a hypermedia-style server round-trip on every cell\nchange would hurt performance tremendously.This is simply not a situation amenable to the “large-grain\nhypermedia data transfer” approach of the web. For an application like\nthis we would certainly recommend looking into using a sophisticated\nclient-side JavaScript approach.However even in the case of an online spreadsheet there are\nlikely areas where the hypermedia approach might help.The spreadsheet application likely also has a settings page. And\nperhaps that settings page is amenable to the hypermedia\napproach. If it is simply a set of relatively straight-forward forms\nthat need to be persisted to the server, the chances are good that\nhypermedia would, in fact, work great for this part of the app.And, by adopting hypermedia for that part of your application, you\nmight be able to simplify that part of the application quite a bit. You\ncould then save more of your application’s complexity budget\nfor the core, complicated spreadsheet logic, keeping the simple stuff\nsimple.Why waste all the complexity associated with a heavy JavaScript\nframework on something as simple as a settings page?A Complexity BudgetAny software project has a complexity budget, explicit or not: there\nis only so much complexity a given development team can tolerate and\nevery new feature and implementation choice adds at least a bit more to\nthe overall complexity of the system.What is particularly nasty about complexity is that it tends to grow\nexponentially: one day you can keep the entire system in your head and\nunderstand the ramifications of a particular change, and a week later\nthe whole system seems intractable. Even worse, efforts to help control\ncomplexity, such as introducing abstractions or infrastructure to manage\nthe complexity, often end up making things even more complex. Truly, the\njob of the good software engineer is to keep complexity under\ncontrol.The sure-fire way to keep complexity down is also the hardest: say\nno. Pushing back on feature requests is an art and, if you can learn to\ndo it well, making people feel like they said no, you will go\nfar.Sadly this is not always possible: some features will need to be\nbuilt. At this point the question becomes: “what is the simplest thing\nthat could possibly work?” Understanding the possibilities available in\nthe hypermedia approach will give you another tool in your “simplest\nthing” tool chest.Hypermedia is often regarded as an old and antiquated technology in\nweb development circles, useful perhaps for static websites but\ncertainly not a realistic choice for modern, sophisticated web\napplications.Seriously? Are we claiming that modern web applications can be built\nusing it?Yes, seriously.Contrary to current popular opinion, hypermedia is an\ninnovative and modern system architecture for building\napplications, in some ways more modern than the prevailing\nSingle Page Application approaches. In the remainder of this book we\nwill reintroduce you to the core, practical concepts of hypermedia and\nthen demonstrate exactly how you can take advantage of this system\narchitecture in your own software.In the coming chapters you will develop a firm understanding of all\nthe benefits and techniques enabled by this approach. We hope that, in\naddition, you will also become as passionate about it as we are. The best-known kind of messy HTML is \u003cdiv\u003e\nsoup.When developers fall back on the generic \u003cdiv\u003e and\n\u003cspan\u003e elements instead of more meaningful tags, we\neither degrade the quality of our websites or create more work for\nourselves — probably both.For example, instead of adding a button using the dedicated\n\u003cbutton\u003e element, a \u003cdiv\u003e element\nmight have a click event listener added to it.There are two main issues with this button:It’s not focusable — the Tab key won’t get you to it.There’s no way for assistive tools to tell that it’s a\nbutton.Yes, we can fix that by adding role=\"button\" and\ntabindex=\"0\":These are easy fixes, but they’re things you have to\nremember. It’s also not obvious from the HTML source that this\nis a button, making the source harder to read and the absence of these\nattributes harder to spot. The source code of pages with div soup is\ndifficult to edit and debug.To avoid div soup, become friendly with the HTML spec of available\ntags, and consider each tag another tool in your tool chest. There might\nbe things there you don’t remember from before! (With the 113 elements\ncurrently defined in the spec, it’s more of a tool shed).Of course, not every UI pattern has a designated HTML element. We\noften need to compose elements and augment them with attributes. Before\nyou do, though, rummage through the HTML tool chest. Sometimes you might\nbe surprised by how much is available."
 },
 {
 "chapter": "Introduction",
 "content": "This is a book about building applications using hypermedia systems.\nHypermedia systems might seem like a strange phrase: how is\nhypermedia a system? Isn’t hypermedia just a way to link\ndocuments together?Like with HTML, on the World Wide Web?What do you mean hypermedia systems?Well, yes, HTML is a hypermedia. But there is more to the\nway the web works than just HTML: HTTP, the Hyper Text Transfer\nProtocol, is what transfers HTML from servers to clients, and there are\nmany details and features associated with it: caching, various headers,\nresponse codes, and so forth.And then, of course, there are hypermedia servers, which\npresent hypermedia APIs (yes, APIs) to clients over\nthe network.And, finally, there is the all-important hypermedia client:\na software client that understands how to render a hypermedia\nresponse intelligibly to a human, so that a human can interact with\nthe remote system. The most widely known and used hypermedia clients\nare, of course, web browsers.Web browsers are perhaps the most sophisticated pieces of software we\nuse. They not only understand HTML, CSS and many other file formats, but\nthey also provide a JavaScript runtime and programming environment that\nis so powerful that web developers can create entire applications in it\nthat are nearly as sophisticated as thick clients, that is,\nnative applications.This JavaScript runtime is so powerful, in fact, that today many\ndevelopers ignore the hypermedia features of the browser, in\nfavor of building their web applications entirely in JavaScript.\nApplications built in this manner have come to be called Single Page\nApplications (SPAs). Rather than navigating between pages, these web\napplications use JavaScript for updating the user interface directly.\nWhen they communicate with a server, these applications typically use\nJSON API calls via AJAX. And they often update the user interface using\na “reactive” style frontend JavaScript library.In these applications HTML becomes a (somewhat awkward) graphical\ninterface description language that is used because, for historical\nreasons, that’s what happens to be there, in the browser.Applications built in this style are not hypermedia-driven:\nthey do not take advantage of the underlying hypermedia system of the\nweb.To explain what a hypermedia-driven application looks like, and to\ncontrast it with the popular SPA approach of today, we need to first\nexplore the entire hypermedia system of the web, beyond just\ndiscussing HTML. We need to look at the network architecture of\nthe web, including how a web server delivers a hypermedia API, and how\nto effectively use the hypermedia features available in the hypermedia\nclient (e.g., the browser).Each of these are important aspects of building an effective\nhypermedia-driven application, and it is the entire hypermedia\nsystem that comes together to make hypermedia such a powerful\narchitecture.To understand what a hypermedia system is we’ll first take an\nin-depth look at the canonical hypermedia system: the World\nWide Web. Roy Fielding, an engineer who helped create specifications and\nbuild the implementations of many early pieces of the web, gave us the\nterm REpresentational State Transfer, or REST. In his PhD dissertation\nhe described REST as a network architecture, and he contrasted\nit with earlier approaches to building distributed software.We define a hypermedia system as a system that adheres to\nthe RESTful network architecture in Fielding’s original sense\nof this term.Unfortunately, today, you probably associate the term “REST” with\nJSON APIs, since that is where the term is typically used in industry.\nThis is a misapplied use of the term REST because JSON is not a\nnatural hypermedia due to the absence of hypermedia controls.\nThe exchange of hypermedia is an explicit requirement for a system to be\nconsidered “RESTful.” It is a long story how we got here, using the term\nREST so incorrectly, and we will go into the details later in this book.\nBut, for now, if you think REST implies JSON, please try to set that\nunderstanding aside while reading this book, and come to the concept\nwith fresh eyes.It is important to understand that, in his dissertation, Fielding was\ndescribing The World Wide Web as it existed in the late 1990s. The web,\nat that point, was simply web browsers exchanging hypermedia. That\nsystem, with its simple links and forms, was what Fielding was calling\nRESTful.JSON APIs were a decade away from becoming a common tool in web\ndevelopment: REST was about hypermedia and the 1.0 version of\nthe web.In this book we are going to take a look at hypermedia as a\nsystem architecture and then explore some practical,\nmodern approaches to building web applications using it. We\nwill call applications built in this style Hypermedia-Driven\nApplications, or HDAs, and we contrast them with a popular style in\nuse today, the Single Page Application.A Hypermedia-Driven Application is an application built on top of a\nhypermedia system that respects and utilizes the hypermedia\nfunctionality of that underlying system.The goal of this book is to give you a strong sense of how the\nRESTful, hypermedia system architecture differs from other\nclient-server systems, and what the strengths (and weaknesses) of the\nhypermedia approach are. Further, we hope to convince you that the\nhypermedia architecture is relevant to developers building\nmodern web applications.We aim to give you the tools to evaluate the requirements for an\napplication and answer the question:“Could I build this as a Hypermedia-Driven Application?”We hope that for many applications the answer to that question will\nbe “Yes!”The book is broken into three parts:An introduction (or re-introduction) to hypermedia, with a\nparticular focus on HTML and HTTP. We will finish this review of core\nhypermedia concepts by creating a simple “Web 1.0“-style application,\nContact.app, for managing contacts.Next we will look at how we can use htmx, a hypermedia-oriented JavaScript\nlibrary created by the authors of this book, to improve Contact.app. By\nusing htmx, we will be able to achieve a level of interactivity in our\napplication that many developers would expect to require a large,\nsophisticated front end library, such as React. Thanks to htmx, we will\nbe able to do this using hypermedia as our system architecture.Finally, we will look at a completely different hypermedia\nsystem, Hyperview. Hyperview is a mobile hypermedia system,\nrelated to, but distinct from the web and created by one of the authors\nof this book – Adam Stepinski. It supports mobile specific\nfeatures by providing not only a mobile specific hypermedia, but also a\nmobile hypermedia client. These novel components, combined with any HTTP\nserver, make it possible to build mobile Hypermedia-Driven\nApplications.Note that each section is somewhat independent of the\nothers. If you already know hypermedia in-depth and how basic Web 1.0\napplications function, you may want to skip ahead to the second section\non htmx and how to build modern web applications using hypermedia.\nSimilarly, if you are well versed in htmx and want to dive into a novel\nmobile hypermedia, you can skip ahead to the Hyperview\nsection.That being said, the book is designed to be read in order and both\nthe htmx and Hyperview sections build on the Web 1.0 application\ndescribed at the end of the first section. Furthermore, even if you\nare well versed in all the concepts of hypermedia and details\nof HTML \u0026 HTTP, it is likely worth it to at least skim through the\nfirst few chapters for a refresher.Hypermedia isn’t a frequent topic of discussion these days. Even many\nolder programmers who grew up with the web in the late 1990s and early\n2000s haven’t thought much about these ideas in years. Many younger web\ndevelopers have grown up knowing nothing but Single Page Applications\nand the frameworks that are used to build them.In particular, many young web developers began their careers by\nbuilding React.js applications that interact with a Node server using a\nJSON API; they may never have learned about hypermedia as a system at\nall.This is a tragedy, and, frankly, a failure on the part of the thought\nleaders in the web development community to properly communicate and\nadvocate for the hypermedia approach.Hypermedia was a great idea! It still is!By the end of this book, you will have the tools and the\nlanguage to put this great idea to work in your own\napplications. And, further, you will be able to bring the ideas and\nconcepts of hypermedia systems to the broader web development\ncommunity.Hypermedia can compete, hypermedia can win, hypermedia\nhas won as an architectural choice against the Single Page\nApplication approach, but only if smart people (like you) learn\nabout it, build with it and then tell the world about it.Remember the message? “The future is not set. There is no fate but\nwhat we make for ourselves.” Kyle Reese, Terminator 2: Judgement DayClearly, HTML plays a central role in the story we tell here. At the\nend of each chapter we will share what we have learned about writing\nHTML for hypermedia-driven web applications.To start, remember that our web applications are not islands. We’re\nwriting HTML not just for a particular application, but also to play\nalong with other members of the web. When we write with the hypermedia\nsystem in mind, we’re better able to tap the range of abilities\navailable to the web.HTML is hypermedia-friendly when it is written for the full range of\nconstituents of the hypermedia system. It conveys the state of an\napplication to people viewing our sites with a browser, as well as to\npeople listening to screen readers that read sites aloud. It conveys the\naims of our sites to search engines that scrape sites programmatically.\nIt also conveys its behavior as clearly as possible to other\ndevelopers.No, we can’t fix every problem with good HTML. The mantra that HTML\nis “accessible by default” is misleading. We would miss out on important\nopportunities if we shunned other technologies like JavaScript. And we\nstill need to test, a lot, everywhere, to ensure things work as\nexpected.But good HTML lets browsers do a lot of work for us."
 },
 {
 "chapter": "A Web 1.0 Application",
 "content": "To start our journey into Hypermedia-Driven Applications, we are\ngoing to create a simple contact management web application called\nContact.app. We will start with a basic, “Web 1.0-style” Multi-Page\nApplication (MPA), in the grand CRUD (Create, Read, Update, Delete)\ntradition. It will not be the best contact management application in the\nworld, but it will be simple and it will do its job.This application will also be easy to incrementally improve in the\ncoming chapters by utilizing the hypermedia-oriented library htmx.By the time we are finished building and enhancing the application,\nover the next few chapters, it will have some very slick features that\nmost developers today would assume requires the use of a SPA JavaScript\nframework.In order to demonstrate how web 1.0 applications work, we need to\npick a server-side language and a library for handling HTTP requests.\nColloquially, this is called our “Server-Side” or “Web” stack, and there\nare literally hundreds of options to choose from, many with passionate\nfollowings. You probably have a web framework that you prefer and, while\nwe wish we could write this book for every possible stack out there, in\nthe interest of simplicity (and sanity) we can only pick one.For this book we are going to use the following stack:Python as our programming\nlanguage.Flask as our\nweb framework, allowing us to connect HTTP requests to Python\nlogic.Jinja2 for our\nserver-side templating language, allowing us to render HTML responses\nusing a familiar and intuitive syntax.Why this particular stack?Python is the most popular programming language in the world, as of\nthis writing, according to the TIOBE index, a respected\nmeasure of programming language popularity. More importantly, Python is\neasy to read even if you aren’t familiar with it.We chose the Flask web framework because it is simple and does not\nimpose a lot of structure on top of the basics of HTTP request\nhandling.This bare-bones approach is a good match for our needs: in other\ncases you might consider a more full-featured Python framework, such as\nDjango, which supplies much\nmore functionality out of the box than Flask does.By using Flask for our book, we will be able to keep our code focused\non hypermedia exchanges.We picked Jinja2 templates because they are the default templating\nlanguage for Flask. They are simple enough and similar enough to most\nother server-side templating languages that most people who are familiar\nwith any server-side (or client-side) templating library should be able\nto understand them quickly and easily.Even if this combination of technologies isn’t your preferred stack,\nplease, keep reading: you will learn quite a bit from the patterns we\nintroduce in the coming chapters and it shouldn’t be hard to map them\ninto your preferred language and frameworks.With this stack we will be rendering HTML on the server-side\nto return to clients, rather than producing JSON. This is the\ntraditional approach to building web applications. However, with the\nrise of SPAs, this approach is not as widely used a technique as it once\nwas. Today, as people are rediscovering this style of web applications,\nthe term “Server-Side Rendering” or SSR is emerging as the way that\npeople talk about it. This contrasts with “Client-Side Rendering”, that\nis, rendering templates in the browser with data retrieved in JSON form\nfrom the server, as is common in SPA libraries.In Contact.app we will intentionally keep things as simple as\npossible to maximize the teaching value of our code: it won’t be\nperfectly factored code, but it will be easy to follow for readers, even\nif they have little Python experience, and it should be easy to\ntranslate both the application and the techniques demonstrated into your\npreferred programming environment.Since this book is for learning how to use hypermedia effectively,\nwe’ll just briefly introduce the various technologies we use\naround that hypermedia. This has some obvious drawbacks: if you\naren’t comfortable with Python, for example, some example Python code in\nthe book may be a bit confusing or mysterious at first.If you feel like you need a quick introduction to the language before\ndiving into the code, we recommend the following books and websites:Python Crash\nCourse from No Starch PressLearn Python\nThe Hard Way by Zed ShawPython For Everybody by Dr.\nCharles R. SeveranceWe think most web developers, even developers who are unfamiliar with\nPython, should be able to follow along with our examples. Most of the\nauthors of this book hadn’t written much Python before writing it, and\nwe got the hang of it pretty quickly.Flask is a simple but flexible web framework for Python. We’ll ease\ninto it by touching on its core elements.A Flask application consists of a series of routes tied to\nfunctions that execute when an HTTP request to a given path is made. It\nuses a Python feature called “decorators” to declare the route that will\nbe handled, which is then followed by a function to handle requests to\nthat route. We’ll use the term “handler” to refer to the functions\nassociated with a route.Let’s create our first route definition, a simple “Hello World”\nroute. In the following Python code you will see the @app\nsymbol. This is the flask decorator that allows us to set up our routes.\nDon’t worry too much about how decorators work in Python, just know that\nthis feature allows us to map a given path to a particular\nfunction (i.e., handler). The Flask application, when started, will take\nHTTP requests and look up the matching handler and invoke it.A simple “Hello World” routeEstablishes we are mapping the / path as a\nroute.The next method is the handler for that route.Returns the string “Hello World!” to the client.The route() method on the Flask decorator takes an\nargument: the path you wish the route to handle. Here we pass in the\nroot or / path, as a string, to handle requests to the root\npath.This route declaration is then followed by a simple function\ndefinition, index(). In Python, decorators invoked in this\nmanner apply to the function immediately following them. Therefore, this\nfunction becomes the “handler” for that route, and will be executed when\nan HTTP request to the given path is made.Note that the name of the function doesn’t matter, we can call it\nwhatever we’d like so long as it is unique. In this case we chose\nindex() because that fits with the route we are handling:\nthe root “index” of the web application.So we have the index() function immediately following\nour route definition for the root, and this will become the handler for\nthe root URL in our web application.The handler in this case is dead simple, it just returns a string,\n“Hello World!”, to the client. This isn’t hypermedia yet, but as we can\nsee in [fig-helloworld], a\nbrowser will render it just fine.Hello World!Great, there’s our first step into Flask, showing the core technique\nwe are going to use to respond to HTTP requests: routes mapped to\nhandlers.For Contact.app, rather than rendering “Hello World!” at the root\npath, we are going to do something a little fancy: we are going to\nredirect to another path, the /contacts path. Redirects are\na feature of HTTP that allow you to redirect a client to another\nlocation with an HTTP response.We are going to display a list of contacts as our root page, and,\narguably, redirecting to the /contacts path to display this\ninformation is a bit more consistent with the notion of resources with\nREST. This is a judgement call on our part, and not something we feel is\ntoo important, but it makes sense in terms of routes we will set up\nlater in the application.To change our “Hello World” route to a redirect, we only need to\nchange one line of code:Changing “Hello World” to a redirectUpdate to a call to redirect()Now the index() function returns the result of the\nFlask-supplied redirect() function with the path we’ve\nsupplied. In this case the path is /contacts, passed in as\na string argument. Now, if you navigate to the root path,\n/, our Flask application will forward you on to the\n/contacts path.Now that we have some understanding of how to define routes, let’s\nget down to specifying and then implementing our web application.What will Contact.app do?Initially, it will allow users to:View a list of contacts, including first name, last name, phone\nand email addressSearch the contactsAdd a new contactView the details of a contactEdit the details of a contactDelete a contactSo, as you can see, Contact.app is a CRUD application, the sort of\napplication that is perfect for an old-school web 1.0 approach.Note that the source code of Contact.app is available on GitHub.Let’s add our first real bit of functionality: the ability to show\nall the contacts in our app in a list (really, in a table).This functionality is going to be found at the /contacts\npath, which is the path our previous route is redirecting to.We will use Flask to route the /contacts path to a\nhandler function, contacts(). This function will do one of\ntwo things:If there is a search term found in the request, it will filter\ndown to only contacts matching that termIf not, it will simply list all contactsThis is a common approach in web 1.0 style applications: the same URL\nthat displays all instances of some resource also serves as the search\nresults page for those resources. Taking this approach makes it easy to\nreuse the list display that is common to both types of request.Here is what the code looks like for this handler:A handler for server-side searchLook for the query parameter named q, which stands\nfor “query.”If the parameter exists, call the Contact.search()\nfunction with it.If not, call the Contact.all() function.Pass the result to the index.html template to render\nto the client.We see the same sort of routing code we saw in our first example, but\nwe have a more elaborate handler function. First, we check to see if a\nsearch query parameter named q is part of the request.A “query string” is part of the URL specification. Here is an example\nURL with a query string in it:\nhttps://example.com/contacts?q=joe. The query string is\neverything after the ?, and has a name-value pair format.\nIn this URL, the query parameter q is set to the string\nvalue joe. In plain HTML, a query string can be included in\na request either by being hardcoded in an anchor tag or, more\ndynamically, by using a form tag with a GET request.To return to our Flask route, if a query parameter named\nq is found, we call out to the search() method\non a Contact model object to do the actual contact search\nand return all the matching contacts.If the query parameter is not found, we simply get all\ncontacts by invoking the all() method on the\nContact object.Finally, we render a template, index.html that displays\nthe given contacts, passing in the results of whichever of these two\nfunctions we end up calling.A Note On The Contact ClassThe Contact Python class we’re using is the “domain\nmodel” or just “model” class for our application, providing the\n“business logic” around the management of Contacts.It could be working with a database (it isn’t) or a simple flat file\n(it is), but we’re going to skip over the internal details of the model.\nThink of it as a “normal” domain model class, with methods on it that\nact in a “normal” manner.We will treat Contact as a resource, and focus\non how to effectively provide hypermedia representations of that\nresource to clients.Now that we have our handler logic written, we’ll create a template\nto render HTML in our response to the client. At a high level, our HTML\nresponse needs to have the following elements:A list of any matching or all contacts.A search box where a user may type and submit search\nterms.A bit of surrounding “chrome”: a header and footer for the\nwebsite that will be the same regardless of the page you are\non.We are using the Jinja2 templating language, which has the following\nfeatures:We can use double-curly braces, {{ }}, to embed\nexpression values in the template.we can use curly-percents, {% %}, for directives,\nlike iteration or including other content.Beyond this basic syntax, Jinja2 is very similar to other templating\nlanguages used to generate content, and should be easy to follow for\nmost web developers.Let’s look at the first few lines of code in the\nindex.html template:Start of index.htmlSet the layout template for this template.Delimit the content to be inserted into the layout.Create a search form that will issue an HTTP GET to\n/contacts.Create an input for a user to type search queries.The first line of code references a base template,\nlayout.html, with the extends directive. This\nlayout template provides the layout for the page (again, sometimes\ncalled “the chrome”): it wraps the template content in an\n\u003chtml\u003e tag, imports any necessary CSS and JavaScript\nin a \u003chead\u003e element, places a\n\u003cbody\u003e tag around the main content and so forth. All\nthe common content wrapped around the “normal” content for the entire\napplication is located in this file.The next line of code declares the content section of\nthis template. This content block is used by the\nlayout.html template to inject the content of\nindex.html within its HTML.Next we have our first bit of actual HTML, rather than just Jinja\ndirectives. We have a simple HTML form that allows you to search\ncontacts by issuing a GET request to the\n/contacts path. The form itself contains a label and an\ninput with the name “q.” This input’s value will be submitted with the\nGET request to the /contacts path, as a query\nstring (since this is a GET request.)Note that the value of this input is set to the Jinja expression\n{{ request.args.get('q') or '' }}. This expression is\nevaluated by Jinja and will insert the request value of “q” as the\ninput’s value, if it exists. This will “preserve” the search value when\na user does a search, so that when the results of a search are rendered\nthe text input contains the term that was searched for. This makes for a\nbetter user experience since the user can see exactly what the current\nresults match, rather than having a blank text box at the top of the\nscreen.Finally, we have a submit-type input. This will render as a button\nand, when it is clicked, it will trigger the form to issue an HTTP\nrequest.This search interface forms the top of our contact page. Following it\nis a table of contacts, either all contacts or the contacts that match\nthe search, if a search was done.Here is what the template code for the contact table looks like:The contacts tableOutput some headers for our table.Iterate over the contacts that were passed in to the\ntemplate.Output the values of the current contact, first name, last name,\netc.An “operations” column, with links to edit or view the contact\ndetails.This is the core of the page: we construct a table with appropriate\nheaders matching the data we are going to show for each contact. We\niterate over the contacts that were passed into the template by the\nhandler method using the for loop directive in Jinja2. We\nthen construct a series of rows, one for each contact, where we render\nthe first and last name, phone and email of the contact as table cells\nin the row.Additionally, we have a table cell that includes two links:A link to the “Edit” page for the contact, located at\n/contacts/{{ contact.id }}/edit (e.g., For the contact with\nid 42, the edit link will point to\n/contacts/42/edit)A link to the “View” page for the contact\n/contacts/{{ contact.id }} (using our previous contact\nexample, the view page would be at /contacts/42)Finally, we have a bit of end-matter: a link to add a new contact and\na Jinja2 directive to end the content block:The “add contact” linkLink to the page that allows you to create a new\ncontact.The closing element of the content block.And that’s our complete template. Using this simple server-side\ntemplate, in combination with our handler method, we can respond with an\nHTML representation of all the contacts requested. So far, so\nhypermedia.[fig-contactapp] is what\nthe template looks like, rendered with a bit of contact information.Contact.appNow, our application won’t win any design awards at this point, but\nnotice that our template, when rendered, provides all the functionality\nnecessary to see all the contacts and search them, and also provides\nlinks to edit them, view details of them or even create a new one.And it does all this without the client (that is, the browser)\nknowing a thing about what contacts are or how to work with them.\nEverything is encoded in the hypermedia. A web browser\naccessing this application just knows how to issue HTTP requests and\nthen render HTML, nothing more about the specifics of our applications\nend points or underlying domain model.As simple as our application is at this point, it is thoroughly\nRESTful.The next bit of functionality that we will add to our application is\nthe ability to add new contacts. To do this, we are going to need to\nhandle that /contacts/new URL referenced in the “Add\nContact” link above. Note that when a user clicks on that link, the\nbrowser will issue a GET request to the\n/contacts/new URL.All the other routes we have so far use GET as well, but\nwe are actually going to use two different HTTP methods for this bit of\nfunctionality: an HTTP GET to render a form for adding a\nnew contact, and then an HTTP POST to the same\npath to actually create the contact, so we are going to be explicit\nabout the HTTP method we want to handle when we declare this route.Here is the code:The “new contact” GET routeDeclare a route, explicitly handling GET requests to\nthis path.Render the new.html template, passing in a new\ncontact object.Simple enough. We just render a new.html template with a\nnew Contact. (Contact() is how you construct a new instance\nof the Contact class in Python, if you aren’t familiar with\nit.)While the handler code for this route is very simple, the\nnew.html template is more complicated.For the remaining templates we are going to omit the layout directive\nand the content block declaration, but you can assume they are the same\nunless we say otherwise. This will let us focus on the “meat” of the\ntemplate.If you are familiar with HTML you are probably expecting a form\nelement here, and you will not be disappointed. We are going to use the\nstandard form hypermedia control for collecting contact information and\nsubmitting it to the server.Here is what our HTML looks like:The “new contact” formA form that submits to the /contacts/new path, using\nan HTTP POST.A label for the first form input.The first form input, of type email.Any error messages associated with this field.In the first line of code we create a form that will submit back\nto the same path that we are handling:\n/contacts/new. Rather than issuing an HTTP GET\nto this path, however, we will issue an HTTP POST to it.\nUsing a POST in this manner will signal to the server that\nwe want to create a new Contact, rather than get a form for creating\none.We then have a label (always a good practice!) and an input that\ncaptures the email of the contact being created. The name of the input\nis email and, when this form is submitted, the value of\nthis input will be submitted in the POST request,\nassociated with the email key.Next we have inputs for the other fields for contacts:Inputs and labels for the “new contact”\nformFinally, we have a button that will submit the form, the end of the\nform tag, and a link back to the main contacts table:The submit button for the “new contact”\nformIt is easy to miss in this straight-forward example: we are seeing\nthe flexibility of hypermedia in action.If we add a new field, remove a field, or change the logic around how\nfields are validated or work with one another, this new state of affairs\nwould be reflected in the new hypermedia representation given to users.\nA user would see the updated new form and be able to work with these new\nfeatures, with no software update required.The next step in our application is to handle the POST\nthat this form makes to /contacts/new.To do so, we need to add another route to our application that\nhandles the /contacts/new path. The new route will handle\nan HTTP POST method instead of an HTTP GET. We\nwill use the submitted form values to attempt to create a new\nContact.If we are successful in creating a Contact, we will redirect the user\nto the list of contacts and show a success message. If we aren’t\nsuccessful, then we will render the new contact form again with whatever\nvalues the user entered and render error messages about what issues need\nto be fixed so that the user can correct them.Here is our new request handler:The “new contact” controller codeWe construct a new contact object with the values from the\nform.We try to save it.On success, “flash” a success message \u0026 redirect to the\n/contacts page.On failure, re-render the form, showing any errors to the\nuser.The logic in this handler is a bit more complex than other methods we\nhave seen. The first thing we do is create a new Contact, again using\nthe Contact() syntax in Python to construct the object. We\npass in the values that the user submitted in the form by using the\nrequest.form object, a feature provided by Flask.This request.form allows us to access submitted form\nvalues in an easy and convenient way, by simply passing in the same name\nassociated with the various inputs.We also pass in None as the first value to the\nContact constructor. This is the “id” parameter, and by\npassing in None we are signaling that it is a new contact,\nand needs to have an ID generated for it. (Again, we are not going into\nthe details of how this model object is implemented, our only concern is\nusing it to generate hypermedia responses.)Next, we call the save() method on the Contact object.\nThis method returns true if the save is successful, and\nfalse if the save is unsuccessful (for example, a bad email\nwas submitted by the user).If we are able to save the contact (that is, there were no validation\nerrors), we create a flash message indicating success, and\nredirect the browser back to the list page. A “flash” is a common\nfeature in web frameworks that allows you to store a message that will\nbe available on the next request, typically in a cookie or in a\nsession store.Finally, if we are unable to save the contact, we re-render the\nnew.html template with the contact. This will show the same\ntemplate as above, but the inputs will be filled in with the submitted\nvalues, and any errors associated with the fields will be rendered to\nfeedback to the user as to what validation failed.The Post/Redirect/Get PatternThis handler implements a common strategy in web 1.0-style\ndevelopment called the Post/Redirect/Get\nor PRG pattern. By issuing an HTTP redirect once a contact has been\ncreated and forwarding the browser on to another location, we ensure\nthat the POST does not end up in the browsers request\ncache.This means that if the user accidentally (or intentionally) refreshes\nthe page, the browser will not submit another POST,\npotentially creating another contact. Instead, it will issue the\nGET that we redirect to, which should be side-effect\nfree.We will use the PRG pattern in a few different places in this\nbook.OK, so we have our server-side logic set up to save contacts. And,\nbelieve it or not, this is about as complicated as our handler logic\nwill get, even when we look at adding more sophisticated htmx-driven\nbehaviors.The next piece of functionality we will implement is the detail page\nfor a Contact. The user will navigate to this page by clicking the\n“View” link in one of the rows in the list of contacts. This will take\nthem to the path /contact/\u003ccontact id\u003e (e.g.,\n/contacts/42).This is a common pattern in web development: contacts are treated as\nresources and the URLs around these resources are organized in a\ncoherent manner.If you wish to view all contacts, you issue a GET to\n/contacts.If you want a hypermedia representation allowing you to create a\nnew contact, you issue a GET to\n/contacts/new.If you wish to view a specific contact (with, say, an id of\n42), you issue a `GET to\n/contacts/42.The Eternal Bike Shed of URL DesignIt is easy to quibble about the particulars of the path scheme you\nuse for your application:“Should we POST to /contacts/new or to\n/contacts?”We have seen many arguments online and in person advocating for one\napproach versus another. We feel it is more important to understand the\noverarching idea of resources and hypermedia\nrepresentations, rather than getting worked up about the smaller\ndetails of your URL design.We recommend you just pick a reasonable, resource-oriented URL layout\nyou like and then stay consistent. Remember, in a hypermedia system, you\ncan always change your endpoints later, because you are using hypermedia\nas the engine of application state!Our handler logic for the detail route is going to be very\nsimple: we just look the Contact up by id, which is embedded in the path\nof the URL for the route. To extract this ID we are going to need to\nintroduce a final bit of Flask functionality: the ability to call out\npieces of a path and have them automatically extracted and passed in to\na handler function.Here is what the code looks like, just a few lines of simple\nPython:Map the path, with a path variable named\ncontact_id.The handler takes the value of this path parameter.Look up the corresponding contact.Render the show.html template.You can see the syntax for extracting values from the path in the\nfirst line of code: you enclose the part of the path you wish to extract\nin \u003c\u003e and give it a name. This component of the path\nwill be extracted and then passed into the handler function, via the\nparameter with the same name.So, if you were to navigate to the path /contacts/42,\nthe value 42 would be passed into the\ncontacts_view() function for the value of\ncontact_id.Once we have the id of the contact we want to look up, we load it up\nusing the find method on the Contact object.\nWe then pass this contact into the show.html template and\nrender a response.Our show.html template is relatively simple, just\nshowing the same information as the table but in a slightly different\nformat (perhaps for printing). If we add functionality like “notes” to\nthe application later on, this will give us a good place to do so.Again, we will omit the “chrome” of the template and focus on the\nmeat:The “contact details” templateWe simply render a First Name and Last Name header, with the\nadditional contact information below it, and a couple of links: a link\nto edit the contact and a link to navigate back to the full list of\ncontacts.Next up we will tackle the functionality on the other end of that\n“Edit” link. Editing a contact is going to look very similar to creating\na new contact. As with adding a new contact, we are going to need two\nroutes that handle the same path, but using different HTTP methods: a\nGET to /contacts/\u003ccontact_id\u003e/edit will\nreturn a form allowing you to edit the contact and a POST\nto that path will update it.We are also going to piggyback the ability to delete a contact along\nwith this editing functionality. To do this we will need to handle a\nPOST to\n/contacts/\u003ccontact_id\u003e/delete.Let’s look at the code to handle the GET, which, again,\nwill return an HTML representation of an editing interface for the given\nresource:The “edit contact” controller codeAs you can see this looks a lot like our “Show Contact”\nfunctionality. In fact, it is nearly identical except for the template:\nhere we render edit.html rather than\nshow.html.While our handler code looked similar to the “Show Contact”\nfunctionality, the edit.html template is going to look very\nsimilar to the template for the “New Contact” functionality: we will\nhave a form that submits updated contact values to the same “edit” URL\nand that presents all the fields of a contact as inputs for editing,\nalong with any error messages.Here is the first bit of the form:The “edit contact” form startIssue a POST to the\n/contacts/{{ contact.id }}/edit path.As with the new.html page, the input is tied to the\ncontact’s email.This HTML is nearly identical to our new.html form,\nexcept that this form is going to submit a POST to a\ndifferent path, based on the id of the contact that we want to update.\n(It’s worth mentioning here that, rather than POST, we\nwould prefer to use a PUT or PATCH, but those\nare not available in plain HTML.)Following this we have the remainder of our form, again very similar\nto the new.html template, and our button to submit the\nform.The “edit contact” form bodyIn the final part of our template we have a small difference between\nthe new.html and edit.html. Below the main\nediting form, we include a second form that allows you to delete a\ncontact. It does this by issuing a POST to the\n/contacts/\u003ccontact id\u003e/delete path. Just as we would\nprefer to use a PUT to update a contact, we would much\nrather use an HTTP DELETE request to delete one.\nUnfortunately that also isn’t possible in plain HTML.To finish up the page, there is a simple hyperlink back to the list\nof contacts.The “edit contact” form footerGiven all the similarities between the new.html and\nedit.html templates, you may be wondering why we are not\nrefactoring these two templates to share logic between them.\nThat’s a good observation and, in a production system, we would probably\ndo just that.For our purposes, however, since our application is small and simple,\nwe will leave the templates separate.Factoring Your ApplicationsOne thing that often trips people up who are coming to hypermedia\napplications from a JavaScript background is the notion of “components”.\nIn JavaScript-oriented applications it is common to break your app up\ninto small client-side components that are then composed together. These\ncomponents are often developed and tested in isolation and provide a\nnice abstraction for developers to create testable code.With Hypermedia-Driven Applications, in contrast, you factor your\napplication on the server side. As we said, the above form could be\nrefactored into a shared template between the edit and create templates,\nallowing you to achieve a reusable and DRY (Don’t Repeat Yourself)\nimplementation.Note that factoring on the server-side tends to be coarser-grained\nthan on the client-side: you tend to split out common sections\nrather than create lots of individual components. This has benefits (it\ntends to be simple) as well as drawbacks (it is not nearly as isolated\nas client-side components).Overall, a properly factored server-side hypermedia application can\nbe extremely DRY.Next we need to handle the HTTP POST request that the\nform in our edit.html template submits. We will declare\nanother route that handles the same path as the GET\nabove.Here is the new handler code:Handle a POST to\n/contacts/\u003ccontact_id\u003e/edit.Look the contact up by id.Update the contact with the new information from the\nform.Attempt to save it.On success, flash a success message \u0026 redirect to the detail\npage.On failure, re-render the edit template, showing any\nerrors.The logic in this handler is very similar to the logic in the handler\nfor adding a new contact. The only real difference is that, rather than\ncreating a new Contact, we look the contact up by id and then call the\nupdate() method on it with the values that were entered in\nthe form.Once again, this consistency between our CRUD operations is one of\nthe nice and simplifying aspects of traditional CRUD web\napplications.We piggybacked contact delete functionality into the same template\nused to edit a contact. This second form will issue an HTTP\nPOST to /contacts/\u003ccontact_id\u003e/delete,\nand we will need to create a handler for that path as well.Here is what the controller looks like:The “delete contact” controller codeHandle a POST the\n/contacts/\u003ccontact_id\u003e/delete path.Look up and then invoke the delete() method on the\ncontact.Flash a success message and redirect to the main list of\ncontacts.The handler code is very simple since we don’t need to do any\nvalidation or conditional logic: we simply look up the contact the same\nway we have been doing in our other handlers and invoke the\ndelete() method on it, then redirect back to the list of\ncontacts with a success flash message.No need for a template in this case, the contact is gone.And, well…​ believe it or not, that’s our entire contact\napplication!If you’ve struggled with parts of the code so far, don’t worry: we\ndon’t expect you to be a Python or Flask expert (we aren’t!). You just\nneed a basic understanding of how they work to benefit from the\nremainder of the book.This is a small and simple application, but it does demonstrate many\nof the aspects of traditional, web 1.0 applications: CRUD, the\nPost/Redirect/Get pattern, working with domain logic in a controller,\norganizing our URLs in a coherent, resource-oriented manner.And, furthermore, this is a deeply Hypermedia-Driven web\napplication. Without thinking about it very much, we have been using\nREST, HATEOAS and all the other hypermedia concepts we discussed\nearlier. We would bet that this simple little contact app of ours is\nmore RESTful than 99% of all JSON APIs ever built!Just by virtue of using a hypermedia, HTML, we naturally\nfall into the RESTful network architecture.So that’s great. But what’s the matter with this little web app? Why\nnot end here and go off to develop web 1.0 style applications?Well, at some level, nothing is wrong with it. Particularly for an\napplication as simple as this one, the older way of building web apps\nmight be a perfectly acceptable approach.However, our application does suffer from that “clunkiness” that we\nmentioned earlier when discussing web 1.0 applications: every request\nreplaces the entire screen, introducing a noticeable flicker when\nnavigating between pages. You lose your scroll state. You have to click\naround a bit more than you might in a more sophisticated web\napplication.Contact.app, at this point, just doesn’t feel like a “modern” web\napplication.Is it time to reach for a JavaScript framework and JSON APIs to make\nour contact application more interactive?No. No it isn’t.It turns out that we can improve the user experience of this\napplication while retaining its fundamental hypermedia architecture.In the next few chapters we will look at htmx, a hypermedia-oriented library that\nwill let us improve our contact application while retaining the\nhypermedia-based approach we have used so far.Components encapsulate a section of a page along with its dynamic\nbehavior. While encapsulating behavior is a good way to organize code,\nit can also separate elements from their surrounding context, which can\nlead to wrong or inadequate relationships between elements. The result\nis what one might call component soup, where information is\nhidden in component state, rather than being present in the HTML, which\nis now incomprehensible due to missing context.Before you reach for components for reuse, consider your options.\nLower-level mechanisms often (allow you to) produce better HTML. In some\ncases, components can actually improve the clarity of your\nHTML.The fact that the HTML document is something that you barely touch,\nbecause everything you need in there will be injected via JavaScript,\nputs the document and the page structure out of focus. Manuel Matuzović, Why\nI’m not the biggest fan of Single Page ApplicationsIn order to avoid \u003cdiv\u003e soup (or Markdown soup, or\nComponent soup), you need to be aware of the markup you’re producing and\nbe able to change it.Some SPA frameworks, and some web components, make this more\ndifficult by putting layers of abstraction between the code the\ndeveloper writes and the generated markup.While these abstractions can allow developers to create richer UI or\nwork faster, their pervasiveness means that developers can lose sight of\nthe actual HTML (and JavaScript) being sent to clients. Without diligent\ntesting, this leads to inaccessibility, poor SEO, and bloat."
 },
 {
 "chapter": "Extending HTML As Hypermedia",
 "content": "In the previous chapter we introduced a simple Web 1.0-style\nhypermedia application to manage contacts. Our application supported the\nnormal CRUD operations for contacts, as well as a simple mechanism for\nsearching contacts. Our application was built using nothing but forms\nand anchor tags, the traditional hypermedia controls used to interact\nwith servers. The application exchanges hypermedia (HTML) with the\nserver over HTTP, issuing GET and POST HTTP\nrequests and receiving back full HTML documents in response.It is a basic web application, but it is also definitely a\nHypermedia-Driven Application. It is robust, it leverages the web’s\nnative technologies, and it is simple to understand.So what’s not to like about the application?Unfortunately, our application has a few issues common to web 1.0\nstyle applications:From a user experience perspective: there is a noticeable refresh\nwhen you move between pages of the application, or when you create,\nupdate or delete a contact. This is because every user interaction (link\nclick or form submission) requires a full page refresh, with a whole new\nHTML document to process after each action.From a technical perspective, all the updates are done with the\nPOST HTTP method. This, despite the fact that more logical\nactions and HTTP request types like PUT and\nDELETE exist and would make more sense for some of the\noperations we implemented. After all, if we wanted to delete a resource,\nwouldn’t it make more sense to use an HTTP DELETE request\nto do so? Somewhat ironically, since we have used pure HTML, we are\nunable to access the full expressive power of HTTP, which was designed\nspecifically for HTML.The first point, in particular, is noticeable in Web 1.0 style\napplications like ours and is what is responsible for giving them the\nreputation for being “clunky” when compared with their more\nsophisticated JavaScript-based Single Page Application cousins.We could address this issue by adopting a Single Page Application\nframework, and updating our server-side to provide JSON-based responses.\nSingle Page Applications eliminate the clunkiness of web 1.0\napplications by updating a web page without refreshing it: they can\nmutate parts of the Document Object Model (DOM) of the existing page\nwithout needing to replace (and re-render) the entire page.The DOMThe DOM is the internal model that a browser builds up when it\nprocesses HTML, forming a tree of “nodes” for the tags and other content\nin the HTML. The DOM provides a programmatic JavaScript API that allows\nyou to update the nodes in a page directly, without the use of\nhypermedia. Using this API, JavaScript code can insert new content, or\nremove or update existing content, entirely outside the normal browser\nrequest mechanism.There are a few different styles of SPA, but, as we discussed in\nChapter 1, the most common approach today is to tie the DOM to a\nJavaScript model and then let an SPA framework like React or Vue reactively update the DOM\nwhen a JavaScript model is updated: you make a change to a JavaScript\nobject that is stored locally in memory in the browser, and the web page\n“magically” updates its state to reflect the change in the model.In this style of application, communication with the server is\ntypically done via a JSON Data API, with the application sacrificing the\nadvantages of hypermedia in order to provide a better, smoother user\nexperience.Many web developers today would not even consider the hypermedia\napproach due to the perceived “legacy” feel of these web 1.0 style\napplications.Now, the second more technical issue we mentioned may strike you as a\nbit pedantic, and we are the first to admit that conversations around\nREST and which HTTP Action is right for a given operation can become\nvery tedious. But still, it’s odd that, when using plain HTML, it is\nimpossible to use all the functionality of HTTP!Just seems wrong, doesn’t it?It turns out that we can boost the interactivity of our application\nand address both of these issues without resorting to the SPA\napproach. We can do so by using a hypermedia-oriented\nJavaScript library, htmx. The authors of\nthis book built htmx specifically to extend HTML as a hypermedia and\naddress the issues with legacy HTML applications we mentioned above (as\nwell as a few others.)Before we get into how htmx allows us to improve the UX of our Web\n1.0 style application, let’s revisit the hyperlink/anchor tag from\nChapterRecall, a hyperlink is what is known as a hypermedia\ncontrol,a mechanism that describes some sort of interaction with a server by\nencoding information about that interaction directly and completely\nwithin the control itself.Consider again this simple anchor tag which, when interpreted by a\nbrowser, creates a hyperlink to the website for this book:A simple hyperlink, revisitedLet’s break down exactly what happens with this link:The browser will render the text “Hypermedia Systems” to the\nscreen, likely with a decoration indicating it is clickable.Then, when a user clicks on the text…​The browser will issue an HTTP GET to\nhttps://hypermedia.systems…​The browser will load the HTML body of the HTTP response into the\nbrowser window, replacing the current document.So we have four aspects of a simple hypermedia link like this, with\nthe last three aspects supplying the mechanism that distinguishes a\nhyperlink from “normal” text and, thus, makes this a hypermedia\ncontrol.Now, let’s take a moment and think about how we can\ngeneralize these last three aspects of a hyperlink.Consider: what makes anchor tags (and forms) so special?Why can’t other elements issue HTTP requests as well?For example, why shouldn’t button elements be able to\nissue HTTP requests? It seems arbitrary to have to wrap a form tag\naround a button just to make deleting contacts work in our application,\nfor example.Maybe: other elements should be able to issue HTTP requests as well.\nMaybe other elements should be able to act as hypermedia controls on\ntheir own.This is our first opportunity to generalize HTML as a hypermedia.Opportunity 1HTML could be extended to allow any element to issue a\nrequest to the server and act as a hypermedia control.Next, let’s consider the event that triggers the request to the\nserver on our link: a click event.Well, what’s so special about clicking (in the case of anchors) or\nsubmitting (in the case of forms) things? Those are just two of many,\nmany events that are fired by the DOM, after all. Events like mouse\ndown, or key up, or blur are all events you might want to use to issue\nan HTTP request.Why shouldn’t these other events be able to trigger requests as\nwell?This gives us our second opportunity to expand the expressiveness of\nHTML:Opportunity 2HTML could be extended to allow any event — not just a\nclick, as in the case of hyperlinks — to trigger HTTP requests.Getting a bit more technical in our thinking leads us to the problem\nwe noted earlier: plain HTML only give us access to the GET\nand POST actions of HTTP.HTTP stands for Hypertext Transfer Protocol, and yet the\nformat it was explicitly designed for, HTML, only supports two of the\nfive developer-facing request types. You have to use JavaScript\nand issue an AJAX request to get at the other three:\nDELETE, PUT and PATCH.Let’s recall what these different HTTP request types are designed to\nrepresent:GET corresponds with “getting” a representation for\na resource from a URL: it is a pure read, with no mutation of the\nresource.POST submits an entity (or data) to the given\nresource, often creating or mutating the resource and causing a state\nchange.PUT submits an entity (or data) to the given\nresource for update or replacement, again likely causing a state\nchange.PATCH is similar to PUT but implies a\npartial update and state change rather than a complete replacement of\nthe entity.DELETE deletes the given resource.These operations correspond closely to the CRUD operations we\ndiscussed in Chapter 2. By giving us access to only two of the five,\nHTML hamstrings our ability to take full advantage of HTTP.This gives us our third opportunity to expand the expressiveness of\nHTML:Opportunity 3HTML could be extended so that it allows access to the missing three\nHTTP methods, PUT, PATCH and\nDELETE.As a final observation, consider the last aspect of a hyperlink: it\nreplaces the entire screen when a user clicks on it.It turns out that this technical detail is the primary culprit for\npoor user experience in Web 1.0 Applications. A full page refresh can\ncause a flash of unstyled content, where content “jumps” on the screen\nas it transitions from its initial to its styled final form. It also\ndestroys the scroll state of the user by scrolling to the top of the\npage, removes focus from a focused element and so forth.But, if you think about it, there is no rule saying that hypermedia\nexchanges must replace the entire document.This gives us our fourth, final and perhaps most important\nopportunity to generalize HTML:Opportunity 4HTML could be extended to allow the responses to requests to replace\nelements within the current document, rather than requiring\nthat they replace the entire document.This is actually a very old concept in hypermedia. Ted Nelson, in his\n1980 book “Literary Machines” coined the term transclusion to\ncapture this idea: the inclusion of content into an existing document\nvia a hypermedia reference. If HTML supported this style of “dynamic\ntransclusion,” then Hypermedia-Driven Applications could function much\nmore like a Single Page Application, where only part of the DOM is\nupdated by a given user interaction or network request.These four opportunities present us a way to extend HTML well beyond\nits current abilities, but in a way that is entirely within the\nhypermedia model of the web. The fundamentals of HTML, HTTP, the\nbrowser, and so on, won’t be changed dramatically. Rather, these\ngeneralizations of existing functionality already found within\nHTML would simply let us accomplish more using HTML.Htmx is a JavaScript library that extends HTML in exactly this\nmanner, and it will be the focus of the next few chapters of this book.\nAgain, htmx is not the only JavaScript library that takes this\nhypermedia-oriented approach (other excellent examples are Unpoly and Hotwire), but htmx is the purest in its\npursuit of extending HTML as a hypermedia.From a practical “getting started” perspective, htmx is a simple,\ndependency-free and stand-alone JavaScript library that can be added to\na web application by simply including it via a script tag\nin your head element.Because of this simple installation model, you can take advantage of\ntools like public CDNs to install the library.Below is an example using the popular unpkg Content Delivery Network (CDN) to\ninstall version 1.9.2 of the library. We use an integrity\nhash to ensure that the delivered JavaScript content matches what we\nexpect. This SHA can be found on the htmx website.We also mark the script as crossorigin=\"anonymous\" so no\ncredentials will be sent to the CDN.Installing htmxIf you are used to modern JavaScript development, with complex build\nsystems and large numbers of dependencies, it may be a pleasant surprise\nto find that that’s all it takes to install htmx.This is in the spirit of the early web, when you could simply include\na script tag and things would “just work.”If you don’t want to use a CDN, you can download htmx to your local\nsystem and adjust the script tag to point to wherever you keep your\nstatic assets. Or, you may have a build system that automatically\ninstalls dependencies. In this case you can use the Node Package Manager\n(npm) name for the library: htmx.org and install it in the\nusual manner that your build system supports.Once htmx has been installed, you can begin using it immediately.And here we get to the interesting part of htmx: htmx does not\nrequire you, the user of htmx, to actually write any JavaScript.Instead, you will use attributes placed directly on elements\nin your HTML to drive more dynamic behavior. Htmx extends HTML as a\nhypermedia, and it is designed to make that extension feel as natural\nand consistent as possible with existing HTML concepts. Just as an\nanchor tag uses an href attribute to specify the URL to\nretrieve, and forms use an action attribute to specify the\nURL to submit the form to, htmx uses HTML attributes to specify\nthe URL that an HTTP request should be issued to.Let’s look at the first feature of htmx: the ability for any element\nin a web page to issue HTTP requests. This is the core functionality\nprovided by htmx, and it consists of five attributes that can be used to\nissue the five different developer-facing types of HTTP requests:hx-get - issues an HTTP GET\nrequest.hx-post - issues an HTTP POST\nrequest.hx-put - issues an HTTP PUT\nrequest.hx-patch - issues an HTTP PATCH\nrequest.hx-delete - issues an HTTP DELETE\nrequest.Each of these attributes, when placed on an element, tells the htmx\nlibrary: “When a user clicks (or whatever) this element, issue an HTTP\nrequest of the specified type.”The values of these attributes are similar to the values of both\nhref on anchors and action on forms: you\nspecify the URL you wish to issue the given HTTP request type to.\nTypically, this is done via a server-relative path.For example, if we wanted a button to issue a GET\nrequest to /contacts then we would write the following\nHTML:A simple htmx-powered buttonA simple button that issues an HTTP GET to\n/contacts.The htmx library will see the hx-get attribute on this\nbutton, and hook up some JavaScript logic to issue an HTTP\nGET AJAX request to the /contacts path when\nthe user clicks on it.Very easy to understand and very consistent with the rest of\nHTML.With the request issued by the button above, we get to perhaps the\nmost important thing to understand about htmx: it expects the response\nto this AJAX request to be HTML. Htmx is an extension of HTML.\nA native hypermedia control like an anchor tag will typically get an\nHTML response to an HTTP request it creates. Similarly, htmx expects the\nserver to respond to the requests that it makes with HTML.This may surprise web developers who are used to responding to an\nAJAX request with JSON, which is far and away the most common response\nformat for such requests. But AJAX requests are just HTTP requests and\nthere is no rule saying they must use JSON. Recall again that AJAX\nstands for Asynchronous JavaScript \u0026 XML, so JSON is already a step\naway from the format originally envisioned for this API: XML.Htmx simply goes another direction and expects HTML.There is an important difference between the HTTP responses to\n“normal” anchor or form driven HTTP requests and to htmx-powered\nrequests: in the case of htmx triggered requests, responses can be\npartial bits of HTML.In htmx-powered interactions, as you will see, we are often not\nreplacing the entire document. Rather we are using “transclusion” to\ninclude content within an existing document. Because of this,\nit is often not necessary or desirable to transfer an entire HTML\ndocument from the server to the browser.This fact can be used to save bandwidth as well as resource loading\ntime. Less overall content is transferred from the server to the client,\nand it isn’t necessary to reprocess a head tag with style\nsheets, script tags, and so forth.When the “Get Contacts” button is clicked, a partial HTML\nresponse might look something like this:A partial HTML response to an htmx\nrequestThis is just an unordered list of contacts with some clickable\nelements in it. Note that there is no opening html tag, no\nhead tag, and so forth: it is a raw HTML list,\nwithout any decoration around it. A response in a real application might\ncontain more sophisticated HTML than this simple list, but even if it\nwere more complicated it wouldn’t need to be an entire page of HTML: it\ncould just be the “inner” content of the HTML representation for this\nresource.Now, this simple list response is perfect for htmx. Htmx will simply\ntake the returned content and then swap it in to the DOM in place of\nsome element in the page. (More on exactly where it will be placed in\nthe DOM in a moment.) Swapping in HTML content in this manner is fast\nand efficient because it leverages the existing native HTML parser in\nthe browser, rather than requiring a significant amount of client-side\nJavaScript to be executed.This small HTML response shows how htmx stays within the hypermedia\nparadigm: just like a “normal” hypermedia control in a “normal” web\napplication, we see hypermedia being transferred to the client in a\nstateless and uniform manner.This button just gives us a slightly more sophisticated mechanism for\nbuilding a web application using hypermedia.Now, given that htmx has issued a request and gotten back some HTML\nas a response, and that we are going to swap this content into the\nexisting page (rather than replacing the entire page), the question\nbecomes: where should this new content be placed?It turns out that the default htmx behavior is to simply put the\nreturned content inside the element that triggered the request. That’s\nnot a good thing in the case of our button: we will end up with\na list of contacts awkwardly embedded within the button element. That\nwill look pretty silly and is obviously not what we want.Fortunately htmx provides another attribute, hx-target\nwhich can be used to specify exactly where in the DOM the new\ncontent should be placed. The value of the hx-target\nattribute is a Cascading Style Sheet (CSS) selector that allows\nyou to specify the element to put the new hypermedia content into.Let’s add a div tag that encloses the button with the id\nmain. We will then target this div with the\nresponse:A simple htmx-powered buttonA div element that wraps the button.The hx-target attribute that specifies the target of\nthe response.We have added hx-target=\"#main\" to our button, where\n#main is a CSS selector that says “The thing with the ID\n‘main’.”By using CSS selectors, htmx builds on top of familiar and standard\nHTML concepts. This keeps the additional conceptual load for working\nwith htmx to a minimum.Given this new configuration, what would the HTML on the client look\nlike after a user clicks on this button and a response has been received\nand processed?It would look something like this:Our HTML after the htmx request finishesThe response HTML has been swapped into the div,\nreplacing the button that triggered the request. Transclusion! And this\nhas happened “in the background” via AJAX, without a clunky page\nrefresh.Now, perhaps we don’t want to load the content from the server\nresponse into the div, as child elements. Perhaps, for whatever\nreason, we wish to replace the entire div with the response. To\nhandle this, htmx provides another attribute, hx-swap, that\nallows you to specify exactly how the content should be swapped\ninto the DOM.The hx-swap attribute supports the following values:innerHTML - The default, replace the inner html of\nthe target element.outerHTML - Replace the entire target element with\nthe response.beforebegin - Insert the response before the target\nelement.afterbegin - Insert the response before the first\nchild of the target element.beforeend - Insert the response after the last child\nof the target element.afterend - Insert the response after the target\nelement.delete - Deletes the target element regardless of\nthe response.none - No swap will be performed.The first two values, innerHTML and\nouterHTML, are taken from the standard DOM properties that\nallow you to replace content within an element or in place of an entire\nelement respectively.The next four values are taken from the\nElement.insertAdjacentHTML() DOM API, which allow you to\nplace an element or elements around a given element in various ways.The last two values, delete and none are\nspecific to htmx. The first option will remove the target element from\nthe DOM, while the second option will do nothing (you may want to only\nwork with response headers, an advanced technique we will look at later\nin the book.)Again, you can see htmx stays as close as possible to existing web\nstandards in order to minimize the conceptual load necessary for its\nuse.So let’s consider that case where, rather than replacing the\ninnerHTML content of the main div above, we want to replace\nthe entire div with the HTML response.To do so would require only a small change to our button, adding a\nnew hx-swap attribute:Replacing the entire divThe hx-swap attribute specifies how to swap in new\ncontent.Now, when a response is received, the entire div will be\nreplaced with the hypermedia content:Our HTML after the htmx request finishesYou can see that, with this change, the target div has been entirely\nremoved from the DOM, and the list that was returned as the response has\nreplaced it.Later in the book we will see additional uses for\nhx-swap, for example when we implement infinite scrolling\nin our contact management application.Note that with the hx-get, hx-post,\nhx-put, hx-patch and hx-delete\nattributes, we have addressed two of the four opportunities for\nimprovement that we enumerated regarding plain HTML:Opportunity 1: We can now issue an HTTP request with any\nelement (in this case we are using a button).Opportunity 3: We can issue any sort of HTTP request we\nwant, PUT, PATCH and DELETE, in\nparticular.And, with hx-target and hx-swap we have\naddressed a third shortcoming: the requirement that the entire page be\nreplaced.Opportunity 4: We can now replace any element we want in our page\nvia transclusion, and we can do so in any manner we want.So, with only seven relatively simple additional attributes, we have\naddressed most of the shortcomings of HTML as a hypermedia that we\nidentified earlier.What’s next? Recall the one other opportunity we noted: the fact that\nonly a click event (on an anchor) or a submit\nevent (on a form) can trigger an HTTP request. Let’s look at how we can\naddress that limitation.Thus far we have been using a button to issue a request with htmx.\nYou have probably intuitively understood that the button would issue its\nrequest when you clicked on the button since, well, that’s what you do\nwith buttons: you click on them.And, yes, by default when an hx-get or another\nrequest-driving annotation from htmx is placed on a button, the request\nwill be issued when the button is clicked.However, htmx generalizes this notion of an event triggering a\nrequest by using, you guessed it, another attribute:\nhx-trigger. The hx-trigger attribute allows\nyou to specify one or more events that will cause the element to trigger\nan HTTP request.Often you don’t need to use hx-trigger because the\ndefault triggering event will be what you want. The default triggering\nevent depends on the element type, and should be fairly intuitive:Requests on input, textarea \u0026\nselect elements are triggered by the change\nevent.Requests on form elements are triggered on the\nsubmit event.Requests on all other elements are triggered by the\nclick event.To demonstrate how hx-trigger works, consider the\nfollowing situation: we want to trigger the request on our button when\nthe mouse enters it. Now, this is certainly not a good UX\npattern, but bear with us: we are just using this as an example.To respond to a mouse entering the button, we would add the following\nattribute to our button:A (bad?) button that triggers on mouse\nentryIssue a request on the… mouseenter event.Now, with this hx-trigger attribute in place, whenever\nthe mouse enters this button, a request will be triggered. Silly, but it\nworks.Let’s try something a bit more realistic and potentially useful:\nlet’s add support for a keyboard shortcut for loading the contacts,\nCtrl-L (for “Load”). To do this we will need to take\nadvantage of additional syntax that the hx-trigger\nattribute supports: event filters and additional arguments.Event filters are a mechanism for determining if a given event should\ntrigger a request or not. They are applied to an event by adding square\nbrackets after it: someEvent[someFilter]. The filter itself\nis a JavaScript expression that will be evaluated when the given event\noccurs. If the result is truthy, in the JavaScript sense, it will\ntrigger the request. If not, the request will not be triggered.In the case of keyboard shortcuts, we want to catch the\nkeyup event in addition to the click event:A start, trigger on keyupA trigger with two events.Note that we have a comma separated list of events that can trigger\nthis element, allowing us to respond to more than one potential\ntriggering event. We still want to respond to the click\nevent and load the contacts, in addition to handling the\nCtrl-L keyboard shortcut.Unfortunately there are two problems with our keyup\naddition: As it stands, it will trigger requests on any keyup\nevent that occurs. And, worse, it will only trigger when a keyup occurs\nwithin this button. The user would need to tab onto the button\nto make it active and then begin typing.Let’s fix these two issues. To fix the first one, we will use a\ntrigger filter to test that Control key and the “L” key are pressed\ntogether:Getting better with filter on keyupkeyup now has a filter, so the control key and L\nmust be pressed.The trigger filter in this case is\nctrlKey \u0026\u0026 key == 'l'. This can be read as “A key\nup event, where the ctrlKey property is true and the key property is\nequal to l.” Note that the properties ctrlKey and\nkey are resolved against the event rather than the global\nname space, so you can easily filter on the properties of a given event.\nYou can use any expression you like for a filter, however: calling a\nglobal JavaScript function, for example, is perfectly acceptable.OK, so this filter limits the keyup events that will trigger the\nrequest to only Ctrl-L presses. However, we still have the\nproblem that, as it stands, only keyup events\nwithin the button will trigger the request.If you are not familiar with the JavaScript event bubbling model:\nevents typically “bubble” up to parent elements. So an event like\nkeyup will be triggered first on the focused element, and\nthen on its parent (enclosing) element, and so on, until it reaches the\ntop level document object that is the root of all other\nelements.To support a global keyboard shortcut that works regardless of what\nelement has focus, we will take advantage of event bubbling and a\nfeature that the hx-trigger attribute supports: the ability\nto listen to other elements for events. The syntax for doing\nthis is the from: modifier, which is added after an event\nname and that allows you to specify a specific element to listen for the\ngiven event on using a CSS selector.In this case, we want to listen to the body element,\nwhich is the parent element of all visible elements on the page.Here is what our updated hx-trigger attribute looks\nlike:Even better, listen for keyup on the\nbodyListen to the ‘keyup” event on the body\ntag.Now, in addition to clicks, the button will listen for\nkeyup events on the body of the page. So it will issue a\nrequest when it is clicked on and also whenever someone hits\nCtrl-L within the body of the page.And now we have a nice keyboard shortcut for our Hypermedia-Driven\nApplication.The hx-trigger attribute supports many more modifiers,\nand it is more elaborate than other htmx attributes. This is because\nevents, in general, are complicated and require a lot of details to get\njust right. The default trigger will often suffice, however, and you\ntypically don’t need to reach for complicated hx-trigger\nfeatures when using htmx.Even with more sophisticated trigger specifications like the keyboard\nshortcut we just added, the overall feel of htmx is declarative\nrather than imperative. That keeps htmx-powered applications\n“feeling like” standard web 1.0 applications in a way that adding\nsignificant amounts of JavaScript does not.And hey, check it out! With hx-trigger we have addressed\nthe final opportunity for improvement of HTML that we outlined at the\nstart of this chapter:Opportunity 2: We can use any event to trigger an HTTP\nrequest.That’s a grand total of eight, count ‘em, eight attributes\nthat all fall squarely within the same conceptual model as normal HTML\nand that, by extending HTML as a hypermedia, open up a whole new world\nof user interaction possibilities within it.Here is a table summarizing those opportunities and which htmx\nattributes address them:hx-get, hx-post, hx-put,\nhx-patch, hx-deletehx-triggerhx-put, hx-patch,\nhx-deletehx-target, hx-swapSo far we have just looked at a situation where a button makes a\nsimple GET request. This is conceptually very close to what\nan anchor tag might do. But there is that other native hypermedia\ncontrol in HTML-based applications: forms. Forms are used to pass\nadditional information beyond just a URL up to the server in a\nrequest.This information is captured via input and input-like elements within\nthe form via the various types of input tags available in HTML.Htmx allows you include this additional information in a way that\nmirrors HTML itself.The simplest way to pass input values with a request in htmx is to\nenclose the element making a request within a form tag.Let’s take our original search form and convert it to use htmx\ninstead:An htmx-powered search buttonWhen an htmx-powered element is withing an ancestor form tag, all\ninput values within that form will be submitted for non-GET\nrequestsWe have switched from an input of type\nsubmit to a button and added the\nhx-post attributeNow, when a user clicks on this button, the value of the input with\nthe id search will be included in the request. This is by\nvirtue of the fact that there is a form tag enclosing both the button\nand the input: when an htmx-driven request is triggered, htmx will look\nup the DOM hierarchy for an enclosing form, and, if one is found, it\nwill include all values from within that form. (This is sometimes\nreferred to as “serializing” the form.)You might have noticed that the button was switched from a\nGET request to a POST request. This is\nbecause, by default, htmx does not include the closest\nenclosing form for GET requests, but it does\ninclude the form for all other types of requests.This may seem a little strange, but it avoids junking up URLs that\nare used within forms when dealing with history entries, which we will\ndiscuss in a bit. You can always include an enclosing form’s values with\nan element that uses a GET by using the\nhx-include attribute, which we will discuss next.Note also that we could have added the hx-post attribute\nto the form, rather than to the button but that would create a somewhat\nawkward duplication of the search URL in the action and\nhx-post attributes. This can be avoided by using the\nhx-boost attribute, which we discuss in the next\nchapter.While enclosing all the inputs you want included in a request within\na form is the most common approach for serializing inputs for htmx\nrequests, it isn’t always possible or desirable: form tags can have\nlayout consequences and simply cannot be placed in some spots in HTML\ndocuments. A good example of the latter situation is in table row\n(tr) elements: the form tag is not a valid\nchild or parent of table rows, so you can’t place a form within or\naround a row of data in a table.To address this issue, htmx provides a mechanism for including input\nvalues in requests: the hx-include attribute. The\nhx-include attribute allows you to select input values that\nyou wish to include in a request via CSS selectors.Here is the above example reworked to include the input, dropping the\nform:An htmx-powered search button with\nhx-includehx-include can be used to include values directly in\na request.The hx-include attribute takes a CSS selector value and\nallows you to specify exactly which values to send along with the\nrequest. This can be useful if it is difficult to colocate an element\nissuing a request with all the desired inputs.It is also useful when you do, in fact, want to submit values with a\nGET request and overcome the default behavior of htmx.The hx-include attribute and, in fact, most attributes\nthat take a CSS selector, also support relative CSS selectors.\nThese allow you to specify a CSS selector relative to the\nelement it is declared on. Here are some examples:Find the closest parentelement matching the given selector, e.g.,\nclosest form.Find the next element (scanningforward) matching the given selector, e.g.,\nnext input.Find the previous element(scanning backwards) matching the given selector, e.g.,\nprevious input.Find the next element within thiselement matching the given selector, e.g.,\nfind input.The current element.Using relative CSS selectors often allows you to avoid generating ids\nfor elements, since you can take advantage of their local structural\nlayout instead.A final way to include values in htmx-driven requests is to use the\nhx-vals attribute, which allows you to include “static”\nvalues in the request. This can be useful if you have additional\ninformation that you want to include in requests, but you don’t want to\nhave this information embedded in, for example, hidden inputs (which\nwould be the standard mechanism for including additional, hidden\ninformation in HTML.)Here is an example of hx-vals:An htmx-powered button with\nhx-valshx-vals, a JSON value to include in the\nrequest.The parameter state with the value MT will\nbe included in the GET request, resulting in a path and\nparameters that looks like this: /contacts?state=MT. Note\nthat we switched the hx-vals attribute to use single quotes\naround its value. This is because JSON strictly requires double quotes\nand, therefore, to avoid escaping we needed to use the single-quote form\nfor the attribute value.You can also prefix hx-vals with a js: and\npass values evaluated at the time of the request, which can be useful\nfor including things like a dynamically maintained variable, or value\nfrom a third party JavaScript library.For example, if the state variable were maintained\ndynamically, via some JavaScript, and there existed a JavaScript\nfunction, getCurrentState(), that returned the currently\nselected state, it could be included dynamically in htmx requests like\nso:A dynamic valueWith the js: prefix, this expression will evaluate\nat submit time.These three mechanisms, using form tags, using the\nhx-include attribute and using the hx-vals\nattribute, allow you to include values in your hypermedia requests with\nhtmx in a manner that should feel very familiar and in keeping with the\nspirit of HTML, while also giving you the flexibility to achieve what\nyou want.We have a final piece of functionality to close out our overview of\nhtmx: browser history support. When you use normal HTML links and forms,\nyour browser will keep track of all the pages that you have visited. You\ncan then use the back button to navigate back to a previous page and,\nonce you have done this, you can use a forward button to go forward to\nthe original page you were on.This notion of history was one of the killer features of the early\nweb. Unfortunately it turns out that history becomes tricky when you\nmove to the Single Page Application paradigm. An AJAX request does not,\nby itself, register a web page in your browser’s history, which is a\ngood thing: an AJAX request may have nothing to do with the state of the\nweb page (perhaps it is just recording some activity in the browser), so\nit wouldn’t be appropriate to create a new history entry for the\ninteraction.However, there are likely to be a lot of AJAX driven interactions in\na Single Page Application where it is appropriate to create a\nhistory entry. There is a JavaScript API to work with browser history,\nbut this API is deeply annoying and difficult to work with, and thus\noften ignored by JavaScript developers.If you have ever used a Single Page Application and accidentally\nclicked the back button, only to lose your entire application state and\nhave to start over, you have seen this problem in action.In htmx, as with Single Page Application frameworks, you will often\nneed to explicitly work with the history API. Fortunately, since htmx\nsticks so close to the native model of the web and since it is\ndeclarative, getting web history right is typically much easier to do in\nan htmx-based application.Consider the button we have been looking at to load contacts:Our trusty buttonAs it stands, if you click this button it will retrieve the content\nfrom /contacts and load it into the element with the id\nmain, but it will not create a new history\nentry.If we wanted it to create a history entry when this request happened,\nwe would add a new attribute to the button, the hx-push-url\nattribute:Our trusty button, now with history!hx-push-url will create an entry in history when the\nbutton is clicked.Now, when the button is clicked, the /contacts path will\nbe put into the browser’s navigation bar and a history entry will be\ncreated for it. Furthermore, if the user clicks the back button, the\noriginal content for the page will be restored, along with the original\nURL.Now, the name hx-push-url for this attribute might sound\na little obscure, but it is based on the JavaScript API,\nhistory.pushState(). This notion of “pushing” derives from\nthe fact that history entries are modeled as a stack, and so you are\n“pushing” new entries onto the top of the stack of history entries.With this relatively simple, declarative mechanism, htmx allows you\nto integrate with the back button in a way that mimics the “normal”\nbehavior of HTML.Now, there is one additional thing we need to handle to get history\n“just right”: we have “pushed” the /contacts path into the\nbrowsers location bar successfully, and the back button works. But what\nif someone refreshes their browser while on the /contacts\npage?In this case, you will need to handle the htmx-based “partial”\nresponse as well as the non-htmx “full page” response. You can do this\nusing HTTP headers, a topic we will go into in detail later in the\nbook.So that’s our whirlwind introduction to htmx. We’ve only seen about\nten attributes from the library, but you can see a hint of just how\npowerful these attributes can be. Htmx enables a much more sophisticated\nweb application than is possible in plain HTML, with minimal additional\nconceptual load compared to most JavaScript-based approaches.Htmx aims to incrementally improve HTML as a hypermedia in a manner\nthat is conceptually coherent with the underlying markup language. Like\nany technical choice, this is not without trade-offs: by staying so\nclose to HTML, htmx does not give developers a lot of infrastructure\nthat many might feel should be there “by default”.By staying closer to the native model of the web, htmx aims to strike\na balance between simplicity and functionality, deferring to other\nlibraries for more elaborate frontend extensions on top of the existing\nweb platform. The good news is that htmx plays well with others, so when\nthese needs arise it is often easy enough to bring in another library to\nhandle them.The close relationship between content and markup means that good\nHTML is labor-intensive. Most sites have a separation between the\nauthors, who are rarely familiar with HTML, and the developers, who need\nto develop a generic system able to handle any content that’s thrown at\nit — this separation usually taking the form of a CMS. As a result,\nhaving markup tailored to content, which is often necessary for advanced\nHTML, is rarely feasible.Furthermore, for internationalized sites, content in different\nlanguages being injected into the same elements can degrade markup\nquality as stylistic conventions differ between languages. It’s an\nexpense few organizations can spare.Thus, we don’t expect every site to contain perfectly conformant\nHTML. What’s most important is to avoid wrong HTML — it can be\nbetter to fall back on a more generic element than to be precisely\nincorrect.If you have the resources, however, putting more care in your HTML\nwill produce a more polished site."
 },
 {
 "chapter": "Conclusion",
 "content": "We hope to have convinced you that hypermedia, rather than being a\n“legacy” technology or a technology only appropriate for “documents” of\nlinks, text and pictures, is, in fact, a powerful technology for\nbuilding applications. In this book you have seen how to build\nsophisticated user interfaces — for both the web, with htmx, and for\nmobile applications, using Hyperview — using hypermedia as a core\nunderlying application technology.Many web developers view the links and forms of “plain” HTML as\nbygone tools from a less sophisticated age. And, in some ways, they are\nright: there were definite usability issues with the original web.\nHowever, there are now JavaScript libraries that extend HTML by\naddressing its core limitations.Htmx, for example, allowed us to:Make any element capable of issuing an HTTP requestMake any event capable of triggering an HTTP eventUse all the available types of HTTP methodsTarget any element in the DOM for replacementWith that, we were able to build user interfaces for Contact.app that\nmany developers would assume require a significant amount of client-side\nJavaScript, and we did it using hypermedia concepts.The Hypermedia-Driven Application approach is not right for every\napplication. For many applications, though, the increased flexibility\nand simplicity of hypermedia can be a huge benefit. Even if your\napplication wouldn’t benefit from this approach, it is worthwhile to\nunderstand the approach, its strengths and weaknesses, and how\nit differs from the approach you are taking. The original web grew\nfaster than any distributed system in history; web developers should\nknow how to tap the power of the underlying technologies that made that\ngrowth possible.The JavaScript community and, by extension, the web development\ncommunity is famously chaotic, with new frameworks and technologies\nemerging monthly, and sometimes even weekly. It can be\nexhausting to keep up with the latest and greatest technologies, and, at\nthe same time, terrifying that we won’t keep up with them and\nbe left behind in our career.This is not a fear without foundation: there are many senior software\nengineers that have seen their careers peter out because they picked a\ntechnology to specialize in that, fairly or not, did not thrive. The web\ndevelopment world tends to be young, with many companies favoring young\ndevelopers over older developers who “haven’t kept up.”We shouldn’t sugar-coat these realities of our industry. On the other\nhand, we also shouldn’t ignore the downside that these realities create.\nIt creates a high-pressure environment where everyone is watching for\n“the new new” thing, that is, for the latest and greatest technology\nthat is going to change everything. It creates pressure to\nclaim that your technology is going to change everything. It\ntends to favor sophistication over simplicity. People\nare scared to ask “Is this too complex?” because it sounds an awful lot\nlike “I’m not smart enough to understand this.”The software industry tends, especially in web development, to lean\nfar more towards innovating, rather than understanding existing\ntechnologies and building on them or within them. We tend to look ahead\nfor new, genius solutions, rather than looking to established ideas.\nThis is understandable: the technology world is necessarily a\nforward-looking industry.On the other hand — as we saw with Roy Fielding’s formulation of REST\n— some early architects of the web had some great ideas which have been\noverlooked. We are old enough to have seen hypermedia come and go as the\n“new new” idea. It was a little shocking to us to see powerful ideas\nlike REST discarded so cavalierly by the industry. Fortunately, the\nconcepts are still sitting there, waiting to be rediscovered and\nreinvigorated. The original, RESTful architecture of the web, when\nlooked at with fresh eyes, can address many of the problems that today’s\nweb developers are facing.Perhaps, following Mark Twain’s advice, it is time to pause and\nreflect. Perhaps, for a few quiet moments, we can put the endless swirl\nof the “new new” aside, look back on where the web came from, and\nlearn.Perhaps it’s time to give hypermedia a chance."
 },
 {
 "chapter": "Htmx Patterns",
 "content": "Now that we’ve seen how htmx extends HTML as a hypermedia, it’s time\nto put it into action. As we use htmx, we will still be using\nhypermedia: we will issue HTTP requests and get back HTML. But, with the\nadditional functionality that htmx provides, we will have a more\npowerful hypermedia to work with, allowing us to accomplish\nmuch more sophisticated interfaces.This will allow us to address user experience issues, such as long\nfeedback cycles or painful page refreshes, without needing to write\nmuch, if any, JavaScript, and without creating a JSON API. Everything\nwill be implemented in hypermedia, using the core hypermedia concepts of\nthe early web.The first thing we need to do is install htmx in our web application.\nWe are going to do this by downloading the source and saving it locally\nin our application, so we aren’t dependent on any external systems. This\nis known as “vendoring” the library. We can grab the latest version of\nhtmx by navigating our browser to\nhttps://unpkg.com/htmx.org, which will redirect us to the\nsource of the latest version of the library.We can save the content from this URL into the\nstatic/js/htmx.js file in our project.You can, of course, use a more sophisticated JavaScript package\nmanager such as Node Package Manager (NPM) or yarn to install htmx. You\ndo this by referring to its package name, htmx.org, in the\nmanner appropriate for your tool. However, htmx is very small\n(approximately 12kb when compressed and zipped) and is dependency free,\nso using it does not require an elaborate mechanism or build tool.With htmx downloaded locally to our applications\n/static/js directory, we can now load it in to our\napplication. We do this by adding the following script tag\nto the head tag in our layout.html file, which\nwill make htmx available and active on every page in our\napplication:Installing htmxRecall that the layout.html file is a layout\nfile included in most templates that wraps the content of those\ntemplates in common HTML, including a head element that we\nare using here to install htmx.Believe it or not, that’s it! This simple script tag will make htmx’s\nfunctionality available across our entire application.To get our feet wet with htmx, the first feature we are going to take\nadvantage of is known as “boosting.” This is a bit of a “magic” feature\nin that we don’t need to do much beyond adding a single attribute,\nhx-boost, to the application.When you put hx-boost on a given element with the value\ntrue, it will “boost” all anchor and form elements within\nthat element. “Boost”, here, means that htmx will convert all those\nanchors and forms from “normal” hypermedia controls into AJAX-powered\nhypermedia controls. Rather than issuing “normal” HTTP requests that\nreplace the whole page, the links and forms will issue AJAX requests.\nHtmx then swaps the inner content of the \u003cbody\u003e tag\nin the response to these requests into the existing pages\n\u003cbody\u003e tag.This makes navigation feel faster because the browser will not be\nre-interpreting most of the tags in the response\n\u003chead\u003e and so forth.Let’s take a look at an example of a boosted link. Below is a link to\na hypothetical settings page for a web application. Because it has\nhx-boost=\"true\" on it, htmx will halt the normal link\nbehavior of issuing a request to the /settings path and\nreplacing the entire page with the response. Instead, htmx will issue an\nAJAX request to /settings, take the result and replace the\nbody element with the new content.A boosted linkThe hx-boost attribute makes this link\nAJAX-powered.You might reasonably ask: what’s the advantage here? We are issuing\nan AJAX request and simply replacing the entire body.Is that significantly different from just issuing a normal link\nrequest?Yes, it is in fact different: with a boosted link, the browser is\nable to avoid any processing associated with the head tag. The head tag\noften contains many scripts and CSS file references. In the boosted\nscenario, it is not necessary to re-process those resources: the scripts\nand styles have already been processed and will continue to apply to the\nnew content. This can often be a very easy way to speed up your\nhypermedia application.A second question you might have is: does the response need to be\nformatted specially to work with hx-boost? After all, the\nsettings page would normally render an html tag, with a\nhead tag and so forth. Do you need to handle “boosted”\nrequests specially?The answer is no: htmx is smart enough to pull out only the content\nof the body tag to swap in to the new page. The\nhead tag is mostly ignored: only the title tag, if it is\npresent, will be processed. This means you don’t need to do anything\nspecial on the server side to render templates that\nhx-boost can handle: just return the normal HTML for your\npage, and it should work fine.Note that boosted links (and forms) will also continue to update the\nnavigation bar and history, just like normal links, so users will be\nable to use the browser back button, will be able to copy and paste URLs\n(or “deep links”) and so on. Links will act pretty much like “normal”,\nthey will just be faster.Boosted form tags work in a similar way to boosted anchor tags: a\nboosted form will use an AJAX request rather than the usual\nbrowser-issued request, and will replace the entire body with the\nresponse.Here is an example of a form that posts messages to the\n/messages endpoint using an HTTP POST request.\nBy adding hx-boost to it, those requests will be done in\nAJAX, rather than the normal browser behavior.A boosted formAs with the link, hx-boost makes this form\nAJAX-powered.A big advantage of the AJAX-based request that hx-boost\nuses (and the lack of head processing that occurs) is that it avoids\nwhat is known as a flash of unstyled content:A situation where a browser renders a web page before all the styling\ninformation is available for the page. A FOUC causes a disconcerting\nmomentary “flash” of the unstyled content, which is then restyled when\nall the style information is available. You will notice this as a\nflicker when you move around the internet: text, images and other\ncontent can “jump around” on the page as styles are applied to it.With hx-boost the site’s styling is already loaded\nbefore the new content is retrieved, so there is no such flash\nof unstyled content. This can make a “boosted” application feel both\nsmoother and also snappier in general.Let’s expand on our previous example of a boosted link, and add a few\nmore boosted links alongside it. We’ll add links so that we have one to\nthe /contacts page, the /settings page, and\nthe /help page. All these links are boosted and will behave\nin the manner that we have described above.This feels a little redundant, doesn’t it? It seems silly to annotate\nall three links with the hx-boost=\"true\" attribute right\nnext to one another.A set of boosted linksHtmx offers a feature to help reduce this redundancy: attribute\ninheritance. With most attributes in htmx, if you place it on a parent,\nthe attribute will also apply to children elements. This is how\nCascading Style Sheets work, and that idea inspired htmx to adopt a\nsimilar “cascading htmx attributes” feature.To avoid the redundancy in this example, let’s introduce a\ndiv element that encloses all the links and then “hoist”\nthe hx-boost attribute up to that parent div.\nThis will let us remove the redundant hx-boost attributes\nbut ensure all the links are still boosted, inheriting that\nfunctionality from the parent div.Note that any legal HTML element could be used here, we just use a\ndiv out of habit.Boosting links via the parentThe hx-boost has been moved to the parent\ndiv.Now we don’t have to put an hx-boost=\"true\" on every\nlink and, in fact, we can add more links alongside the existing ones,\nand they, too, will be boosted, without us needing to explicitly\nannotate them.That’s fine, but what if you have a link that you don’t want\nboosted within an element that has hx-boost=\"true\" on it? A\ngood example of this situation is when a link is to a resource to be\ndownloaded, such as a PDF. Downloading a file can’t be handled well by\nan AJAX request, so you probably want that link to behave “normally”,\nissuing a full page request for the PDF, which the browser will then\noffer to save as a file on the user’s local system.To handle this situation, you simply override the parent\nhx-boost value with hx-boost=\"false\" on the\nanchor tag that you don’t want to boost:Disabling boostingThe hx-boost is still on the parent div.The boosting behavior is overridden for this link.Here we have a new link to a documentation PDF that we wish to\nfunction like a regular link. We have added\nhx-boost=\"false\" to the link and this declaration will\noverride the hx-boost=\"true\" on the parent\ndiv, reverting it to regular link behavior and, thus,\nallowing for the file download behavior that we want.A nice aspect of hx-boost is that it is an example of\nprogressive enhancement:A software design philosophy that aims to provide as much essential\ncontent and functionality to as many users as possible, while delivering\na better experience to users with more advanced web browsers.Consider the links in the example above. What would happen if someone\ndid not have JavaScript enabled?No problem. The application would continue to work, but it would\nissue regular HTTP requests, rather than AJAX-based HTTP requests. This\nmeans that your web application will work for the maximum number of\nusers; those with modern browsers (or users who have not turned off\nJavaScript) can take advantage of the benefits of the AJAX-style\nnavigation that htmx offers, and others can still use the app just\nfine.Compare the behavior of htmx’s hx-boost attribute with a\nJavaScript heavy Single Page Application: such an application often\nwon’t function at all without JavaScript enabled. It is often\nvery difficult to adopt a progressive enhancement approach when you use\nan SPA framework.This is not to say that every htmx feature offers\nprogressive enhancement. It is certainly possible to build features that\ndo not offer a “No JS” fallback in htmx, and, in fact, many of the\nfeatures we will build later in the book will fall into this category.\nWe will note when a feature is progressive enhancement friendly and when\nit is not.Ultimately, it is up to you, the developer, to decide if the\ntrade-offs of progressive enhancement (a more basic UX, limited\nimprovements over plain HTML) are worth the benefits for your\napplication users.For the contact app we are building, we want this htmx “boost”\nbehavior…​ well, everywhere.Right? Why not?How could we accomplish that?Well, it’s easy (and pretty common in htmx-powered web applications):\nwe can just add hx-boost on the body tag of\nour layout.html template, and we are done.Boosting the entire contact.appAll links and forms will be boosted now!Now every link and form in our application will use AJAX by default,\nmaking it feel much snappier. Consider the “New Contact” link that we\ncreated on the main page:A newly boosted “add contact” linkEven though we haven’t touched anything on this link or on the\nserver-side handling of the URL it targets, it will now “just work” as a\nboosted link, using AJAX for a snappier user experience, including\nupdating history, back button support and so on. And, if JavaScript\nisn’t enabled, it will fall back to the normal link behavior.All this with one htmx attribute.The hx-boost attribute is neat, but is different than\nother htmx attributes in that it is pretty “magical”: by making one\nsmall change you modify the behavior of a large number of elements on\nthe page, turning them into AJAX-powered elements. Most other htmx\nattributes are generally lower level and require more explicit\nannotations in order to specify exactly what you want htmx to do. In\ngeneral, this is the design philosophy of htmx: prefer explicit over\nimplicit and obvious over “magic.”However, the hx-boost attribute was too useful to allow\ndogma to override practicality, and so it is included as a feature in\nthe library.For our next step with htmx, recall that Contact.app has a small form\non the edit page of a contact that is used to delete the contact:Plain HTML form to delete a contactThis form issued an HTTP POST to, for example,\n/contacts/42/delete, in order to delete the contact with\nthe ID 42.We mentioned previously that one of the annoying things about HTML is\nthat you can’t issue an HTTP DELETE (or PUT or\nPATCH) request directly, even though these are all part of\nHTTP and HTTP is obviously designed for transferring HTML.Thankfully, now, with htmx, we have a chance to rectify this\nsituation.The “right thing,” from a RESTful, resource-oriented perspective is,\nrather than issuing an HTTP POST to\n/contacts/42/delete, to issue an HTTP DELETE\nto /contacts/42. We want to delete the contact. The contact\nis a resource. The URL for that resource is /contacts/42.\nSo the ideal is a DELETE request to\n/contacts/42/.Let’s update our application to do this by adding the htmx\nhx-delete attribute to the “Delete Contact” button:An htmx-powered button for deleting a\ncontactNow, when a user clicks this button, htmx will issue an HTTP\nDELETE request via AJAX to the URL for the contact in\nquestion.A couple of things to notice:We no longer need a form tag to wrap the button,\nbecause the button itself carries the hypermedia action that it performs\ndirectly on itself.We no longer need to use the somewhat awkward\n\"/contacts/{{ contact.id }}/delete\" route, but can simply\nuse the \"/contacts/{{ contact.id }} route, since we are\nissuing a DELETE. By using a DELETE we\ndisambiguate between a request intended to update the contact and a\nrequest intended to delete it, using the native HTTP tools available for\nexactly this reason.Note that we have done something pretty magical here: we have turned\nthis button into a hypermedia control. It is no longer\nnecessary that this button be placed within a larger form\ntag in order to trigger an HTTP request: it is a stand-alone, and fully\nfeatured hypermedia control on its own. This is at the heart of htmx,\nallowing any element to become a hypermedia control and fully\nparticipate in a Hypermedia-Driven Application.We should also note that, unlike with the hx-boost\nexamples above, this solution will not degrade gracefully. To\nmake this solution degrade gracefully, we would need to wrap the button\nin a form element and handle a POST on the server side as\nwell.In the interest of keeping our application simple, we are going to\nomit that more elaborate solution.We have updated the client-side code (if HTML can be considered code)\nso it now issues a DELETE request to the appropriate URL,\nbut we still have some work to do. Since we updated both the route and\nthe HTTP method we are using, we are going to need to update the\nserver-side implementation as well to handle this new HTTP request.The original server-side code for deleting a\ncontactWe’ll need to make two changes to our handler: update the route, and\nupdate the HTTP method we are using to delete contacts.Updated handler with new route and\nmethodAn updated path and method for the handler.Pretty simple, and much cleaner.Unfortunately, there is a problem with our updated handler: by\ndefault, in Flask the redirect() method responds with a\n302 Found HTTP Response Code.According to the Mozilla Developer Network (MDN) web docs on the 302 Found\nresponse, this means that the HTTP method of the request\nwill be unchanged when the redirected HTTP request is\nissued.We are now issuing a DELETE request with htmx and then\nbeing redirected to the /contacts path by flask. According\nto this logic, that would mean that the redirected HTTP request would\nstill be a DELETE method. This means that, as it stands,\nthe browser will issue a DELETE request to\n/contacts.This is definitely not what we want: we would like the HTTP\nredirect to issue a GET request, slightly modifying the\nPost/Redirect/Get behavior we discussed earlier to be a\nDelete/Redirect/Get.Fortunately, there is a different response code, 303 See Other,\nthat does what we want: when a browser receives a\n303 See Other redirect response, it will issue a\nGET to the new location.So we want to update our code to use the 303 response\ncode in the controller.Thankfully, this is very easy: there is a second parameter to\nredirect() that takes the numeric response code you wish to\nsend.Updated handler with 303 redirect\nresponseThe response code is now a 303.Now, when you want to remove a given contact, you can simply issue a\nDELETE to the same URL as you used to access the contact in\nthe first place.This is a natural HTTP-based approach to deleting a resource.We aren’t quite finished with our updated delete button. Recall that,\nby default, htmx “targets” the element that triggers a request, and will\nplace the HTML returned by the server inside that element. Right now,\nthe “Delete Contact” button is targeting itself.That means that, since the redirect to the /contacts URL\nis going to re-render the entire contact list, we will end up with that\ncontact list placed inside the “Delete Contact” button.Mis-targeting like this comes up from time to time when you are\nworking with htmx and can lead to some pretty funny situations.The fix for this is easy: add an explicit target to the button, and\ntarget the body element with the response:A fixed htmx-powered button for deleting a\ncontactAn explicit target added to the button.Now our button behaves as expected: clicking on the button will issue\nan HTTP DELETE to the server against the URL for the\ncurrent contact, delete the contact and redirect back to the contact\nlist page, with a nice flash message.Is everything working smoothly now?Well, almost.If you click on the button you will notice that, despite the\nredirect, the URL in the location bar is not correct. It still points to\n/contacts/{{ contact.id }}. That’s because we haven’t told\nhtmx to update the URL: it just issues the DELETE request\nand then updates the DOM with the response.As we mentioned, boosting via hx-boost will naturally\nupdate the location bar for you, mimicking normal anchors and forms, but\nin this case we are building a custom button hypermedia control to issue\na DELETE. We need to let htmx know that we want the\nresulting URL from this request “pushed” into the location bar.We can achieve this by adding the hx-push-url attribute\nwith the value true to our button:Deleting a contact, now with proper location\ninformationWe tell htmx to push the redirected URL up into the location\nbar.Now we are done.We have a button that, all by itself, is able to issue a properly\nformatted HTTP DELETE request to the correct URL, and the\nUI and location bar are all updated correctly. This was accomplished\nwith three declarative attributes placed directly on the button:\nhx-delete, hx-target and\nhx-push-url.This required more work than the hx-boost change, but\nthe explicit code makes it easy to see what the button is doing as a\ncustom hypermedia control. The resulting solution feels clean; it takes\nadvantage of the built-in features of the web as a hypermedia system\nwithout any URL hacks.There is one additional “bonus” feature we can add to our “Delete\nContact” button: a confirmation dialog. Deleting a contact is a\ndestructive operation and as it stands right now, if the user\ninadvertently clicked the “Delete Contact” button, the application would\njust delete that contact. Too bad, so sad for the user.Fortunately htmx has an easy mechanism for adding a confirmation\nmessage on destructive operations like this: the hx-confirm\nattribute. You can place this attribute on an element, with a message as\nits value, and the JavaScript method confirm() will be\ncalled before a request is issued, which will show a simple confirmation\ndialog to the user asking them to confirm the action. Very easy and a\ngreat way to prevent accidents.Here is how we would add confirmation of the contact delete\noperation:Confirming deletionThis message will be shown to the user, asking them to confirm\nthe delete.Now, when someone clicks on the “Delete Contact” button, they will be\npresented with a prompt that asks “Are you sure you want to delete this\ncontact?” and they will have an opportunity to cancel if they clicked\nthe button in error. Very nice.With this final change we now have a pretty solid “delete contact”\nmechanism: we are using the correct RESTful routes and HTTP Methods, we\nare confirming the deletion, and we have removed a lot of the cruft that\nnormal HTML imposes on us, all while using declarative attributes in our\nHTML and staying firmly within the normal hypermedia model of the\nweb.As we noted earlier about this solution: it is not a\nprogressive enhancement to our web application. If someone has disabled\nJavaScript then this “Delete Contact” button will no longer work. We\nwould need to do additional work to keep the older form-based mechanism\nworking in a JavaScript-disabled environment.Progressive Enhancement can be a hot-button topic in web development,\nwith lots of passionate opinions and perspectives. Like nearly all\nJavaScript libraries, htmx makes it possible to create applications that\ndo not function in the absence of JavaScript. Retaining support for\nnon-JavaScript clients requires additional work and complexity in your\napplication. It is important to determine exactly how important\nsupporting non-JavaScript clients is before you begin using htmx, or any\nother JavaScript framework, for improving your web applications.Let’s move on to another improvement in our application. A big part\nof any web app is validating the data that is submitted to the server:\nensuring emails are correctly formatted and unique, numeric values are\nvalid, dates are acceptable, and so forth.Currently, our application has a small amount of validation that is\ndone entirely server-side and that displays an error message when an\nerror is detected.We are not going to go into the details of how validation works in\nthe model objects, but recall what the code for updating a contact looks\nlike from Chapter 3:Server-side validation on contact updateWe attempt to save the contact.If the save does not succeed we re-render the form to display\nerror messages.So we attempt to save the contact, and, if the save()\nmethod returns true, we redirect to the contact’s detail page. If the\nsave() method does not return true, that indicates that\nthere was a validation error; instead of redirecting, we re-render the\nHTML for editing the contact. This gives the user a chance to correct\nthe errors, which are displayed alongside the inputs.Let’s take a look at the HTML for the email input:Validation error messagesDisplay any errors associated with the email fieldWe have a label for the input, an input of type text and\nthen a bit of HTML to display any error messages associated with the\nemail. When the template is rendered on the server, if there are errors\nassociated with the contact’s email, they will be displayed in this\nspan, which will be highlighted red.Server-Side Validation LogicRight now there is a bit of logic in the contact class that checks if\nthere are any other contacts with the same email address, and adds an\nerror to the contact model if so, since we do not want to have duplicate\nemails in the database. This is a very common validation example: emails\nare usually unique and adding two contacts with the same email is almost\ncertainly a user error.Again, we are not going into the details of how validation works in\nour models, but almost all server-side frameworks provide ways to\nvalidate data and collect errors to display to the user. This sort of\ninfrastructure is very common in Web 1.0 server-side frameworks.The error message shown when a user attempts to save a contact with a\nduplicate email is “Email Must Be Unique”, as seen in [fig-emailerror].Email validation errorAll of this is done using plain HTML and using Web 1.0 techniques,\nand it works well.However, as the application currently stands, there are two\nannoyances.First, there is no email format validation: you can enter\nwhatever characters you’d like as an email and, as long as they are\nunique, the system will allow it.Second, we only check the email’s uniqueness when all the data is\nsubmitted: if a user has entered a duplicate email, they will not find\nout until they have filled in all the fields. This could be quite\nannoying if the user was accidentally reentering a contact and had to\nput all the contact information in before being made aware of this\nfact.For the first issue, we have a pure HTML mechanism for improving our\napplication: HTML 5 supports inputs of type email. All we\nneed to do is switch our input from type text to type\nemail, and the browser will enforce that the value entered\nproperly matches the email format:Changing the input to type\nemailA change of the type attribute to email\nensures that values entered are valid emails.With this change, when the user enters a value that isn’t a valid\nemail, the browser will display an error message asking for a properly\nformed email in that field.So a simple single-attribute change done in pure HTML improves our\nvalidation and addresses the first problem we noted.Server-Side vs. Client-Side ValidationsExperienced web developers might be grinding their teeth at the code\nabove: this validation is done on the client-side. That is, we\nare relying on the browser to detect the malformed email and correct the\nuser. Unfortunately, the client-side is not trustworthy: a browser may\nhave a bug in it that allows the user to circumvent this validation\ncode. Or, worse, the user may be malicious and figure out a mechanism\naround our validation entirely, such as using the developer console to\nedit the HTML.This is a perpetual danger in web development: all validations done\non the client-side cannot be trusted and, if the validation is\nimportant, must be redone on the server-side. This is less of a\nproblem in Hypermedia-Driven Applications than in Single Page\nApplications, because the focus of HDAs is the server-side, but it is\nworth bearing in mind as you build your application.While we have improved our validation experience a bit, the user must\nstill submit the form to get any feedback on duplicate emails. We can\nnext use htmx to improve this user experience.It would be better if the user were able to see a duplicate email\nerror immediately after entering the email value. It turns out that\ninputs fire a change event and, in fact, the\nchange event is the default trigger for inputs in\nhtmx. So, putting this feature to work, we can implement the following\nbehavior: when the user enters an email, immediately issue a request to\nthe server and validate that email, and render an error message if\nnecessary.Recall the current HTML for our email input:The initial email configurationThis is the input that we want to have drive an HTTP request to\nvalidate the email.This is the span we want to put the error message, if any,\ninto.So we want to add an hx-get attribute to this input.\nThis will cause the input to issue an HTTP GET request to a\ngiven URL to validate the email. We then want to target the error span\nfollowing the input with any error message returned from the server.Let’s make those changes to our HTML:Our updated HTMLIssue an HTTP GET to the email endpoint\nfor the contact.Target the next element with the class error on\nit.Note that in the hx-target attribute we are using a\nrelative positional selector, next. This is a\nfeature of htmx and an extension to normal CSS. Htmx supports prefixes\nthat will find targets relative to the current element.Relative Positional Expressions in HtmxScan forward in the DOM for the next matching element, e.g.,\nnext .errorScan backwards in the DOM for the closest previous matching element,\ne.g., previous .alertScan the parents of this element for matching element, e.g.,\nclosest tableScan the children of this element for matching element, e.g.,\nfind spanthe current element is the target (default)By using relative positional expressions we can avoid adding explicit\nids to elements and take advantage of the local structure of HTML.So, in our example with added hx-get and\nhx-target attributes, whenever someone changes the value of\nthe input (remember, change is the default trigger\nfor inputs in htmx) an HTTP GET request will be issued to\nthe given URL. If there are any errors, they will be loaded into the\nerror span.Next, let’s look at the server-side implementation. We are going to\nadd another endpoint, similar to our edit endpoint in some ways: it is\ngoing to look up the contact based on the ID encoded in the URL. In this\ncase, however, we only want to update the email of the contact, and we\nobviously don’t want to save it! Instead, we will call the\nvalidate() method on it.That method will validate the email is unique and so forth. At that\npoint we can return any errors associated with the email directly, or\nthe empty string if none exist.Code for our email validation endpointLook up the contact by id.Update its email (note that since this is a GET, we\nuse the args property rather than the form\nproperty).Validate the contact.Return a string, either the errors associated with the email\nfield or, if there are none, the empty string.With this small bit of server-side code in place, we now have the\nfollowing user experience: when a user enters an email and tabs to the\nnext input field, they are immediately notified if the email is already\ntaken.Note that the email validation is still done when the entire\ncontact is submitted for an update, so there is no danger of allowing\nduplicate email contacts to slip through: we have simply made it\npossible for users to catch this situation earlier by use of htmx.It is also worth noting that this particular email validation\nmust be done on the server side: you cannot determine that an\nemail is unique across all contacts unless you have access to the data\nstore of record. This is another simplifying aspect of Hypermedia-Driven\nApplications: since validations are done server-side, you have access to\nall the data you might need to do any sort of validation you’d like.Here again we want to stress that this interaction is done entirely\nwithin the hypermedia model: we are using declarative attributes and\nexchanging hypermedia with the server in a manner very similar to how\nlinks or forms work. But we have managed to improve our user experience\ndramatically.Despite the fact that we haven’t added a lot of code here, we have a\nfairly sophisticated user interface, at least when compared with plain\nHTML-based applications. However, if you have used more advanced Single\nPage Applications you have probably seen the pattern where an email\nfield (or a similar sort of input) is validated as you\ntype.This seems like the sort of interactivity that is only possible with\na sophisticated, complex JavaScript framework, right?Well, no.It turns out that you can implement this functionality in htmx, using\npure HTML attributes.In fact, all we need to do is to change our trigger. Currently, we\nare using the default trigger for inputs, which is the\nchange event. To validate as the user types, we would want\nto capture the keyup event as well:Triggering With keyup\neventsAn explicit keyup trigger has been added along with\nchange.With this tiny change, every time a user types a character we will\nissue a request and validate the email. Simple.Simple, yes, but probably not what we want: issuing a new request on\nevery key up event would be very wasteful and could potentially\noverwhelm your server. What we want instead is only issue the request if\nthe user has paused for a small amount of time. This is called\n“debouncing” the input, where requests are delayed until things have\n“settled down”.Htmx supports a delay modifier for triggers that allows\nyou to debounce a request by adding a delay before the request is sent.\nIf another event of the same kind appears within that interval, htmx\nwill not issue the request and will reset the timer.This turns out to be exactly what we want for our email input: if the\nuser is busy typing in an email we won’t interrupt them, but as soon as\nthey pause or leave the field, we’ll issue a request.Let’s add a delay of 200 milliseconds to the keyup\ntrigger, which is long enough to detect that the user has stopped\ntyping.:Debouncing the keyup eventWe debounce the keyup event by adding a\ndelay modifier.Now we no longer issue a stream of validation requests as the user\ntypes. Instead, we wait until the user pauses for a bit and then issue\nthe request. Much better for our server, and still a great user\nexperience.There is one last issue we should address with the keyup event: as it\nstands we will issue a request no matter which keys are\npressed, even if they are keys that have no effect on the value of the\ninput, such as arrow keys. It would be better if there were a way to\nonly issue a request if the input value has changed.And it turns out that htmx has support for that exact pattern, by\nusing the changed modifier for events. (Not to be confused\nwith the change event triggered by the DOM on input\nelements.)By adding changed to our keyup trigger, the\ninput will not issue validation requests unless the keyup event actually\nupdates the inputs value:Only sending requests when the input value\nchangesWe do away with pointless requests by only issuing them when the\ninput’s value has actually changed.That’s some pretty good-looking and powerful HTML, providing an\nexperience that most developers would think requires a complicated\nclient-side solution.With a total of three attributes and a simple new server-side\nendpoint, we have added a fairly sophisticated user experience to our\nweb application. Even better, any email validation rules we add on the\nserver side will automatically just work using this model:\nbecause we are using hypermedia as our communication mechanism there is\nno need to keep a client-side and server-side model in sync with one\nanother.A great demonstration of the power of the hypermedia\narchitecture!Let’s move on from the contact editing page for a bit and improve the\nroot page of the application, found at the /contacts path\nand rendering the index.html template.Currently, Contact.app does not support paging: if there are 10,000\ncontacts in the database we will show all 10,000 contacts on the root\npage. Showing so much data can bog a browser (and a server) down, so\nmost web applications adopt a concept of “paging” to deal with data sets\nthis large, where only one “page” of a smaller number of items is shown,\nwith the ability to navigate around the pages in the data set.Let’s fix our application so that we only show ten contacts at a time\nwith a “Next” and “Previous” link if there are more than 10 contacts in\nthe contact database.The first change we will make is to add a simple paging widget to our\nindex.html template.We will conditionally include two links:If we are beyond the “first” page, we will include a link to the\nprevious pageIf there are ten contacts in the current result set, we will\ninclude a link to the next pageThis isn’t a perfect paging widget: ideally we’d show the number of\npages and offer the ability to do more specific page navigation, and\nthere is the possibility that the next page might have 0 results in it\nsince we aren’t checking the total results count, but it will do for now\nfor our simple application.Let’s look at the jinja template code for this in\nindex.html.Adding paging widgets to our list of\ncontactsInclude a new div under the table to hold our navigation\nlinks.If we are beyond page 1, include an anchor tag with the page\ndecremented by one.If there are 10 contacts in the current page, include an anchor\ntag linking to the next page by incrementing it by one.Note that here we are using a special jinja filter syntax\ncontacts|length to compute the length of the contacts list.\nThe details of this filter syntax is beyond the scope of this book, but\nin this case you can think of it as invoking the\ncontacts.length property and then comparing that with\n10.Now that we have these links in place, let’s address the server-side\nimplementation of paging.We are using the page request parameter to encode the\npaging state of the UI. So, in our handler, we need to look for that\npage parameter and pass that through to our model, as an\ninteger, so the model knows which page of contacts to return:Adding paging to our request handlerResolve the page parameter, defaulting to page 1 if no page is\npassed in.Pass the page through to the model when loading all contacts so\nit knows which page of 10 contacts to return.This is fairly straightforward: we just need to get another\nparameter, like the q parameter we passed in for searching\ncontacts earlier, convert it to an integer and then pass it through to\nthe Contact model, so it knows which page to return.And, with that small change, we are done: we now have a very basic\npaging mechanism for our web application.And, believe it or not, it is already using AJAX, thanks to our use\nof hx-boost in the application. Easy!This paging mechanism is fine for a basic web application, and it is\nused extensively on the internet. But it has some drawbacks associated\nwith it: every time you click the “Next” or “Previous” buttons you get a\nwhole new page of contacts and lose any context you had on the previous\npage.Sometimes a more advanced paging UI pattern might be better. Maybe,\nrather than loading in a new page of elements and replacing the current\nelements, it would be nicer to append the next page of elements\ninline, after the current elements.This is the common “click to load” UX pattern, found in more advanced\nweb applications.A Click To Load UIIn [fig-clicktoload], you\nhave a button that you can click, and it will load the next set of\ncontacts directly into the page, rather than “paging” to the next page.\nThis allows you to keep the current contacts “in context” visually on\nthe page, but still progress through them as you would in a normal,\npaged user interface.Let’s see how we can implement this UX pattern in htmx.It’s actually surprisingly simple: we can just take the existing\n“Next” link and repurpose it a bit using nothing but a few htmx\nattributes!We want to have a button that, when clicked, appends the rows from\nthe next page of contacts to the current, existing table, rather than\nre-rendering the whole table. This can be achieved by adding a new row\nto our table that has just such a button in it:Changing to “click to load”Only show “Load More” if there are 10 contact results in the\ncurrent page.Target the closest enclosing row.Replace the entire row with the response from the\nserver.Select out the table rows from the response.Let’s go through each attribute in detail here.First, we are using hx-target to target the “closest”\ntr element, that is, the closest parent table\nrow.Second, we want to replace this entire row with whatever\ncontent comes back from the server.Third, we want to yank out only the tr elements in the\nresponse. We are replacing this tr element with a new set\nof tr elements, which will have additional contact\ninformation in them, as well as, if necessary, a new “Load More” button\nthat points to the next next page. To do this, we use a CSS\nselector tbody \u003e tr to ensure we only pull out the rows\nin the body of the table in the response. This avoids including rows in\nthe table header, for example.Finally, we issue an HTTP GET to the url that will serve\nthe next page of contacts, which looks just like the “Next” link from\nabove.Somewhat surprisingly, no server-side changes are necessary for this\nnew functionality. This is because of the flexibility that htmx gives\nyou with respect to how it processes server responses.So, four attributes, and we now have a sophisticated “Click To Load”\nUX, via htmx.Another common pattern for dealing with large sets of things is known\nas the “Infinite Scroll” pattern. In this pattern, as the last item of a\nlist or table of elements is scrolled into view, more elements are\nloaded and appended to the list or table.Now, this behavior makes more sense in situations where a user is\nexploring a category or series of social media posts, rather than in the\ncontext of a contact application. However, for completeness, and to just\nshow what you can do with htmx, we will implement this pattern as\nwell.It turns out that we can repurpose the “Click To Load” code to\nimplement this new pattern quite easily: if you think about it for a\nmoment, infinite scroll is really just the “Click To Load” logic, but\nrather than loading when a click event occurs, we want to load when an\nelement is “revealed” in the view portal of the browser.As luck would have it, htmx offers a synthetic (non-standard) DOM\nevent, revealed that can be used in tandem with the\nhx-trigger attribute, to trigger a request when, well, when\nan element is revealed.So let’s convert our button to a span and take advantage of this\nevent:Changing to “infinite scroll”We have converted our element from a button to a span, since the\nuser will not be clicking on it.We trigger the request when the element is revealed, that is when\nit comes into view in the portal.All we needed to do to convert from “Click to Load” to “Infinite\nScroll” was to update our element to be a span and then add the\nrevealed event trigger.The fact that switching to infinite scroll was so easy shows how well\nhtmx generalizes HTML: just a few attributes allow us to dramatically\nexpand what we can achieve in the hypermedia.And, again, we are doing all this while taking advantage of the\nRESTful model of the web. Despite all this new behavior, we are still\nexchanging hypermedia with the server, with no JSON API response to be\nseen.As the web was designed.Think twice about modals. Modal windows have become popular,\nalmost standard, in many web applications today.Unfortunately, modal windows do not play well with much of the\ninfrastructure of the web and introduce client-side state that can be\ndifficult (though not impossible) to integrate cleanly with the\nhypermedia-based approach.Modal windows can be used safely for views that don’t constitute a\nresource or correspond to a domain entity:AlertsConfirmation dialogsForms for creating/updating entitiesOtherwise, consider using alternatives such as inline editing, or a\nseparate page, rather than a modal.Use display: none; with care. The issue is that\nit is not purely cosmetic — it also removes elements from the\naccessibility tree and keyboard focus. This is sometimes done to present\nthe same content to visual and aural interfaces. If you want to hide an\nelement visually without hiding it from assistive technology (e.g. the\nelement contains information that is communicated through styling), you\ncan use this utility class:vh is short for “visually hidden.” This class uses\nmultiple methods and workarounds to make sure no browser removes the\nelement’s function."
 },
 {
 "chapter": "Components Of A Hypermedia System",
 "content": "A hypermedia system consists of a number of components,\nincluding:A hypermedia, such as HTML.A network protocol, such as HTTP.A server that presents a hypermedia API responding to network\nrequests with hypermedia responses.A client that properly interprets those responses.In this chapter we will look at these components and their\nimplementation in the context of the web.Once we have reviewed the major components of the web as a hypermedia\nsystem, we will look at some key ideas behind this system — especially\nas developed by Roy Fielding in his dissertation, “Architectural Styles\nand the Design of Network-based Software Architectures.” We will see\nwhere the terms REpresentational State Transfer (REST), RESTful and\nHypermedia As The Engine Of Application State (HATEOAS) come from, and\nwe will analyze these terms in the context of the web.This should give you a stronger understanding of the theoretical\nbasis of the web as a hypermedia system, how it is supposed to fit\ntogether, and why Hypermedia-Driven Applications are RESTful, whereas\nJSON APIs — despite the way the term REST is currently used in the\nindustry — are not.The fundamental technology of a hypermedia system is a hypermedia\nthat allows a client and server to communicate with one another in a\ndynamic, non-linear fashion. Again, what makes a hypermedia a hypermedia\nis the presence of hypermedia controls: elements that allow\nusers to select non-linear actions within the hypermedia. Users can\ninteract with the media in a manner beyond simply reading from\nstart to end.We have already mentioned the two primary hypermedia controls in\nHTML, anchors and forms, which allow a browser to present links and\noperations to a user through a browser.In the case of HTML, these links and forms typically specify the\ntarget of their operations using Uniform Resource Locators\n(URLs):A uniform resource locator is a textual string that refers to, or\npoints to a location on a network where a resource can\nbe retrieved from, as well as the mechanism by which the resource can be\nretrieved.A URL is a string consisting of various subcomponents:URL ComponentsMany of these subcomponents are not required, and are often\nomitted.A typical URL might look like this:A simple URLThis particular URL is made up of the following components:A protocol or scheme (in this case, https)A domain (e.g., hypermedia.systems)A path (e.g., /book/contents)This URL uniquely identifies a retrievable resource on the\ninternet, to which an HTTP Request can be issued by a\nhypermedia client that “speaks” HTTPS, such as a web browser. If this\nURL is found as the reference of a hypermedia control within an HTML\ndocument, it implies that there is a hypermedia server on the\nother side of the network that understands HTTPS as well, and that can\nrespond to this request with a representation of the given\nresource (or redirect you to another location, etc.)Note that URLs are often not written out entirely within HTML. It is\nvery common to see anchor tags that look like this, for example:A Simple LinkHere we have a relative hypermedia reference, where the\nprotocol, host and port are implied to be that of the “current\ndocument,” that is, the same as whatever the protocol and server were to\nretrieve the current HTML page. So, if this link was found in an HTML\ndocument retrieved from https://hypermedia.systems/, then\nthe implied URL for this anchor would be\nhttps://hypermedia.systems/book/contents/.The hypermedia control (link) above tells a browser: “When a user\nclicks on this text, issue a request to\nhttps://hypermedia.systems/book/contents/ using the\nHypertext Transfer Protocol,” or HTTP.HTTP is the protocol used to transfer HTML (hypermedia)\nbetween browsers (hypermedia clients) and servers (hypermedia servers)\nand, as such, is the key network technology that binds the distributed\nhypermedia system of the web together.HTTP version 1.1 is a relatively simple network protocol, so lets\ntake a look at what the GET request triggered by the anchor\ntag would look like. This is the request that would be sent to the\nserver found at hypermedia.systems, on port 80\nby default:The first line specifies that this is an HTTP GET\nrequest. It then specifies the path of the resource being requested.\nFinally, it contains the HTTP version for this request.After that are a series of HTTP request headers: individual\nlines of name/value pairs separated by a colon. The request headers\nprovide metadata that can be used by the server to determine\nexactly how to respond to the client request. In this case, with the\nAccept header, the browser is saying it would prefer HTML\nas a response format, but will accept any server response.Next, it has a Host header that specifies which server\nthe request has been sent to. This is useful when multiple domains are\nhosted on the same host.An HTTP response from a server to this request might look something\nlike this:In the first line, the HTTP Response specifies the HTTP version being\nused, followed by a response code of 200,\nindicating that the given resource was found and that the request\nsucceeded. This is followed by a string, OK that\ncorresponds to the response code. (The actual string doesn’t matter, it\nis the response code that tells the client the result of a request, as\nwe will discuss in more detail below.)After the first line of the response, as with the HTTP Request, we\nsee a series of response headers that provide metadata to the\nclient to assist in displaying the representation of the\nresource correctly.Finally, we see some new HTML content. This content is the HTML\nrepresentation of the requested resource, in this case a table\nof contents of a book. The browser will use this HTML to replace the\nentire content in its display window, showing the user this new page,\nand updating the address bar to reflect the new URL.The anchor tag above issued an HTTP GET, where\nGET is the method of the request. The particular\nmethod being used in an HTTP request is perhaps the most important piece\nof information about it, after the actual resource that the request is\ndirected at.There are many methods available in HTTP; the ones of most practical\nimportance to developers are the following:A GET request retrieves the representation of the specified resource.\nGET requests should not mutate data.A POST request submits data to the specified resource. This will\noften result in a mutation of state on the server.A PUT request replaces the data of the specified resource. This\nresults in a mutation of state on the server.A PATCH request replaces the data of the specified resource. This\nresults in a mutation of state on the server.A DELETE request deletes the specified resource. This results in a\nmutation of state on the server.These methods roughly line up with the\n“Create/Read/Update/Delete” or CRUD pattern found in many\napplications:POST corresponds with Creating a resource.GET corresponds with Reading a resource.PUT and PATCH correspond with Updating\na resource.DELETE corresponds, well, with Deleting a\nresource.Put vs. PostWhile HTTP Actions correspond roughly to CRUD, they are not the same.\nThe technical specifications for these methods make no such connection,\nand are often somewhat difficult to read. Here, for example, is the\ndocumentation on the distinction between a POST and a\nPUT from RFC-9110.The target resource in a POST request is intended to handle the\nenclosed representation according to the resource’s own semantics,\nwhereas the enclosed representation in a PUT request is defined as\nreplacing the state of the target resource. Hence, the intent of PUT is\nidempotent and visible to intermediaries, even though the exact effect\nis only known by the origin server. RFC-9110, https://www.rfc-editor.org/rfc/rfc9110#section-9.3.4In plain terms, a POST can be handled by a server pretty\nmuch however it likes, whereas a PUT should be handled as a\n“replacement” of the resource, although the language, once again allows\nthe server to do pretty much whatever it would like within the\nconstraint of being idempotent.In a properly structured HTML-based hypermedia system you would use\nan appropriate HTTP method for the operation a particular hypermedia\ncontrol performs. For example, if a hypermedia control such as a button\ndeletes a resource, ideally it should issue an HTTP\nDELETE request to do so.A strange thing about HTML, though, is that the native hypermedia\ncontrols can only issue HTTP GET and POST\nrequests.Anchor tags always issue a GET request.Forms can issue either a GET or POST using\nthe method attribute.Despite the fact that HTML — the world’s most popular hypermedia —\nhas been designed alongside HTTP (which is the Hypertext Transfer\nProtocol, after all!): if you wish to issue PUT,\nPATCH or DELETE requests you currently\nhave to resort to JavaScript to do so. Since a\nPOST can do almost anything, it ends up being used for any\nmutation on the server, and PUT, PATCH and\nDELETE are left aside in plain HTML-based applications.This is an obvious shortcoming of HTML as a hypermedia; it would be\nwonderful to see this fixed in the HTML specification. For now, in\nChapter 4, we’ll discuss ways to get around this.HTTP request methods allow a client to tell a server what to\ndo to a given resource. HTTP responses contain response codes,\nwhich tell a client what the result of the request was. HTTP response\ncodes are numeric values that are embedded in the HTTP response, as we\nsaw above.The most familiar response code for web developers is probably\n404, which stands for “Not Found.” This is the response\ncode that is returned by web servers when a resource that does not exist\nis requested from them.HTTP breaks response codes up into various categories:Informational responses that provide information about how the server\nis processing the response.Successful responses indicating that the request succeeded.Redirection responses indicating that the request should be sent to\nsome other URL.Client error responses indicating that the client made some sort of\nbad request (e.g., asking for something that didn’t exist in the case of\n404 errors).Server error responses indicating that the server encountered an\nerror internally as it attempted to respond to the request.Within each of these categories there are multiple response codes for\nspecific situations.Here are some of the more common or interesting ones:The HTTP request succeeded.The URL for the requested resource has moved to a new location\npermanently, and the new URL will be provided in the\nLocation response header.The URL for the requested resource has moved to a new location\ntemporarily, and the new URL will be provided in the\nLocation response header.The URL for the requested resource has moved to a new location, and\nthe new URL will be provided in the Location response\nheader. Additionally, this new URL should be retrieved with a\nGET request.The client is not yet authenticated (yes, authenticated, despite the\nname) and must be authenticated to retrieve the given resource.The client does not have access to this resource.The server cannot find the requested resource.The server encountered an error when attempting to process the\nresponse.There are some fairly subtle differences between HTTP response codes\n(and, to be honest, some ambiguities between them). The difference\nbetween a 302 redirect and a 303 redirect, for\nexample, is that the former will issue the request to the new URL using\nthe same HTTP method as the initial request, whereas the latter will\nalways use a GET. This is a small but often crucial\ndifference, as we will see later in the book.A well crafted Hypermedia-Driven Application will take advantage of\nboth HTTP methods and HTTP response codes to create a sensible\nhypermedia API. You do not want to build a Hypermedia-Driven Application\nthat uses a POST method for all requests and responds with\n200 OK for every response, for example. (Some JSON Data\nAPIs built on top of HTTP do exactly this!)When building a Hypermedia-Driven Application, you want, instead, to\ngo “with the grain” of the web and use HTTP methods and response codes\nas they were designed to be used.A constraint of REST (and, therefore, a feature of HTTP) is the\nnotion of caching responses: a server can indicate to a client (as well\nas intermediary HTTP servers) that a given response can be cached for\nfuture requests to the same URL.The cache behavior of an HTTP response from a server can be indicated\nwith the Cache-Control response header. This header can\nhave a number of different values indicating the cacheability of a given\nresponse. If, for example, the header contains the value\nmax-age=60, this indicates that a client may cache this\nresponse for 60 seconds, and need not issue another HTTP request for\nthat resource until that time limit has expired.Another important caching-related response header is\nVary. This response header can be used to indicate exactly\nwhat headers in an HTTP Request form the unique identifier for a cached\nresult. This becomes important to allow the browser to correctly cache\ncontent in situations where a particular header affects the form of the\nserver response.A common pattern in htmx-powered applications, for example, is to use\na custom header set by htmx, HX-Request, to differentiate\nbetween “normal” web requests and requests submitted by htmx. To\nproperly cache the response to these requests, the\nHX-Request request header must be indicated by the\nVary response header.A full discussion of caching HTTP responses is beyond the scope of\nthis chapter; see the MDN\nArticle on HTTP Caching if you would like to know more on the\ntopic.Hypermedia servers are any server that can respond to an HTTP request\nwith an HTTP response. Because HTTP is so simple, this means that nearly\nany programming language can be used to build a hypermedia server. There\nare a vast number of libraries available for building HTTP-based\nhypermedia servers in nearly every programming language imaginable.This turns out to be one of the best aspects of adopting hypermedia\nas your primary technology for building a web application: it removes\nthe pressure to adopt JavaScript as a backend technology. If you use a\nJavaScript-heavy Single Page Application-based front end, and you use\nJSON Data APIs, you are going to feel significant pressure to deploy\nJavaScript on the back end as well.In this latter situation, you already have a ton of code written in\nJavaScript. Why maintain two separate code bases in two different\nlanguages? Why not create reusable domain logic on the client-side as\nwell as the server-side? Now that JavaScript has excellent server-side\ntechnologies available like Node and Deno, why not just use a single\nlanguage for everything?In contrast, building a Hypermedia-Driven Application gives you a lot\nmore freedom in picking the back end technology you want to use. Your\ndecision can be based on the domain of your application, what languages\nand server software you are familiar with or are passionate about, or\njust what you feel like trying out.You certainly aren’t writing your server-side logic in HTML! And\nevery major programming language has at least one good web framework and\ntemplating library that can be used to handle HTTP requests cleanly.If you are doing something in big data, perhaps you’d like to use\nPython, which has tremendous support for that domain.If you are doing AI work, perhaps you’d like to use Lisp, leaning on\na language with a long history in that area of research.Maybe you are a functional programming enthusiast and want to use\nOCaml or Haskell. Perhaps you just really like Julia or Nim.These are all perfectly valid reasons for choosing a particular\nserver-side technology!By using hypermedia as your system architecture, you are freed up to\nadopt any of these choices. There simply isn’t a large JavaScript code\nbase on the front end pressuring you to adopt JavaScript on the back\nend.Hypermedia On Whatever you’d Like (HOWL)In the htmx community we call this (with tongue in cheek) the HOWL\nstack: Hypermedia On Whatever you’d Like. The htmx community is\nmulti-language and multi-framework, there are rubyists as well as\npythonistas, lispers as well as haskellers. There are even JavaScript\nenthusiasts! All these languages and frameworks are able to adopt\nhypermedia, and are able to still share techniques and offer support to\none another because they share a common underlying architecture: they\nare all using the web as a hypermedia system.Hypermedia, in this sense, provides a “universal language” for the\nweb that we can all use.We now come to the final major component in a hypermedia system: the\nhypermedia client. Hypermedia clients are software that\nunderstand how to interpret a particular hypermedia, and the hypermedia\ncontrols within it, properly. The canonical example, of course, is the\nweb browser, which understands HTML and can present it to a user to\ninteract with. Web browsers are incredibly sophisticated pieces of\nsoftware. (So sophisticated, in fact, that they are often re-purposed\naway from being a hypermedia client, to being a sort of cross-platform\nvirtual machine for launching Single Page Applications.)Browsers aren’t the only hypermedia clients out there, however. In\nthe last section of this book we will look at Hyperview, a\nmobile-oriented hypermedia. One of the outstanding features of Hyperview\nis that it doesn’t simply provide a hypermedia, HXML, but also provides\na working hypermedia client for that hypermedia. This makes\nbuilding a proper Hypermedia-Driven Application with Hyperview extremely\neasy.A crucial feature of a hypermedia system is what is known as the\nuniform interface. We discuss this concept in depth in the next\nsection on REST. What is often ignored in discussions about hypermedia\nis how important the hypermedia client is in taking advantage of this\nuniform interface. A hypermedia client must know how to properly\ninterpret and present hypermedia controls found in a hypermedia response\nfrom a hypermedia server for the whole hypermedia system to hang\ntogether. Without a sophisticated client that can do this, hypermedia\ncontrols and a hypermedia-based API are much less useful.This is one reason why JSON APIs have rarely adopted hypermedia\ncontrols successfully: JSON APIs are typically consumed by code that is\nexpecting a fixed format and that isn’t designed to be a hypermedia\nclient. This is totally understandable: building a good hypermedia\nclient is hard! For JSON API clients like this, the power of hypermedia\ncontrols embedded within an API response is irrelevant and often simply\nannoying:The short answer to this question is that HATEOAS isn’t a good fit\nfor most modern use cases for APIs. That is why after almost 20 years,\nHATEOAS still hasn’t gained wide adoption among developers. GraphQL on\nthe other hand is spreading like wildfire because it solves real-world\nproblems. Freddie Karlbom,\nhttps://techblog.commercetools.com/graphql-and-rest-level-3-hateoas-70904ff1f9cfHATEOAS will be described in more detail below, but the takeaway here\nis that a good hypermedia client is a necessary component within a\nlarger hypermedia system.Now that we have reviewed the major components of a hypermedia\nsystem, it’s time to look more deeply into the concept of REST. The term\n“REST” comes from Roy Fielding’s PhD dissertation on the architecture of\nthe web. Fielding wrote his dissertation at U.C. Irvine, after having\nhelped build much of the infrastructure of the early web, including the\nApache web server. Roy was attempting to formalize and describe the\nnovel distributed computing system that he had helped to build.We are going to focus on what we feel is the most important section\nof Fielding’s writing, from a web development perspective: Section 5.1.\nThis section contains the core concepts (Fielding calls them\nconstraints) of Representational State Transfer, or REST.Before we get into the muck, however, it is important to understand\nthat Fielding discusses REST as a network architecture, that\nis, as an entirely different way to architect a distributed system. And,\nfurther, as a novel network architecture that should be\ncontrasted with earlier approaches to distributed systems.It is also important to emphasize that, at the time Fielding wrote\nhis dissertation, JSON APIs and AJAX did not exist. He was describing\nthe early web, with HTML being transferred over HTTP by early browsers,\nas a hypermedia system.Today, in a strange turn of events, the term “REST” is mainly\nassociated with JSON Data APIs, rather than with HTML and hypermedia.\nThis is extremely funny once you realize that the vast majority of JSON\nData APIs aren’t RESTful, in the original sense, and, in fact,\ncan’t be RESTful, since they aren’t using a natural hypermedia\nformat.To re-emphasize: REST, as coined by Fielding, describes the\npre-API web, and letting go of the current, common usage of the\nterm REST to simply mean “a JSON API” is necessary to develop a proper\nunderstanding of the idea.In his dissertation, Fielding defines various “constraints” to\ndescribe how a RESTful system must behave. This approach can feel a\nlittle round-about and difficult to follow for many people, but it is an\nappropriate approach for an academic document. Given a bit of time\nthinking about the constraints he outlines and some concrete examples of\nthose constraints it will become easy to assess whether a given system\nactually satisfies the architectural requirements of REST or not.Here are the constraints of REST Fielding outlines:It is a client-server architecture (section 5.1.2).It must be stateless; (section 5.1.3) that is, every request\ncontains all information necessary to respond to that request.It must allow for caching (section 5.1.4).It must have a uniform interface (section\n5.1.5).It is a layered system (section 5.1.6).Optionally, it can allow for Code-On-Demand (section 5.1.7), that\nis, scripting.Let’s go through each of these constraints in turn and discuss them\nin detail, looking at how (and to what extent) the web satisfies each of\nthem.See Section\n5.1.2 for the Client-Server constraint.The REST model Fielding was describing involved both clients\n(browsers, in the case of the web) and servers (such as the\nApache Web Server he had been working on) communicating via a network\nconnection. This was the context of his work: he was describing the\nnetwork architecture of the World Wide Web, and contrasting it with\nearlier architectures, notably thick-client networking models such as\nthe Common Object Request Broker Architecture (CORBA).It should be obvious that any web application, regardless of how it\nis designed, will satisfy this requirement.See Section\n5.1.3 for the Stateless constraint.As described by Fielding, a RESTful system is stateless: every\nrequest should encapsulate all information necessary to respond to that\nrequest, with no side state or context stored on either the client or\nthe server.In practice, for many web applications today, we actually violate\nthis constraint: it is common to establish a session cookie\nthat acts as a unique identifier for a given user and that is sent along\nwith every request. While this session cookie is, by itself, not\nstateful (it is sent with every request), it is typically used as a key\nto look up information stored on the server, in what is usually termed\n“the session.”This session information is typically stored in some sort of shared\nstorage across multiple web servers, holding things like the current\nuser’s email or id, their roles, partially created domain objects,\ncaches, and so forth.This violation of the Statelessness REST architectural constraint has\nproven to be useful for building web applications and does not appear to\nhave had a major impact on the overall flexibility of the web. But it is\nworth bearing in mind that even Web 1.0 applications often violate the\npurity of REST in the interest of pragmatic trade-offs.And it must be said that sessions do cause additional\noperational complexity headaches when deploying hypermedia servers;\nthese may need shared access to session state information stored across\nan entire cluster. So Fielding was correct in pointing out that an ideal\nRESTful system, one that did not violate this constraint, would be\nsimpler and therefore more robust.See Section\n5.1.4 for the Caching constraint.This constraint states that a RESTful system should support the\nnotion of caching, with explicit information on the cache-ability of\nresponses for future requests of the same resource. This allows both\nclients as well as intermediary servers between a given client and final\nserver to cache the results of a given request.As we discussed earlier, HTTP has a sophisticated caching mechanism\nvia response headers that is often overlooked or underutilized when\nbuilding hypermedia applications. Given the existence of this\nfunctionality, however, it is easy to see how this constraint is\nsatisfied by the web.Now we come to the most interesting and, in our opinion, most\ninnovative constraint in REST: that of the uniform\ninterface.This constraint is the source of much of the flexibility and\nsimplicity of a hypermedia system, so we are going to spend\nsome time on it.See Section\n5.1.5 for the Uniform Interface constraint.In this section, Fielding says:The central feature that distinguishes the REST architectural style\nfrom other network-based styles is its emphasis on a uniform interface\nbetween components…​ In order to obtain a uniform interface, multiple\narchitectural constraints are needed to guide the behavior of\ncomponents. REST is defined by four interface constraints:\nidentification of resources; manipulation of resources through\nrepresentations; self-descriptive messages; and, hypermedia as the\nengine of application state Roy Fielding, Architectural Styles and the Design of Network-based\nSoftware ArchitecturesSo we have four sub-constraints that, taken together, form the\nUniform Interface constraint.In a RESTful system, resources should have a unique identifier. Today\nthe concept of Universal Resource Locators (URLs) is common, but at the\ntime of Fielding’s writing they were still relatively new and novel.What might be more interesting today is the notion of a\nresource, thus being identified: in a RESTful system,\nany sort of data that can be referenced, that is, the target of\na hypermedia reference, is considered a resource. URLs, though common\nenough today, end up solving the very complex problem of uniquely\nidentifying any and every resource on the internet.In a RESTful system, representations of the resource are\ntransferred between clients and servers. These representations can\ncontain both data and metadata about the request (such as “control data”\nlike an HTTP method or response code). A particular data format or\nmedia type may be used to present a given resource to a client,\nand that media type can be negotiated between the client and the\nserver.We saw this latter aspect of the uniform interface in the\nAccept header in the requests above.The Self-Descriptive Messages constraint, combined with the next one,\nHATEOAS, form what we consider to be the core of the Uniform Interface,\nof REST and why hypermedia provides such a powerful system\narchitecture.The Self-Descriptive Messages constraint requires that, in a RESTful\nsystem, messages must be self-describing.This means that all information necessary to both display\nand also operate on the data being represented must be present\nin the response. In a properly RESTful system, there can be no\nadditional “side” information necessary for a client to transform a\nresponse from a server into a useful user interface. Everything must “be\nin” the message itself, in the form of hypermedia controls.This might sound a little abstract so let’s look at a concrete\nexample.Consider two different potential responses from an HTTP server for\nthe URL https://example.com/contacts/42.Both responses will return information about a contact, but each\nresponse will take very different forms.The first implementation returns an HTML representation:The second implementation returns a JSON representation:What can we say about the differences between these two\nresponses?One thing that may initially jump out at you is that the JSON\nrepresentation is smaller than the HTML representation. Fielding notes\nexactly this trade-off when using a RESTful architecture:The trade-off, though, is that a uniform interface degrades\nefficiency, since information is transferred in a standardized form\nrather than one which is specific to an application’s needs. Roy Fielding, Architectural Styles and the Design of Network-based\nSoftware ArchitecturesSo REST trades off representational efficiency for other\ngoals.To understand these other goals, first notice that the HTML\nrepresentation has a hyperlink in it to navigate to a page to archive\nthe contact. The JSON representation, in contrast, does not have this\nlink.What are the ramifications of this fact for a client of the\nJSON API?What this means is that the JSON API client must know in\nadvance exactly what other URLs (and request methods) are available\nfor working with the contact information. If the JSON client is able to\nupdate this contact in some way, it must know how to do so from some\nsource of information external to the JSON message. If the\ncontact has a different status, say “Archived”, does this change the\nallowable actions? If so, what are the new allowable actions?The source of all this information might be API documentation, word\nof mouth or, if the developer controls both the server and the client,\ninternal knowledge. But this information is implicit and\noutside the response.Contrast this with the hypermedia (HTML) response. In this case, the\nhypermedia client (that is, the browser) needs only to know how to\nrender the given HTML. It doesn’t need to understand what actions are\navailable for this contact: they are simply encoded within the\nHTML response itself as hypermedia controls. It doesn’t need to\nunderstand what the status field means. In fact, the client doesn’t even\nknow what a contact is!The browser, our hypermedia client, simply renders the HTML and\nallows the user, who presumably understands the concept of a Contact, to\nmake a decision on what action to pursue from the actions made available\nin the representation.This difference between the two responses demonstrates the crux of\nREST and hypermedia, what makes them so powerful and flexible: clients\n(again, web browsers) don’t need to understand anything about\nthe underlying resources being represented.Browsers only (only! As if it is easy!) need to understand how to\ninterpret and display hypermedia, in this case HTML. This gives\nhypermedia-based systems unprecedented flexibility in dealing with\nchanges to both the backing representations and to the system\nitself.The final sub-constraint on the Uniform Interface is that, in a\nRESTful system, hypermedia should be “the engine of application state.”\nThis is sometimes abbreviated as “HATEOAS”, although Fielding prefers to\nuse the terminology “the hypermedia constraint” when discussing it.This constraint is closely related to the previous self-describing\nmessage constraint. Let us consider again the two different\nimplementations of the endpoint /contacts/42, one returning\nHTML and one returning JSON. Let’s update the situation such that the\ncontact identified by this URL has now been archived.What do our responses look like?The first implementation returns the following HTML:The second implementation returns the following JSON\nrepresentation:The important point to notice here is that, by virtue of being a\nself-describing message, the HTML response now shows that the “Archive”\noperation is no longer available, and a new “Unarchive” operation has\nbecome available. The HTML representation of the contact\nencodes the state of the application; it encodes exactly what\ncan and cannot be done with this particular representation, in a way\nthat the JSON representation does not.A client interpreting the JSON response must, again, understand not\nonly the general concept of a Contact, but also specifically what the\n“status” field with the value “Archived” means. It must know exactly\nwhat operations are available on an “Archived” contact, to appropriately\ndisplay them to an end user. The state of the application is not encoded\nin the response, but rather conveyed through a mix of raw data and side\nchannel information such as API documentation.Furthermore, in the majority of front end SPA frameworks today, this\ncontact information would live in memory in a JavaScript object\nrepresenting a model of the contact, while the page data is held in the\nbrowser’s Document\nObject Model (DOM). The DOM would be updated based on changes to\nthis model, that is, the DOM would “react” to changes to this backing\nJavaScript model.This approach is certainly not using Hypermedia As The\nEngine Of Application State: rather, it is using a JavaScript model as\nthe engine of application state, and synchronizing that model with a\nserver and with the browser.With the HTML approach, the Hypermedia is, indeed, The Engine Of\nApplication State: there is no additional model on the client side, and\nall state is expressed directly in the hypermedia, in this case HTML. As\nstate changes on the server, it is reflected in the representation (that\nis, HTML) sent back to the client. The hypermedia client (a browser)\ndoesn’t know anything about contacts, what the concept of “Archiving”\nis, or anything else about the particular domain model for this\nresponse: it simply knows how to render HTML.Because a hypermedia client doesn’t need to know anything about the\nserver model beyond how to render hypermedia to a client, it is\nincredibly flexible with respect to the representations it receives and\ndisplays to users.This last point is critical to understanding the flexibility of\nhypermedia, so let’s look at a practical example of it in action.\nConsider a situation where a new feature has been added to the web\napplication with these two end points. This feature allows you to send a\nmessage to a given Contact.How would this change each of the two responses—​HTML and JSON—​from\nthe server?The HTML representation might now look like this:The JSON representation, on the other hand, might look like this:Note that, once again, the JSON representation is unchanged. There is\nno indication of this new functionality. Instead, a client must\nknow about this change, presumably via some shared\ndocumentation between the client and the server.Contrast this with the HTML response. Because of the uniform\ninterface of the RESTful model and, in particular, because we are using\nHypermedia As The Engine of Application State, no such exchange of\ndocumentation is necessary! Instead, the client (a browser) simply\nrenders the new HTML with this operation in it, making this operation\navailable for the end user without any additional coding changes.A pretty neat trick!Now, in this case, if the JSON client is not properly updated, the\nerror state is relatively benign: a new bit of functionality is simply\nnot made available to users. But consider a more severe change to the\nAPI: what if the archive functionality was removed? Or what if the URLs\nor the HTTP methods for these operations changed in some way?In this case, the JSON client may be broken in a much more serious\nmanner.The HTML response, however, would simply be updated to exclude the\nremoved options or to update the URLs used for them. Clients would see\nthe new HTML, display it properly, and allow users to select whatever\nthe new set of operations happens to be. Once again, the uniform\ninterface of REST has proven to be extremely flexible: despite a\npotentially radically new layout for our hypermedia API, clients\ncontinue to work.An important fact emerges from this: due to this flexibility,\nhypermedia APIs do not have the versioning headaches that JSON Data\nAPIs do.Once a Hypermedia-Driven Application has been “entered into” (that\nis, loaded through some entry point URL), all functionality and\nresources are surfaced through self-describing messages. Therefore,\nthere is no need to exchange documentation with the client: the client\nsimply renders the hypermedia (in this case HTML) and everything works\nout. When a change occurs, there is no need to create a new version of\nthe API: clients simply retrieve updated hypermedia, which encodes the\nnew operations and resources in it, and display it to users to work\nwith.The final “required” constraint on a RESTful system that we will\nconsider is The Layered System constraint. This constraint can be found\nin Section\n5.1.6 of Fielding’s dissertation.To be frank, after the excitement of the uniform interface\nconstraint, the “layered system” constraint is a bit of a let down. But\nit is still worth understanding and it is actually utilized effectively\nby The web. The constraint requires that a RESTful architecture be\n“layered,” allowing for multiple servers to act as intermediaries\nbetween a client and the eventual “source of truth” server.These intermediary servers can act as proxies, transform intermediate\nrequests and responses and so forth.A common modern example of this layering feature of REST is the use\nof Content Delivery Networks (CDNs) to deliver unchanging static assets\nto clients more quickly, by storing the response from the origin server\nin intermediate servers more closely located to the client making a\nrequest.This allows content to be delivered more quickly to the end user and\nreduces load on the origin server.Not as exciting for web application developers as the uniform\ninterface, at least in our opinion, but useful nonetheless.We called The Layered System constraint the final “required”\nconstraint because Fielding mentions one additional constraint on a\nRESTful system. This Code On Demand constraint is somewhat awkwardly\ndescribed as “optional” (Section 5.1.7).In this section, Fielding says:REST allows client functionality to be extended by downloading and\nexecuting code in the form of applets or scripts. This simplifies\nclients by reducing the number of features required to be\npre-implemented. Allowing features to be downloaded after deployment\nimproves system extensibility. However, it also reduces visibility, and\nthus is only an optional constraint within REST. Roy Fielding, Architectural Styles and the Design of Network-based\nSoftware ArchitecturesSo, scripting was and is a native aspect of the original RESTful\nmodel of the web, and thus should of course be allowed in a\nHypermedia-Driven Application.However, in a Hypermedia-Driven Application the presence of scripting\nshould not change the fundamental networking model: hypermedia\nshould continue to be the engine of application state, server\ncommunication should still consist of hypermedia exchanges rather than,\nfor example, JSON data exchanges, and so on. (JSON Data API’s certainly\nhave their place; in Chapter 10 we’ll discuss when and how to use\nthem).Today, unfortunately, the scripting layer of the web, JavaScript, is\nquite often used to replace, rather than augment the hypermedia\nmodel. We will elaborate in a later chapter what scripting that does not\nreplace the underlying hypermedia system of the web looks like.After this deep dive into the components and concepts behind\nhypermedia systems — including Roy Fielding’s insights into their\noperation — we hope you have much better understanding of REST, and in\nparticular, of the uniform interface and HATEOAS. We hope you can see\nwhy these characteristics make hypermedia systems so\nflexible.If you were not aware of the full significance of REST and HATEOAS\nbefore now, don’t feel bad: it took some of us over a decade of working\nin web development, and building a hypermedia-oriented library to boot,\nto understand the special nature of HTML, hypermedia and the web!The beginning of wisdom is to call things by their right names. ConfuciusElements like \u003csection\u003e,\n\u003carticle\u003e, \u003cnav\u003e,\n\u003cheader\u003e, \u003cfooter\u003e,\n\u003cfigure\u003e have become a sort of shorthand for\nHTML.By using these elements, a page can make false promises, like\n\u003carticle\u003e elements being self-contained, reusable\nentities, to clients like browsers, search engines and scrapers that\ncan’t know better. To avoid this:Make sure that the element you’re using fits your use case. Check\nthe HTML spec.Don’t try to be specific when you can’t or don’t need to.\nSometimes, \u003cdiv\u003e is fine.The most authoritative resource for learning about HTML is the HTML\nspecification. The current specification lives on https://html.spec.whatwg.org/multipage.1 There’s no need to rely on hearsay\nto keep up with developments in HTML.Section 4 of the spec features a list of all available elements,\nincluding what they represent, where they can occur, and what they are\nallowed to contain. It even tells you when you’re allowed to leave out\nclosing tags!The single-page version is too slow to load and render\non most computers. There’s also a “developers’ edition” at /dev, but the\nstandard version has nicer styling.↩︎"
 },
 {
 "chapter": "Building A Contacts App With Hyperview",
 "content": "Earlier chapters in this book explained the benefits of building apps\nusing the hypermedia architecture. These benefits were demonstrated by\nbuilding a robust Contacts web application. Then, Chapter 11 argued that\nhypermedia concepts can and should be applied to platforms other than\nthe web. We introduced Hyperview as an example of a hypermedia format\nand client specifically designed for building mobile apps. But you may\nstill be wondering: what is it like to create a fully-featured,\nproduction-ready mobile app using Hyperview? Do we have to learn a whole\nnew language and framework? In this chapter, we will show Hyperview in\naction by porting the Contacts web app to a native mobile app. You will\nsee that many web development techniques (and indeed, much of the code)\nare completely identical when developing with Hyperview. How is that\npossible?Our Contacts web app was built with the principle of HATEOAS\n(Hypermedia as the Engine of Application State). All of the app’s\nfeatures (retrieving, searching, editing, and creating contacts) are\nimplemented in the backend (the Contacts Python class). Our\nmobile app, built with Hyperview, also leverages HATEOAS and relies on\nthe backend for all of the app’s logic. That means the\nContacts Python class can power our mobile app the same way\nit powers the web app, without any changes required.The client-server communication in the web app happens using\nHTTP. The HTTP server for our web app is written using the Flask\nframework. Hyperview also uses HTTP for client-server communication. So\nwe can re-use the Flask routes and views from the web app for the mobile\napp as well.The web app uses HTML for its hypermedia format, and Hyperview\nuses HXML. HTML and HXML are different formats, but the base syntax is\nsimilar (nested tags with attributes). This means we can use the same\ntemplating library (Jinja) for HTML and HXML. Additionally, many of the\nconcepts of htmx are built into HXML. We can directly port web app\nfeatures implemented with htmx (search, infinite loading) to\nHXML.Essentially, we can re-use almost everything from the web app\nbackend, but we will need to replace the HTML templates with HXML\ntemplates. Most of the sections in this chapter will assume we have the\nweb contacts app running locally and listening on port 5000. Ready?\nLet’s create new HXML templates for our mobile app’s UI.To get started with HXML, there’s one pesky requirement: the\nHyperview client. When developing web applications, you only need to\nworry about the server because the client (web browser) is universally\navailable. There’s no equivalent Hyperview client installed on every\nmobile device. Instead, we will create our own Hyperview client,\ncustomized to only talk to our server. This client can be packaged up\ninto an Android or iOS mobile app, and distributed through the\nrespective app stores.Luckily, we don’t need to start from scratch to implement a Hyperview\nclient. The Hyperview code repository comes with a demo backend and a\ndemo client built using Expo. We will use this demo client but point it\nto our contacts app backend as a starting point.Install dependencies for the demo appStart the Expo server to run the mobile app in the iOS\nsimulator.After running yarn start, you will be presented with a\nprompt asking you to open the mobile app using an Android emulator or\niOS simulator. Select an option based on which developer SDK you have\ninstalled. (The screenshots in this chapter will be taken from the iOS\nsimulator.) With any luck, you will see the Expo mobile app installed in\nthe simulator. The mobile app will automatically launch and show a\nscreen saying “Network request failed.” That’s because by default, this\napp is configured to make a request to http://0.0.0.0:8085/index.xml,\nbut our backend is listening on port 5000. To fix this, we can make a\nsimple configuration change in the demo/src/constants.js\nfile:The default entry point URL in the demo appSetting the URL to point to our contacts appWe’re not up and running yet. With our Hyperview client now pointing\nto the right endpoint, we see a different error, a “ParseError.” That’s\nbecause the backend is responding to requests with HTML content, but the\nHyperview client expects an XML response (specifically, HXML). So it’s\ntime to turn our attention to our Flask backend. We will go through the\nFlask views, and replace the HTML templates with HXML templates.\nSpecifically, let’s support the following features in our mobile\napp:A searchable list of contactsViewing the details of a contactEditing a contactDeleting a contactAdding a new contactZero Client-Configuration in Hypermedia\nApplicationsFor many mobile apps that use the Hyperview client, configuring this\nentry point URL is the only on-device code you need to write to deliver\na full-featured app. Think of the entry point URL as the address you\ntype into a web browser to open a web app. Except in Hyperview, there is\nno address bar, and the browser is hard-coded to only open one URL. This\nURL will load the first screen when a user launches the app. Every other\naction the user can take will be declared in the HXML of that first\nscreen. This minimal configuration is one of the benefits of the\nHypermedia-driven architecture.Of course, you may want to write more on-device code to support more\nfeatures in your mobile app. We will demonstrate how to do that later in\nthis chapter, in the section called “Extending the Client.”We will start building our Hyperview app with the entry point screen,\nthe list of contacts. For the initial version of this screen, let’s\nsupport the following features from the web app:display a scrollable list of contacts“search-as-you-type” field above the list“infinite-scroll” to load more contacts as the user scrolls\nthroughAdditionally, we will add a “pull-to-refresh” interaction on the\nlist, since users expect this from list UIs in mobile apps.If you recall, all of the pages in the Contacts web app extended a\ncommon base template, layout.html. We need a similar base\ntemplate for the screens of the mobile app. This base template will\ncontain the style rules of our UI, and a basic structure common to all\nscreens. Let’s call it layout.xml.Base template hv/layout.xmlThe header section of the template, with a default\ntitle.The content section of the template, to be provided by other\ntemplates.We’re using the HXML tags and attributes covered in the previous\nchapter. This template sets up a basic screen layout using\n\u003cdoc\u003e, \u003cscreen\u003e,\n\u003cbody\u003e, \u003cheader\u003e, and\n\u003cview\u003e tags. Note that the HXML syntax plays well\nwith the Jinja templating library. Here, we’re using Jinja’s blocks to\ndefine two sections (header and content) that\nwill hold the unique content of a screen. With our base template\ncompleted, we can create a template specifically for the contacts list\nscreen.Start of hv/index.xmlExtend the base layout templateOverride the content block of the layout\ntemplateCreate a search form that will issue an HTTP GET to\n/contactsThe list of contacts, using a Jinja include\ntag.This template extends the base layout.xml, and overrides\nthe content block with a \u003cform\u003e. At\nfirst, it might seem strange that the form wraps both the\n\u003ctext-field\u003e and the \u003clist\u003e\nelements. But remember: in Hyperview, the form data gets included in any\nrequest originating from a child element. We will soon add interactions\nto the list (pull to refresh) that will require the form data. Note the\nuse of a Jinja include tag to render the HXML for the rows\nof contacts in the list (hv/rows.xml). Just like in the\nHTML templates, we can use the include to break up our HXML\ninto smaller pieces. It also allows the server to respond with just the\nrows.xml template for interactions like searching, infinite\nscroll, and pull-to-refresh.hv/rows.xmlAn HXML element that groups a set of \u003citem\u003e\nelements in a common ancestor.Iterate over the contacts that were passed in to the\ntemplate.Render an \u003citem\u003e for each contact, showing the\nname, phone number, or email.In the web app, each row in the list showed the contact’s name, phone\nnumber, and email address. But in a mobile app, we have less\nreal-estate. It would be hard to cram all this information into one\nline. Instead, the row just shows the contact’s first and last name, and\nfalls back to email or phone if the name is not set. To render the row,\nwe again make use of Jinja template syntax to render dynamic text with\ndata passed to the template.We now have templates for the base layout, the contacts screen, and\nthe contact rows. But we still have to update the Flask views to use\nthese templates. Let’s take a look at the contacts() view\nin its current form, written for the web app:app.pyThis view supports fetching a set of contacts based on two query\nparams, q and page. It also decides whether to\nrender the full page (index.html) or just the contact rows\n(rows.html) based on the HX-Trigger header.\nThis presents a minor problem. The HX-Trigger header is set\nby the htmx library; there’s no equivalent feature in Hyperview.\nMoreover, there are multiple scenarios in Hyperview that require us to\nrespond with just the contact rows:searchingpull-to-refreshloading the next page of contactsSince we can’t depend on a header like HX-Trigger, we\nneed a different way to detect if the client needs the full screen or\njust the rows in the response. We can do this by introducing a new query\nparam, rows_only. When this param has the value\ntrue, the view will respond to the request by rendering the\nrows.xml template. Otherwise, it will respond with the\nindex.xml template:app.pyCheck for a new rows_only query param.Render the appropriate HXML template based on\nrows_only.There’s one more change we have to make. Flask assumes that most\nviews will respond with HTML. So Flask defaults the\nContent-Type response header to a value of\ntext/html. But the Hyperview client expects to receive HXML\ncontent, indicated by a Content-Type response header with\nvalue application/vnd.hyperview+xml. The client will reject\nresponses with a different content type. To fix this, we need to\nexplicitly set the Content-Type response header in our\nFlask views. We will do this by introducing a new helper function,\nrender_to_response():app.pyRenders the given template with the supplied arguments and\nkeyword arguments.Create an explicit response object with the rendered\ntemplate.Sets the response Content-Type header to\nXML.As you can see, this helper function uses\nrender_template() under the hood.\nrender_template() returns a string. This helper function\nuses that string to create an explicit Response object. The\nresponse object has a headers attribute, allowing us to set\nand change the response headers. Specifically,\nrender_to_response() sets Content-Type to\napplication/vnd.hyperview+xml so that the Hyperview client\nrecognizes the content. This helper is a drop-in replacement for\nrender_template in our views. So all we need to do is\nupdate the last line of the contacts() function.contacts() functionRender the HXML template to an XML response.With these changes to the contacts() view, we can\nfinally see the fruits of our labor. After restarting the backend and\nrefreshing the screen in our mobile app, we can see the contacts\nscreen!Contacts ScreenSo far, we have a mobile app that displays a screen with a list of\ncontacts. But our UI doesn’t support any interactions. Typing a query in\nthe search field doesn’t filter the list of contacts. Let’s add a\nbehavior to the search field to implement a search-as-you-type\ninteraction. This requires expanding \u003ctext-field\u003e to\nadd a \u003cbehavior\u003e element.Snippet of hv/index.xmlThis behavior will trigger when the value of the text field\nchanges.When the behavior triggers, the action will replace the content\ninside the target element.The target of the action is the element with ID\ncontacts-list.The replacement content will be fetched from this URL\npath.The replacement content will be fetched with the GET\nHTTP method.The first thing you’ll notice is that we changed the text field from\nusing a self-closing tag (\u003ctext-field /\u003e) to using\nopening and closing tags\n(\u003ctext-field\u003e…​\u003c/text-field\u003e). This allows us to\nadd a child \u003cbehavior\u003e element to define an\ninteraction.The trigger=\"change\" attribute tells Hyperview that a\nchange to the value of the text field will trigger an action. Any time\nthe user edits the content of the text field by adding or deleting\ncharacters, an action will trigger.The remaining attributes on the \u003cbehavior\u003e element\ndefine the action. action=\"replace-inner\" means the action\nwill update content on the screen, by replacing the HXML content of an\nelement with new content. For replace-inner to do its\nthing, we need to know two things: the current element on the screen\nthat will be targeted by the action, and the content that will used for\nthe replacement. target=\"contacts-list\" tells us the ID of\nthe current element. Note that we set id=\"contacts-list\" on\nthe \u003clist\u003e element in index.xml. So when\nthe user enters a search query into the text field, Hyperview will\nreplace the content of \u003clist\u003e (a bunch of\n\u003citem\u003e elements) with new content\n(\u003citem\u003e elements that match the search query)\nreceived in the relative href response. The domain here is inferred from\nthe domain used to fetch the screen. Note that href\nincludes our rows_only query param; we want the response to\nonly include the rows and not the entire screen.Searching for ContactsThat’s all it takes to add search-as-you-type functionality to our\nmobile app! As the user types a search query, the client will make\nrequests to the backend and replace the list with the search results.\nYou may be wondering, how does the backend know the query to use? The\nhref attribute in the behavior does not include the\nq param expected by our backend. But remember, in\nindex.xml, we wrapped the \u003ctext-field\u003e\nand \u003clist\u003e elements with a \u003cform\u003e\nelement. The \u003cform\u003e element defines a group of inputs\nthat will be serialized and included in any HTTP requests triggered by\nits child elements. In this case, the \u003cform\u003e element\nsurrounds the search behavior and the text field. So the value of the\n\u003ctext-field\u003e will be included in our HTTP request for\nthe search results. Since we are making a GET request, the\nname and value of the text field will be serialized as a query param.\nAny existing query params on the href will be preserved.\nThis means the actual HTTP request to our backend looks like\nGET /contacts?rows_only=true\u0026q=Car. Our backend already\nsupports the q param for searching, so the response will\ninclude rows that match the string “Car.”If the user has hundreds or thousands of contacts, loading them all\nat once may result in poor app performance. That’s why most mobile apps\nwith long lists implement an interaction known as “infinite scroll.” The\napp loads a fixed number of initial items in the list, let’s say 100\nitems. If the user scrolls to the bottom of the list, they see a spinner\nindicating more content is loading. Once the content is available, the\nspinner is replaced with the next page of 100 items. These items are\nappended to the list, they don’t replace the first set of items. So the\nlist now contains 200 items. If the user scrolls to the bottom of the\nlist again, they will see another spinner, and the app will load the\nnext set of content. Infinite scroll improves app performance in two\nways:The initial request for 100 items will be processed quickly, with\npredictable latency.Subsequent requests can also be fast and predictable.If the user doesn’t scroll to the bottom of the list, the app\nwon’t have to make subsequent requests.Our Flask backend already supports pagination on the\n/contacts endpoint via the page query param.\nWe just need to modify our HXML templates to make use of this parameter.\nTo do this, let’s edit rows.xml to add a new\n\u003citem\u003e below the Jinja for-loop:Snippet of hv/rows.xmlInclude an extra \u003citem\u003e in the list to show\nthe spinner.The item behavior triggers when visible in the viewport.When triggered, the behavior will replace an element on the\nscreen.The element to be replaced is the item itself (ID\nload-more).Replace the item with the next page of content.The spinner element.If the current list of contacts passed to the template is empty, we\ncan assume there’s no more contacts to fetch from the backend. So we use\na Jinja conditional to only include this new \u003citem\u003e\nif the list of contacts is non-empty. This new \u003citem\u003e\nelement gets an ID and a behavior. The behavior defines the infinite\nscroll interaction.Up until now, we’ve seen trigger values of\nchange and refresh. But to implement infinite\nscroll, we need a way to trigger the action when the user scrolls to the\nbottom of the list. The visible trigger can be used for\nthis exact purpose. It will trigger the action when the element with the\nbehavior is visible in the device viewport. In this case, the new\n\u003citem\u003e element is the last item in the list, so the\naction will trigger when the user scrolls down far enough for the item\nto enter the viewport. As soon as the item is visible, the action will\nmake an HTTP GET request, and replace the loading\n\u003citem\u003e element with the response content.Note that our href must include the rows_only=true query\nparam, so that our response will only include HXML for the contact\nitems, and not the entire screen. Also, we’re passing the\npage query param, incrementing the current page number to\nensure we load the next page.What happens when there’s more than one page of items? The initial\nscreen will include the first 100 items, plus the “load-more” item at\nthe bottom. When the user scrolls to the bottom of the screen, Hyperview\nwill request the second page of items (\u0026page=2), and\nreplace the “load-more” item with the new items. But this second page of\nitems will include a new “load-more” item. So once the user scrolls\nthrough all of the items from the second page, Hyperview will again\nrequest more items (\u0026page=3). And once again, the\n“load-more” item will be replaced with the new items. This will continue\nuntil all of the items will be loaded on the screen. At that point,\nthere will be no more contacts to return, the response will not include\nanother “load-more” item, and our pagination is over.Pull-to-refresh is a common interaction in mobile apps, especially on\nscreens featuring dynamic content. It works like this: At the top of a\nscrolling view, the user pulls the scrolling content downwards with a\nswipe-down gesture. This reveals a spinner “below” the content. Pulling\nthe content down sufficiently far will trigger a refresh. While the\ncontent refreshes, the spinner remains visible on screen, indicating to\nthe user that the action is still taking place. Once the content is\nrefreshed, the content retracts back up to its default position, hiding\nthe spinner and letting the user know that the interaction is done.Pull-to-refreshThis pattern is so common and useful that it’s built in to Hyperview\nvia the refresh action. Let’s add pull-to-refresh to our\nlist of contacts to see it in action.Snippet of hv/index.xmlThis behavior will trigger when the user does a “pull-to-refresh”\ngesture.When the behavior triggers, this action will replace the content\ninside the target element.The target of the action is the \u003clist\u003e element\nitself.The replacement content will be fetched from this URL\npath.The replacement content will be fetched with the GET\nHTTP method.You’ll notice something unusual in the snippet above: rather than\nadding a \u003cbehavior\u003e element to the\n\u003clist\u003e, we added the behavior attributes directly to\nthe \u003clist\u003e element. This is a shorthand notation\nthat’s sometimes useful for specifying single behaviors on an element.\nIt is equivalent to adding a \u003cbehavior\u003e element to\nthe \u003clist\u003e with the same attributes.So why did we use the shorthand syntax here? It has to do with the\naction, replace-inner. Remember, this action replaces all\nchild elements of the target with the new content. This includes\n\u003cbehavior\u003e elements too! Let’s say our\n\u003clist\u003e did contain a \u003cbehavior\u003e.\nIf the user did a search or pull-to-refresh, we would replace the\ncontent of \u003clist\u003e with the content from\nrows.xml. The \u003cbehavior\u003e would no longer\nbe defined on the \u003clist\u003e, and subsequent attempts to\npull-to-refresh would not work. By defining the behavior as attributes\nof \u003clist\u003e, the behavior will persist even when\nreplacing the items in the list. Generally, we prefer to use explicit\n\u003cbehavior\u003e elements in HXML. It makes it easier to\ndefine multiple behaviors, and to move the behavior around while\nrefactoring. But the shorthand syntax is good to apply in situations\nlike this.Now that our contacts list screen is in good shape, we can start\nadding other screens to our app. The natural next step is to create a\ndetails screen, which appears when the user taps an item in the contacts\nlist. Let’s update the template that renders the contact\n\u003citem\u003e elements, and add a behavior to show the\ndetails screen.hv/rows.xmlBehavior to push the contact details screen onto the stack when\npressed.Our Flask backend already has a route for serving the contact details\nat /contacts/\u003ccontact_id\u003e. In our template, we use a\nJinja variable to dynamically generate the URL path for the current\ncontact in the for-loop. We also used the “push” action to show the\ndetails by pushing a new screen onto the stack. If you reload the app,\nyou can now tap any contact in the list, and Hyperview will open the new\nscreen. However, the new screen will show an error message. That’s\nbecause our backend is still returning HTML in the response, and the\nHyperview client expects HXML. Let’s update the backend to respond with\nHXML and the proper headers.app.pyGenerate an XML response from a new template file.Just like the contacts() view,\ncontacts_view() uses render_to_response() to\nset the Content-Type header on the response. We’re also\ngenerating the response from a new HXML template, which we can create\nnow:hv/show.xmlExtend the base layout template.Override the header block of the layout template to\ninclude a “Back” button.Behavior to navigate to the previous screen when\npressed.Override the content block to show the full details\nof the selected contact.The contacts detail screen extends the base layout.xml\ntemplate, just like we did in index.xml. This time, we’re\noverriding content in both the header block and\ncontent block. Overriding the header block lets us add a\n“Back” button with a behavior. When pressed, the Hyperview client will\nunwind the navigation stack and return the user to the contacts\nlist.Note that triggering this behavior is not the only way to navigate\nback. The Hyperview client respects navigation conventions on different\nplatforms. On iOS, users can also navigate to the previous screen by\nswiping right from the left edge of the device. On Android, users can\nalso navigate to the previous screen by pressing the hardware back\nbutton. We don’t need to specify anything extra in the HXML to get these\ninteractions.Contact Details ScreenWith just a few simple changes, we’ve gone from a single-screen app\nto a multi-screen app. Note that we didn’t need to change anything in\nthe actual mobile app code to support our new screen. This is a big\ndeal. In traditional mobile app development, adding screens can be a\nsignificant task. Developers need to create the new screen, insert it\ninto the appropriate place of the navigation hierarchy, and write code\nto open the new screen from existing screens. In Hyperview, we just\nadded a behavior with action=\"push\".So far, our app lets us browse a list of contacts, and view details\nof a specific contact. Wouldn’t it be nice to update the name, phone\nnumber, or email of a contact? Let’s add UI to edit contacts as our next\nenhancement.First we have to figure out how we want to display the editing UI. We\ncould push a new editing screen onto the stack, the same way we pushed\nthe contact details screen. But that’s not the best design from a\nuser-experience perspective. Pushing new screens makes sense when\ndrilling down into data, like going from a list to a single item. But\nediting is not a “drill-down” interaction, it’s a mode switch between\nviewing and editing. So instead of pushing a new screen, let’s replace\nthe current screen with the editing UI. That means we need to add a\nbutton and behavior that use the reload action. This button\ncan be added to the header of the contact details screen.Snippet of hv/show.xmlThe new “Edit” button.Behavior to reload the current screen with the edit screen when\npressed.Once again, we’re reusing an existing Flask route\n(/contacts/\u003ccontact_id\u003e/edit) for the edit UI, and\nfilling in the contact ID using data passed to the Jinja template. We\nalso need to update the contacts_edit_get() view to return\nan XML response based on an HXML template (hv/edit.xml).\nWe’ll skip the code sample because the needed changes are identical to\nwhat we applied to contacts_view() in the previous section.\nInstead, let’s focus on the template for the edit screen.hv/edit.xmlForm wrapping the input fields and buttons.Container with ID, containing the input fields.Template include to render the input fields.Button to submit the form data and update the input fields\ncontainer.Since the edit screen needs to send data to the backend, we wrap the\nentire content section in a \u003cform\u003e element. This\nensures the form field data will be included in the HTTP requests to our\nbackend. Within the \u003cform\u003e element, our UI is divided\ninto two sections: the form fields, and the Save button. The actual form\nfields are defined in a separate template (form_fields.xml)\nand added to the edit screen using a Jinja include tag.hv/form_fields.xmlText input holding the current value for the contact’s first\nname.Text element that could display errors from the contact\nmodel.Another text field, this time for the contact’s last\nname.We omitted the code for the contact’s phone number and email address,\nbecause they follow the same pattern as the first and last name. Each\ncontact field has its own \u003ctext-field\u003e, and a\n\u003ctext\u003e element below it to display possible errors.\nThe \u003ctext-field\u003e has two important attributes:name defines the name to use when serializing the\ntext-field’s value into form data for HTTP requests. We are using the\nsame names as the web app from previous chapters\n(first_name, last_name, phone,\nemail). That way, we don’t need to make changes in our\nbackend to parse the form data.value defines the pre-filled data in the text field.\nSince we are editing an existing contact, it makes sense to pre-fill the\ntext field with the current name, phone, or email.You might be wondering, why did we choose to define the form fields\nin a separate template (form_fields.xml)? To understand\nthat decision, we need to first discuss the “Save” button. When pressed,\nthe Hyperview client will make an HTTP POST request to\ncontacts/\u003ccontact_id\u003e/edit, with form data serialized\nfrom the \u003ctext-field\u003e inputs. The HXML response will\nreplace the contents of form field container (ID\nform-fields). But what should that response be? That\ndepends on the validity of the form data:If the data is invalid (e.g., duplicate email address), our UI\nwill remain in the editing mode and show error messages on the invalid\nfields. This allows the user to correct the errors and try saving\nagain.If the data is valid, our backend will persist the edits, and our\nUI will switch back to a display mode (the contact details UI).So our backend needs to distinguish between a valid and invalid edit.\nTo support these two scenarios, let’s make some changes to the existing\ncontacts_edit_post() view in the Flask app.app.pyUpdate the contact object from the request’s form data.Attempt to persist the updates. This returns False\nfor invalid data.On success, render the form fields template, and pass a\nsaved flag to the templateOn failure, render the form fields template. Error messages are\npresent on the contact object.This view already contains conditional logic based on whether the\ncontact model save() succeeds. If save()\nfails, we render the form_fields.xml template.\ncontact.errors will contain error messages for the invalid\nfields, which will be rendered into the\n\u003ctext style=\"edit-field-error\"\u003e elements. If\nsave() succeeds, we will also render the\nform_fields.xml template. But this time, the template will\nget a saved flag, indicating success. We will update the\ntemplate to use this flag to implement our desired UI: switching the UI\nback to display mode.hv/form_fields.xmlOnly include this behavior after successfully saving a\ncontact.Trigger the behavior immediately.The behavior will reload the entire screen.The screen will be reloaded with the contact details\nscreen.The Jinja template conditional ensures that our behavior only renders\non successful saves, and not when the screen first opens (or the user\nsubmits invalid data). On success, the template includes a behavior that\ntriggers immediately thanks to trigger=\"load\". The action\nreloads the current screen with the Contact Details screen (from the\n/contacts/\u003ccontact_id\u003e route).The result? When the user hits “Save”, our backend persists the new\ncontact data, and the screen switches back to the Details screen. Since\nthe app will make a new HTTP request to get the contact details, it’s\nguaranteed to show the freshly saved edits.Why Not Redirect?You may remember the web app version of this code behaved a little\ndifferently. On a successful save, the view returned\nredirect(\"/contacts/\" + str(contact_id)). This HTTP\nredirect would tell the web browser to navigate to the contact details\npage.This approach is not supported in Hyperview. Why? A web app’s\nnavigation stack is simple: a linear sequence of pages, with only one\nactive page at a time. Navigation in a mobile app is considerably more\ncomplex. Mobile apps use a nested hierarchy of navigation stacks,\nmodals, and tabs. All screens in this hierarchy are active, and may be\ndisplayed instantly in response to user actions. In this world, how\nwould the Hyperview client interpret an HTTP redirect? Should it reload\nthe current screen, push a new one, or navigate to a screen in the stack\nwith the same URL?Instead of making a choice that would be suboptimal for many\nscenarios, Hyperview takes a different approach. Server-controlled\nredirects are not possible, but the backend can render navigation\nbehaviors into the HXML. This is what we do to switch from the Edit UI\nto the Details UI in the code above. Think of these as client-side\nredirects, or better yet client-side navigations.We now have a working Edit UI in our contacts app. Users can enter\nthe Edit mode by pressing a button on the contact details screen. In the\nEdit mode, they can update the contact’s data and save it to the\nbackend. If the backend rejects the edits as invalid, the app stays in\nEdit mode and shows the validation errors. If the backend accepts and\npersists the edits, the app will switch back to the details mode,\nshowing the updated contact data.Let’s add one more enhancement to the Edit UI. It would be nice to\nlet the user switch away from the Edit mode without needing to save the\ncontact. This is typically done by providing a “Cancel” action. We can\nadd this as a new button below the “Save” button.Snippet of hv/edit.xmlA new Cancel button on the edit screen.When pressed, reload the entire screen.The screen will be reloaded with the contact details\nscreen.This is the same technique we used to switch from the edit UI to the\ndetails UI upon successfully editing the contact. But pressing “Cancel”\nwill update the UI faster than pressing “Save.” On save, the app will\nfirst make a POST request to save the data, and then a\nGET request for the details screen. Cancelling skips the\nPOST, and immediately makes the GET\nrequest.Contact Edit ScreenAt this point, we can claim to have fully implemented the Edit UI.\nBut there’s a problem. In fact, if we stopped here, users may even\nconsider the app to be buggy! Why? It has to do with syncing the app\nstate across multiple screens. Let’s walk through this series of\ninteractions:Launch the app to the Contacts List.Press on the contact “Joe Blow” to load his Contact\nDetails.Press Edit to switch to the edit mode, and change the contact’s\nfirst name to “Joseph.”Press Save to switch back to viewing mode. The contact’s name is\nnow “Joseph Blow.”Hit the back button to return to the Contacts List.Did you catch the issue? Our Contacts list is still showing the same\nlist of names as when we launched the app. The contact we just renamed\nto “Joseph” is still showing up in the list as “Joe.” This is a general\nproblem in hypermedia applications. The client does not have a notion of\nshared data across different parts of the UI. Updates in one part of the\napp will not automatically update other parts of the app.Luckily, there’s a solution to this problem in Hyperview: events.\nEvents are built into the behavior system, and allow lightweight\ncommunication between different parts of the UI.Event BehaviorsEvents are a client-side feature of Hyperview. In Client-Side Scripting,\nwe discussed events while working with HTML, _hyperscript and the DOM.\nDOM Elements will dispatch events as a result of user interactions.\nScripts can listen for these events, and respond to them by running\narbitrary JavaScript code.Events in Hyperview are a good deal simpler, but they don’t require\nany scripting and can be defined declaratively in the HXML. This is done\nthrough the behavior system. Events require adding a new behavior\nattribute, action type, and trigger type:event-name: This attribute of\n\u003cbehavior\u003e defines the name of the event that will\neither be dispatched or listened for.action=\"dispatch-event\": When triggered, this\nbehavior will dispatch an event with the name defined by the\nevent-name attribute. This event is dispatched globally\nacross the entire Hyperview app.trigger=\"on-event\": This behavior will trigger if\nanother behavior in the app dispatches an event matching the\nevent-name attribute.If a \u003cbehavior\u003e element uses\naction=\"dispatch-event\" or trigger=\"on-event\",\nit must also define an event-name. Note that multiple\nbehaviors can dispatch an event with the same name. Likewise, multiple\nbehaviors can trigger on the same event name.Let’s look at this simple behavior:\u003cbehavior trigger=\"press\" action=\"toggle\" target=\"container\" /\u003e.Pressing an element containing this behavior will toggle the\nvisibility of an element with the ID “container”. But what if the\nelement we want to toggle is on a different screen? The “toggle” action\nand target ID lookup only work on the current screen, so this solution\nwouldn’t work. The solution is to create two behaviors, one on each\nscreen, communicating via events:Screen A:\n\u003cbehavior trigger=\"press\" action=\"dispatch-event\" event-name=\"button-pressed\" /\u003eScreen B:\n\u003cbehavior trigger=\"on-event\" event-name=\"button-pressed\" action=\"toggle\" target=\"container\" /\u003ePressing an element containing the first behavior (on Screen A) will\ndispatch an event with the name “button-pressed”. The second behavior\n(on Screen B) will trigger on an event with this name, and toggle the\nvisibility of an element with ID “container”.Events have plenty of uses, but the most common is to inform\ndifferent screens about backend state changes that require the UI to be\nre-fetched.We now know enough about Hyperview’s event system to solve the bug in\nour app. When the user saves a change to a contact, we need to dispatch\nan event from the Details screen. And the Contacts screen needs to\nlisten to that event, and reload itself to reflect the edits. Since the\nform_fields.xml template already gets the\nsaved flag when the backend successfully saves a contact,\nit’s a good place to dispatch the event:Snippet from\nhv/form_fields.xmlTrigger the behavior immediately.The behavior will dispatch an event.The event name is “contact-updated”.The existing behavior to show the Details UI.Now, we just need the contacts list to listen for the\ncontact-updated event, and reload itself:Snippet from hv/index.xmlTrigger the behavior on event dispatch.Trigger the behavior for dispatched events with the name\n“contact-updated”.When triggered, replace the contents of the\n\u003clist\u003e element with rows from the backend.Any time the user edits a contact, the Contacts List screen will\nupdate to reflect the edits. The addition of these two\n\u003cbehavior\u003e elements fixes the bug: the Contacts List\nscreen will correctly show “Joseph Blow” in the list. Note that we\nintentionally added the new behavior inside the\n\u003cform\u003e element. The ensures the triggered request\nwill preserve any search query.To show what we mean, let’s revisit the set of steps that\ndemonstrated the buggy behavior. Assume that before pressing on “Joe\nBlow,” the user had searched the contacts by typing “Joe” in the search\nfield. When the user later updates the contact to “Joseph Blow”, our\ntemplate dispatches the “contact-updated” event, which triggers the\nreplace-inner behavior on the contact list screen. Due to\nthe \u003cform\u003e element, the search query “Joe” will be\nserialized with the request:\nGET /contacts?rows_only=true\u0026q=Joe. Since the name\n“Joseph” doesn’t match the query “Joe”, the contact we edited will not\nappear in the list (until the user clears out the query). Our app’s\nstate remains consistent across our backend and all active screens.Events introduce a level of abstraction to behaviors. So far, we’ve\nseen that editing a contact will cause the list of contacts to refresh.\nBut the list of contacts should also refresh after other actions, such\nas deleting a contact or adding a new contact. As long as our HXML\nresponses for deletion or creation include a behavior to dispatch a\ncontact-updated event, then we will get the desired refresh\nbehavior on the contacts list screen.The screen doesn’t care what causes the contact-updated\nevent to be dispatched. It just knows what it needs to do when it\nhappens.Speaking of deleting a contact, this is a good next feature to\nimplement. We will let users delete a contact from the Edit UI. So let’s\nadd a new button to edit.xml.Snippet of hv/edit.xmlNew Delete Contact button on the edit screen.When pressed, append HXML to a container on the screen.The HXML will be fetched by making a\nPOST /contacts/\u003ccontact_id\u003e/delete request.The HXML for the Delete button is pretty similar to the Save button,\nbut there are a few subtle differences. Remember, pressing the Save\nbutton results in one of two expected outcomes: failing and showing\nvalidation errors on the form, or succeeding and switching to the\ncontact details screen. To support the first outcome (failing and\nshowing validation errors), the save behavior replaces the contents of\nthe \u003cview id=\"form-fields\"\u003e container with a\nre-rendered version of form_fields.xml. Therefore, using\nthe replace-inner action makes sense.Deletion does not involve a validation step, so there’s only one\nexpected outcome: successfully deleting the contact. When deletion\nsucceeds, the contact no longer exists. It doesn’t make sense to show\nthe edit UI or contact details for a non-existent contact. Instead, our\napp will navigate back to the previous screen (the contacts list). Our\nresponse will only include behaviors that trigger immediately, there’s\nno UI to change. Therefore, using the append action will\npreserve the current UI while Hyperview runs the actions.Snippet of hv/deleted.xmlOn load, dispatch the contact-updated event to\nupdate the contact lists screen.Navigate back to the contacts list screen.Note that in addition to behavior to navigate back, this template\nalso includes a behavior to dispatch the contact-updated\nevent. In the previous chapter section, we added a behavior to\nindex.xml to refresh the list when that event is\ndispatched. By dispatching the event after a deletion, we will make sure\nthe deleted contact gets removed from the list.Once again, we’ll skip over the changes to the Flask backend. Suffice\nit to say, we will need to update the contacts_delete()\nview to respond with the hv/deleted.xml template. And we\nneed to update the route to support POST in addition to\nDELETE, since the Hyperview client only understands\nGET and POST.We now have a fully functioning deletion feature! But it’s not the\nmost user-friendly: it takes one accidental tap to permanently delete a\ncontact. For destructive actions like deleting a contact, it’s always a\ngood idea to ask the user for confirmation.We can add a confirmation to the delete behavior by using the\nalert system action described in the previous chapter. As\nyou recall, the alert action will show a system dialog box\nwith buttons that can trigger other behaviors. All we have to do is wrap\nthe delete \u003cbehavior\u003e in a behavior that uses\naction=\"alert\".Delete button in\nhv/edit.xmlPressing “Delete” triggers an action to show the system dialog\nwith the given title and message.The first pressable option in the system dialog.Pressing the first option will trigger contact deletion.The second pressable option has no behavior, so it only closes\nthe dialog.Unlike before, pressing the delete button will not have an immediate\neffect. Instead, the user will be presented with the dialog box and\nasked to confirm or cancel. Our core deletion behavior didn’t change, we\njust chained it from another behavior.Delete Contact confirmationAdding a new contact is the last feature we want to support in our\nmobile app. And luckily, it’s also the easiest. We can reuse the\nconcepts (and even some templates) from features we’ve already\nimplemented. In particular, adding a new contact is very similar to\nediting an existing contact. Both features need to:Show a form to collect information about the contact.Have a way to save the entered information.Show validation errors on the form.Persist the contact when there are no validation errors.Since the functionality is so similar, we’ll summarize the changes\nhere without showing the code.Update index.xml.Override the header block to add a new “Add”\nbutton.Include a behavior in the button. When pressed, push a new screen\nas a modal by using action=\"new\", and request the screen\ncontent from /contacts/new.Create a template hv/new.xml.Override the header block to include a button that closes the\nmodal, using action=\"close\".Include the hv/form_fields.xml template to render\nempty form fieldsAdd a “Add Contact” button below the form fields.Include a behavior in the button. When pressed, make a\nPOST request to /contacts/new, and use\naction=\"replace-inner\" to update the form fields.Update the Flask view.Change contacts_new_get() to use\nrender_to_response() with the hv/new.xml\ntemplate.Change contacts_new() to use\nrender_to_response() with the\nhv/form_fields.xml template. Pass saved=True\nwhen rendering the template after successfully persisting the new\ncontact.By reusing form_fields.xml for both editing and adding a\ncontact, we get to reuse some code and ensure the two features have a\nconsistent UI. Also, our “Add Contact” screen will benefit from the\n“saved” logic that’s already a part of form_fields.xml.\nAfter successfully adding a new contact, the screen will dispatch the\ncontact-updated event, which will refresh the contacts list\nand show the newly added contact. The screen will reload itself to show\nthe Contact Details.Add Contact modalWith the completion of the contact creation UI, we have a fully\nimplemented mobile app. It supports searching a list of contacts,\nviewing the details of a contact, editing and deleting a contact, and\nadding a new contact. But so far, we’ve been developing the app using a\nsimulator on our desktop computer. How can we see it running on a mobile\ndevice? And how can we get it into the hands of our users?To see the app running on a physical device, let’s take advantage of\nthe Expo platform’s app preview functionality.Download the Expo Go app on an Android or iOS device.Restart the Flask app, binding to an interface accessible on your\nnetwork. This might look something like\nflask run --host 192.168.7.229, where the host is your\ncomputer’s IP address on the network.Update the Hyperview client code so that\nENTRY_POINT_URL (in demo/src/constants.js)\npoints to the IP and port that the Flask server is bound to.After running yarn start in the Hyperview demo app,\nyou will see a QR code printed in the console, with instructions on how\nto scan it on Android and iOS.Once you scan the QR code, the full app will run on the device. As\nyou interact with the app, you will see HTTP requests made to the Flask\nserver. You can even use the physical device during development. Any\ntime you make a change in the HXML, just reload the screen to see the UI\nupdates.So we have the app running on a physical device, but it’s still not\nproduction ready. To get the app into the hands of our users, there’s a\nfew things we need to do:Deploy our backend in production. We need to use a\nproduction-grade web server like Gunicorn instead of the Flask\ndevelopment server. And we should run our app on a machine reachable on\nthe Internet, most likely using a cloud provider like AWS or\nHeroku.Create standalone binary apps. By following the instructions from\nthe Expo project, we can create a .ipa or .apk\nfile, for the iOS and Android platforms. Remember to update\nENTRY_POINT_URL in the Hyperview client to point to the\nproduction backend.Submit our binaries to the iOS App Store or Google Play Store,\nand wait for app approval.Once the app is approved, congratulations! Our mobile app can be\ndownloaded by Android and iOS users. And here’s the best part: Because\nour app uses the hypermedia architecture, we can add features to our app\nby simply updating the backend. The UI and interactions are completely\nspecified with the HXML generated from server-side templates. Want to\nadd a new section to a screen? Just update an existing HXML template.\nWant to add a new type of screen to the app? Create a new route, view,\nand HXML template. Then, add a behavior to an existing screen that will\nopen the new screen. To push these changes to your users, you just need\nto re-deploy the backend. Our app knows how to interpret HXML, and\nthat’s enough for it to understand how to handle the new features.To create a mobile app using the hypermedia architecture, we started\nwith the web-based contacts app and made a few changes, primarily\nreplacing HTML templates with HXML templates. But in the process of\nporting the backend to serve our mobile app, we lost the web application\nfunctionality. Indeed, if you tried to visit\nhttp://0.0.0.0:5000 in a web browser, you would see a\njumble of text and XML markup. That’s because web browsers don’t know\nhow to render plain XML, and they certainly don’t know how to interpret\nthe tags and attributes of HXML to render an app. It’s a shame, because\nthe Flask code for the web application and mobile app are nearly\nidentical. The database and model logic are shared, and most of the\nviews are unchanged as well.At this point you’re surely wondering: is it possible to use the same\nbackend to serve both a web application and mobile app? The answer is\nyes! In fact, this is one of the benefits of using a hypermedia\narchitecture across multiple platforms. We don’t need to port any\nclient-side logic from one platform to another, we just need to respond\nto requests with the appropriate Hypermedia format. To do this, we will\nutilize content negotiation built into HTTP.Imagine a German speaker and Japanese speaker both visit\nhttps://google.com in their web browser. They will see the\nGoogle home page localized in German and Japanese, respectively. How\ndoes Google know to return a different version of the homepage based on\nthe user’s preferred language? The answer lies in the REST architecture,\nand how it separates the concepts of resources and representations.In the REST architecture, the Google homepage is considered to be a\nsingle “resource,” represented by a unique URL. However, that single\nresource can have multiple “representations.” Representations are\nvariations on how the content of the resource is presented to the\nclient. The German and Japanese versions of the Google homepage are two\nrepresentations of the same resource. To determine the best\nrepresentation of a resource to return, HTTP clients and servers engage\nin a process called “content negotiation.” It works like this:Clients specify the preferred representation through\nAccept-* request headers.The server tries to match the preferred representation as best it\ncan, and communicates back the chosen representation using\nContent-*.In the Google homepage example, the German speaker uses a browser\nthat is set to prefer content localized for German. Every HTTP request\nmade by the web browser will include a header\nAccept-Language: de-DE. The server sees the request header,\nand it will return a response localized for German (if it can). The HTTP\nresponse will include a Content-Language: de-DE header to\ninform the client of the language of the response content.Language is just one factor for resource representation. More\nimportantly for us, resources can be represented using different content\ntypes, such as HTML or HXML. Content negotiation over content type is\ndone using the Accept request header and\nContent-Type response header. Web browsers set\ntext/html as the preferred content type in the\nAccept header. The Hyperview client sets\napplication/vnd.hyperview+xml as the preferred content\ntype. This gives our backend a way to distinguish requests coming from a\nweb browser or Hyperview client, and serve the appropriate content to\neach.There are two main approaches to content negotiation: fine-grained\nand global.When we ported the Contacts app from the web to mobile, we kept all\nof the Flask views but made some minor changes. Specifically, we\nintroduced a new function render_to_response() and called\nit in the return statement of each view. Here’s the function again to\nrefresh your memory:app.pyrender_to_response() renders a template with the given\ncontext, and turns it into an Flask response object with the appropriate\nHyperview Content-Type header. Obviously, the\nimplementation is highly-specific to serving our Hyperview mobile app.\nBut we can modify the function to do content negotiation based on the\nrequest’s Accept header:app.pyFunction signature takes two templates, one for HTML and one for\nHXML.Determine whether the client wants HTML or HXML.Select the template based on the best match for the\nclient.Set the Content-Type header based on the best match\nfor the client.Flask’s request object exposes an accept_mimetypes\nproperty to help with content negotiation. We pass our two content MIME\ntypes to request.accept_mimetypes.best_match() and get back\nthe MIME type that works for our client. Based on the best matching MIME\ntype, we choose to either render an HTML template or HXML template. We\nalso make sure to set the Content-Type header to the\nappropriate MIME type. The only difference in our Flask views is that we\nneed to provide both an HTML and HXML template:app.pyTemplate switching between an HTML and HXML template, based on\nthe client.After updating all of the Flask views to support both templates, our\nbackend will support both web browsers and our mobile app! This\ntechnique works well for the Contacts app because the screens in the\nmobile app map directly to pages of the web application. Each app has a\ndedicated page (or screen) for listing contacts, showing and editing\ndetails, and creating a new contact. This meant the Flask views could be\nkept as-is without major changes.But what if we wanted to re-imagine the Contacts app UI for our\nmobile app? Perhaps we want the mobile app to use a single screen, with\nrows that expanded in-line to support viewing and editing the\ninformation? In situations where the UI diverges between platforms,\nTemplate Switching becomes cumbersome or impossible. We need a different\napproach to have one backend serve both hypermedia formats.If you recall, the Contacts web app has an index view,\nrouted from the root path /:app.pyRedirect requests from “/” to “/contacts”When someone requests to the root path of the web application, Flask\nredirects them to the /contacts path. This redirect also\nworks in our Hyperview mobile app. The Hyperview client’s\nENTRY_POINT_URL points to\nhttp://0.0.0.0:5000/, and the server redirects it to\nhttp://0.0.0.0:5000/contacts. But there’s no law that says\nwe need to redirect to the same path in our web application and mobile\napp. What if we used the Accept header to redirect to\ndecide on the redirect path?app.pyDetermine whether the client wants HTML or HXML.If the client wants HXML, redirect them to\n/mobile/contacts.If the client wants HTML, redirect them to\n/web/contacts.The entry point is a fork in the road: if the client wants HTML, we\nredirect them to one path. If the client wants HXML, we redirect them to\na different path. These redirects would be handled by different Flask\nviews:app.pyThe mobile_contacts() view would render an HXML template\nwith a list of contacts. Tapping a contact item would open a screen\nrequested from /mobile/contacts/1, handled by a view\nmobile_contacts_view. After the initial fork, all\nsubsequent requests from our mobile app go to paths prefixed with\n/mobile/, and get handled by mobile-specific Flask views.\nLikewise, all subsequent requests from the web app go to paths prefixed\nwith /web/, and get handled by web-specific Flask views.\n(Note that in practice, we would want to separate the web and mobile\nviews into separate parts of our codebase: web_app.py and\nmobile_app.py. We may also choose not to prefix the web\npaths with /web/, if we want more elegant URLs displayed in\nthe browser’s address bar.)You may be thinking that the Redirect Fork leads to a lot of code\nduplication. After all, we need to write double the number of views: one\nset for the web application, and one set for the mobile app. That is\ntrue, which is why the Redirect Fork is only preferred if the two\nplatforms require a disjointed set of view logic. If the apps are\nsimilar on both platforms, Template Switching will save a lot of time\nand keep the apps consistent. Even if we need to use the Redirect Fork,\nthe bulk of the logic in our models can be shared by both sets of\nviews.In practice, you may start out using Template Switching, but then\nrealize you need to implement a fork for platform-specific features. In\nfact, we’re already doing that in the Contacts app. When porting the app\nfrom web to mobile, we didn’t bring over certain features like archiving\nfunctionality. The dynamic archive UI is a power feature that wouldn’t\nmake sense on a mobile device. Since our HXML templates don’t expose any\nentry points to the Archive functionality, we can treat it as “web-only”\nand not worry about supporting it in Hyperview.We’ve covered a lot of ground in this chapter. Take a breath and take\nstock of how far we’ve come: we ported the core functionality of the\nContact.app web application to mobile. And we did it by re-using much of\nour Flask backend and while sticking with Jinja templating. We again saw\nthe utility of events for connecting different aspects of an\napplication.We’re not done yet. In the next chapter we’ll implement custom\nbehaviors and UI elements to finish our mobile Contact.app.Unlike a JSON API, the hypermedia API you produce for your\nhypermedia-driven application should feature endpoints specialized for\nyour particular application’s UI needs.Because hypermedia APIs are not designed to be consumed by\ngeneral-purpose clients you can set aside the pressure to keep them\ngeneralized and produce the content specifically needed for your\napplication. Your endpoints should be optimized to support your\nparticular applications UI/UX needs, not for a general-purpose\ndata-access model for your domain model.A related tip is that, when you have a hypermedia-based API, you can\naggressively refactor your API in a way that is heavily discouraged when\nwriting JSON API-based SPAs or mobile clients. Because hypermedia-based\napplications use Hypermedia As The Engine Of Application State, you are\nable and, in fact, encouraged, to change the shape of them as your\napplication developers and as use cases change.A great strength of the hypermedia approach is that you can\ncompletely rework your API to adapt to new needs over time without\nneeding to version the API or even document it. Take advantage of\nit!"
 },
 {
 "chapter": "Extending The Hyperview Client",
 "content": "In the previous chapter, we created a fully-featured native mobile\nversion of our Contacts app. Aside from customizing the entry point URL,\nwe didn’t need to touch any code that runs on the mobile device. We\ndefined our mobile app’s UI and logic completely in the backend code,\nusing Flask and HXML templates. This is possible because the standard\nHyperview client supports all of the basic features by mobile apps.But the standard Hyperview client can’t do everything out of the box.\nAs app developers, we want apps to have unique touches like custom UIs\nor deep integration with platform capabilities. To support these needs,\nthe Hyperview client was designed to be extended with custom behavior\nactions and UI elements. In this section, we will enhance our mobile app\nwith examples of both.Before diving in, let’s take a quick look at the tech stack we’ll be\nusing. The Hyperview client is written in React Native, a popular\ncross-platform framework for creating mobile apps. It uses the same\ncomponent-based API as React. This means developers familiar with\nJavaScript and React can quickly pick up React Native. React Native has\na healthy ecosystem of open-source libraries. We’ll be leveraging these\nlibraries to create our custom extensions to the Hyperview client.Let’s start with the most obvious feature missing from our Contacts\napp: phone calls. Mobile devices can make phone calls. The contacts in\nour app have phone numbers. Shouldn’t our app support calling those\nphone numbers? And while we’re at it, our app should also support\ne-mailing the contacts.On the web, calling phone numbers is supported with the\ntel: URI scheme, and e-mails are supported with the\nmailto: URI scheme:tel and mailto schemes in\nHTMLWhen clicked, prompt the user to call the given phone\nnumberWhen clicked, open an e-mail client with the given address\npopulated in the to: field.The Hyperview client doesn’t support the tel: and\nmailto: URI schemes. But we can add these capabilities to\nthe client with custom behavior actions. Remember that behaviors are\ninteractions defined in HXML. Behaviors have triggers (“press”,\n“refresh”) and actions (“update”, “share”). The values of “action” are\nnot limited to the set that comes in the Hyperview library. So let’s\ndefine two new actions, “open-phone” and “open-email”.Phone and Email actionsDefine an alias for an XML namespace used by our new\nattributes.When pressed, prompt the user to call the given phone\nnumber.When pressed, open an e-mail client with the given address\npopulated in the to: field.Notice we defined the actual phone number and email address using\nseparate attributes. In HTML, the scheme and data are crammed into the\nhref attribute. HXML’s \u003cbehavior\u003e\nelements give more options for representing the data. We chose to use\nattributes, but we could have represented the phone number or email\nusing child elements. We’re also using a namespace to avoid potential\nfuture conflicts with other client extensions.So far so good, but how does the Hyperview client know how to\ninterpret open-phone and open-email, and how\nto reference the phone-number and\nemail-address attributes? This is where we finally need to\nwrite some JavaScript.First, we’re going to add a 3rd-party library\n(react-native-communications) to our demo app. This library\nprovides a simple API that interacts with OS-level functionality for\ncalls and emails.Add dependency on\nreact-native-communicationsRe-start the mobile appNext, we’ll create a new file, phone.js, that will\nimplement the code associated with the open-phone\naction:demo/src/phone.jsImport the function we need from the 3rd party library.The name of the action.The callback that runs when the action triggers.Get the phone number from the \u003cbehavior\u003e\nelement.Pass the phone number to the function from the 3rd party\nlibrary.Custom actions are defined as a JavaScript object with two keys:\naction and callback. This is how the Hyperview\nclient associates a custom action in the HXML with our custom code. The\ncallback value is a function that takes a single parameter,\nbehaviorElement. This parameter is an XML DOM\nrepresentation of the \u003cbehavior\u003e element that\ntriggered the action. That means we can call methods on it like\ngetAttribute, or access attributes like\nchildNodes. In this case, we use\ngetAttributeNS to read the phone number from the\nphone-number attribute on the \u003cbehavior\u003e\nelement. If the phone number is defined on the element, we can call the\nphonecall() function provided by the\nreact-native-communications library.There’s one more thing to do before we can use our custom action:\nregister the action with the Hyperview client. The Hyperview client is\nrepresented as a React Native component called Hyperview.\nThis component takes a prop called behaviors, which is an\narray of custom action objects like our “open-phone” action. Let’s pass\nour “open-phone” implementation to the Hyperview component\nin our demo app.demo/src/HyperviewScreen.jsImport the open-phone action.Create an array of custom actions.Pass the custom actions to the Hyperview component,\nas a prop called behaviors.Under the hood, the Hyperview component is responsible\nfor taking HXML and turning it into mobile UI elements. It also handles\ntriggering behavior actions based on user interactions.By passing the “open-phone” action to Hyperview, we can now use it as\na value for the action attribute on\n\u003cbehavior\u003e elements. In fact, let’s do that now by\nupdating the show.xml template in our Flask app:Snippet of hv/show.xmlAdd a behavior to the phone number section that triggers on\n“press.”Trigger the new “open-phone” action.Set the attribute expected by the “open-phone” action.Same idea, with a different action (“open-email”).We’ll skip over the implementation of the second custom action,\n“open-email.” As you can guess, this action will open a system-level\nemail composer to let the user send an email to their contact. The\nimplementation of “open-email” is almost identical to “open-phone.” The\nreact-native-communications library exposes a function\ncalled email(), so we just wrap it and pass arguments to it\nin the same way.We now have a complete example of extending the client with custom\nbehavior actions. We chose a new name for our actions (“open-phone” and\n“open-email“), and mapped those names to functions. The functions take\n\u003cbehavior\u003e elements and can run any arbitrary React\nNative code. We wrapped an existing 3rd party library, and read\nattributes set on the \u003cbehavior\u003e element to pass data\nto the library. After re-starting our demo app, our client has new\ncapabilities we can immediately utilize by referencing the actions from\nour HXML templates.The phone and email actions added in the previous section are\nexamples of “system actions.” System actions trigger some UI or\ncapability provided by the device’s OS. But custom actions are not\nlimited to interacting with OS-level APIs. Remember, the callbacks that\nimplement actions can run arbitrary code, including code that renders\nour own UI elements. This next custom action example will do just that:\nrender a custom confirmation message UI element.If you recall, our Contacts web app shows messages upon successful\nactions, such as deleting or creating a contact. These messages are\ngenerated in the Flask backend using the flash() function,\ncalled from the views. Then the base layout.html template\nrenders the messages into the final web page.Snippet templates/layout.htmlOur Flask app still includes the calls to flash(), but\nthe Hyperview app is not accessing the flashed message to display to the\nuser. Let’s add that support now.We could just show the messages using a similar technique to the web\napp: loop through the messages and render some \u003ctext\u003e\nelements in layout.xml. This approach has a major downside:\nthe rendered messages would be tied to a specific screen. If that screen\nwas hidden by a navigation action, the message would be hidden too. What\nwe really want is for our message UI to display “above” all of the\nscreens in the navigation stack. That way, the message would remain\nvisible (fading away after a few seconds), even if the stack of screens\nchanges below. To display some UI outside of the\n\u003cscreen\u003e elements, we’re going to need to extend the\nHyperview client with a new custom action, show-message.\nThis is another opportunity to use an open-source library,\nreact-native-root-toast. Let’s add this library to our demo\napp.]Add dependency on react-native-root-toastRe-start the mobile appNow, we can write the code to implement the message UI as a custom\naction.demo/src/message.jsImport the Toast API.The name of the action.The callback that runs when the action triggers.Pass the message to the toast library.This code looks very similar to the implementation of\nopen-phone. Both callbacks follow a similar pattern: read\nnamespaced attributes from the \u003cbehavior\u003e element,\nand pass those values to a 3rd party library. For simplicity, we’re\nhard-coding options to show the message at the top of the screen, fading\nout after 2 seconds. But react-native-root-toast exposes\nmany options for positioning, timing of animations, colors, and more. We\ncould specify these options using extra attributes on\nbehaviorElement to make the action more configurable. For\nour purposes, we will just stick to a bare-bones implementation.Now we need to register our custom action with the\n\u003cHyperview\u003e component, by passing it to the\nbehaviors prop.demo/src/HyperviewScreen.jsImport the show-message action.Pass the action to the Hyperview component, as a\nprop called behaviors.All that’s left to do is trigger the show-message action\nfrom our HXML. There are three user actions that result in showing a\nmessage:Creating a new contactUpdating an existing contactDeleting a contactThe first two actions are implemented in our app using the same HXML\ntemplate, form_fields.xml. Upon successfully creating or\nupdating a contact, this template will reload the screen and trigger an\nevent, using behaviors that trigger on “load”. The deletion action also\nuses behaviors that trigger on “load”, defined in the\ndeleted.xml template. So both form_fields.xml\nand deleted.xml need to be modified to also show messages\non load. Since the actual behaviors will be the same in both templates,\nlet’s create a shared template to reuse the HXML.hv/templates/messages.xmlDefine a behavior for each message to display.Trigger this behavior as soon as the element loads.Trigger the new “show-message” action.The “show-message” action will display the flashed message in its\nUI.Like in layout.html of the web app, we loop through all\nof the flashed messages and render some markup for each message.\nHowever, in the web app, the message was directly rendered into the web\npage. In the Hyperview app, each message is displayed using a behavior\nthat triggers our custom UI. Now we just need to include this template\nin form_fields.xml:Snippet of hv/templates/form_fields.xmlShow the messages as soon as the screen loads.And we can do the same thing in deleted.xml:hv/templates/deleted.xmlShow the messages as soon as the screen loads.In both form_fields.xml and deleted.xml,\nmultiple behaviors get triggered on “load.” In deleted.xml,\nwe immediately navigate back to the previous screen. In\nform_fields.xml, we immediately reload the current screen\nto show the Contact details. If we rendered our message UI elements\ndirectly in the screen, the user would barely see them before the screen\ndisappeared or reloaded. By using a custom action, the message UI\nremains visible even while the screens change beneath them.Message shown during back navigationTo add communication capabilities and the message UI, we extended the\nclient with custom behavior actions. But the Hyperview client can also\nbe extended with custom UI components that render on the screen. Custom\ncomponents are implemented as React Native components. That means\nanything that’s possible in React Native can be done in Hyperview as\nwell! Custom components open up endless possibilities to build rich\nmobile apps with the Hypermedia architecture.To illustrate the possibilities, we will extend the Hyperview client\nin our mobile app to add a “swipeable row” component. How does it work?\nThe “swipeable row” component supports a horizontal swiping gesture. As\nthe user swipes this component from right to left, the component will\nslide over, revealing a series of action buttons. Each action button\nwill be able to trigger standard Hyperview behaviors when pressed. We\nwill use this custom component in our Contacts List screen. Each contact\nitem will be a “swipeable row”, and the actions will give quick access\nto edit and delete actions for the contact.Swipeable contact itemRather than implementing the swipe gesture from scratch, we will once\nagain use an open-source third-party library:\nreact-native-swipeable.]Add dependency on react-native-swipeable.Re-start the mobile app.This library provides a React Native component called\nSwipeable. It can render any React Native components as its\nmain content (the part that can be swiped). It also takes an array of\nReact Native components as a prop to render as the action buttons.When designing a custom component, we like to define the HXML of the\ncomponent before writing the code. This way, we can make sure the markup\nis expressive but succinct, and will work with the underlying\nlibrary.For the swipeable row, we need a way to represent the entire\ncomponent, the main content, and one of many buttons.]Parent element encapsulating the entire swipeable row, with\ncustom namespace.The main content of the swipeable row, can hold any\nHXML.The first button that appears when swiping, can hold any\nHXML.The second button that appears when swiping, can hold any\nHXML.This structure clearly separates the main content from the buttons.\nIt also supports one, two, or more buttons. Buttons appear in the order\nof definition, making it easy to swap the order.This design covers everything we need to implement a swipeable row\nfor our contacts list. But it’s also generic enough to be reusable. The\nprevious markup contains nothing specific to the contact name, editing\nthe contact, or deleting the contact. If later we add another list\nscreen to our app, we can use this component to make the items in that\nlist swipeable.Now that we know the HXML structure of our custom component, we can\nwrite the code to implement it. What does that code look like? Hyperview\ncomponents are written as React Native components. These React Native\ncomponents are mapped to a unique XML namespace and tag name. When the\nHyperview client encounters that namespace and tag name in the HXML, it\ndelegates rendering of the HXML element to the matching React Native\ncomponent. As part of delegation, the Hyperview Client passes several\nprops to the React Native component:element: The XML DOM element that maps to the React\nNative component.stylesheets: The styles defined in the\n\u003cscreen\u003e.onUpdate: The function to call when the component\ntriggers a behavior.option: Miscellaneous settings used by the Hyperview\nclient.Our swipeable row component is a container with slots to render\narbitrary main content and buttons. That means it needs to delegate back\nto the Hyperview client to render those parts of the UI. This is done\nwith a public function exposed by the Hyperview client,\nHyperview.renderChildren().Now that we know how custom Hyperview components are implemented,\nlet’s write the code for our swipeable row.demo/src/swipeable.jsClass-based React Native component.Map this component to the given HXML namespace.Map this component to the given HXML tag name.Function that returns an array of React Native components for\neach \u003cbutton\u003e element.Delegate to the Hyperview client to render each button.Pass the buttons and main content to the third-party\nlibrary.Delegate to the Hyperview client to render the main\ncontent.The SwipeableRow class implements a React Native\ncomponent. At the top of the class, we set a static\nnamespaceURI property and localName property.\nThese properties map the React Native component to a unique namespace\nand tag name pair in the HXML. This is how the Hyperview client knows to\ndelegate to SwipeableRow when encountering custom elements\nin the HXML. At the bottom of the class, you’ll see a\nrender() method. render() gets called by React\nNative to return the rendered component. Since React Native is built on\nthe principle of composition, render() typically returns a\ncomposition of other React Native components. In this case, we return\nthe Swipeable component (provided by the\nreact-native-swipeable library), composed with React Native\ncomponents for the buttons and main content. The React Native components\nfor the buttons and main content are created using a similar\nprocess:Find the specific child elements (\u003cbutton\u003e or\n\u003cmain\u003e).Turn those elements into React Native components using\nHyperview.renderChildren().Set the components as children or props of\nSwipeable.Rendering delegation between the client and the custom\ncomponentsThis code may be hard to follow if you’ve never worked with React or\nReact Native. That’s OK. The important takeaway is: we can write code to\ntranslate arbitrary HXML into React Native components. The structure of\nthe HXML (both attributes and elements) can be used to represent\nmultiple facets of the UI (in this case, the buttons and main content).\nFinally, the code can delegate rendering of child components back to the\nHyperview client.The result: this swipeable row component is completely generic. The\nactual structure and styling and interactions of the main content and\nbuttons can be defined in the HXML. Creating a generic component means\nwe can reuse it across multiple screens for different purposes. If we\nadd more custom components or new behavior actions in the future, they\nwill work with our swipeable row implementation.The last thing to do is register this new component with the\nHyperview client. The process is similar to registering custom actions.\nCustom components are passed as a separate components prop\nto the Hyperview component.demo/src/HyperviewScreen.jsImport the SwipeableRow component.Create an array of custom components.Pass the custom component to the Hyperview\ncomponent, as a prop called components.We’re now ready to update our HXML templates to make use of the new\nswipeable row component.Currently, the HXML for a contact item in the list consists of a\n\u003cbehavior\u003e and \u003ctext\u003e element:Snippet of hv/rows.xmlWith our swipeable row component, this markup will become the “main”\nUI. So let’s start by adding \u003crow\u003e and\n\u003cmain\u003e as ancestor elements.Adding swipeable row\nhv/rows.xmlAdded \u003cswipe:row\u003e ancestor element, with\nnamespace alias for swipe.Added \u003cswipe:main\u003e element to define the main\ncontent.Wrapped the existing \u003cbehavior\u003e and\n\u003ctext\u003e elements in a\n\u003cview\u003e.Previously, the contact-item style was set on the\n\u003citem\u003e element. That made sense when the\n\u003citem\u003e element was the container for the main content\nof the list item. Now that the main content is a child of\n\u003cswipe:main\u003e, we need to introduce a new\n\u003cview\u003e where we apply the styles.If we reload our backend and mobile app, you won’t experience any\nchanges on the Contacts List screen yet. Without any action buttons\ndefined, there’s nothing to reveal when swiping a row. Let’s add two\nbuttons to the swipeable row.Adding swipeable row\nhv/rows.xmlAdded \u003cswipe:button\u003e for edit action.Added \u003cswipe:button\u003e for delete\naction.Now if we use our mobile app, we can see the swipeable row in action!\nAs you swipe the contact item, the “Edit” and “Delete” buttons reveal\nthemselves. But they don’t do anything yet. We need to add some\nbehaviors to these buttons. The “Edit” button is straight-forward:\npressing it should open the contact details screen in edit mode.Snippet of hv/rows.xmlWhen pressed, push a new screen with the Edit Contact\nUI.The “Delete” button is a bit more complicated. There’s no screen to\nopen for deletion, so what should happen when the user presses this\nbutton? Perhaps we use the same interaction as the “Delete” button on\nthe Edit Contact screen. That interaction brings up a system dialog,\nasking the user to confirm the deletion. If the user confirms, the\nHyperview client makes a POST request to\n/contacts/\u003ccontact_id\u003e/delete, and appends the\nresponse to the screen. The response triggers a few behaviors\nimmediately to reload the contacts list and show a message. This\ninteraction will work for our action button as well:Snippet of hv/rows.xmlWhen pressed, open a system dialog box asking the user to confirm\nthe action.If confirmed, make a POST request to the deletion endpoint, and\nappend the response to the enclosing \u003citem\u003e.Now when we press “Delete,” we get the confirmation dialog as\nexpected. After pressing confirm, the backend response triggers\nbehaviors that show a confirmation message and reload the list of\ncontacts. The item for the deleted contact disappears from the list.Delete from swipe buttonNotice that the action buttons are able to support any type of\nbehavior action, from push to alert. If we\nwanted to, we could have the action buttons trigger our custom actions,\nlike open-phone and open-email. Custom\ncomponents and actions can be mixed freely with the standard components\nand actions that come standard with the Hyperview framework. This makes\nthe extensions to the Hyperview client feel like first-class\nfeatures.In fact, we’ll let you in on a secret. Within the Hyperview client,\nstandard components and actions are implemented the same way as custom\ncomponents and actions! The rendering code does not treat\n\u003cview\u003e differently from\n\u003cswipe:row\u003e. The behavior code does not treat\nalert differently from open-phone. They are\nboth implemented using the same techniques described in this section.\nStandard components and actions are just the ones that are universally\nneeded by all mobile apps. But they are just the starting point.Most mobile apps will require some extensions to the Hyperview client\nto deliver a great user experience. Extensions evolve the client from\nbeing a generic “Hyperview client,” to being a purpose-built client for\nyour app. And importantly, this evolution preserves the Hypermedia,\nserver-driven architecture and all of its benefits.That concludes our build of mobile Contact.app. Step back from the\ncode details and consider the broader pattern:The core logic of the app resides on the server.Server-rendered templates power both the web and mobile\napps.Platform customizations are done through scripting on the web,\nand client customization on mobile.The Hypermedia-Driven Application architecture allowed for\nsignificant code reuse and a manageable tech stack. Ongoing app updates\nand maintenance for both web and mobile can be done at the same\ntime.Yes, there is a story for Hypermedia-Driven Applications on\nmobile.A problem many SPA and native mobile developers face when coming to\nthe HDA approach is that they look at their current application and\nimagine implementing it exactly using hypermedia. While htmx and\nHyperview significantly improve the user experience available via the\nhypermedia-driven approach, there are still times when it won’t be easy\nto pull of a particular user experience.As we saw in Chapter Two, Roy Fielding noted this tradeoff with\nrespect to the web’s RESTful network architecture, where “information is\ntransferred in a standardized form rather than one which is specific to\nan application’s needs.”Accepting a slightly less efficient and interactive solution to a\nparticular UX can save you a tremendous amount of complexity when\nbuilding your applications.Do not let the perfect be the enemy of the good. Many advantages are\nto be gained by accepting a slightly less sophisticated user experience\nin some cases, and tools like htmx and Hyperview make that compromise\nmuch more palatable when they are used properly."
 },
 {
 "chapter": "JSON Data APIs",
 "content": "So far we have been focusing on using hypermedia to build\nHypermedia-Driven Applications. In doing so we are following and taking\nadvantage of the native network architecture of the web, and building a\nRESTful system, in the original sense of that term.However, today, we should acknowledge that many web applications are\noften not built using this approach. Instead, they use a Single\nPage Application front end library such as React to build their\napplication, and they interact with the server via a JSON API. This JSON\nAPI almost never uses hypermedia concepts. Rather JSON APIs tend to be\nData APIs, that is, an API that simply returns structured\ndomain data to the client without any hypermedia control information.\nThe client itself must know how to interpret the JSON Data: what end\npoints are associated with the data, how certain fields should be\ninterpreted, and so on.Now, believe it or not, we have been creating an API for\nContact.app.This may sound confusing to you: an API? We have just been creating a\nweb application, with handlers that just return HTML.How is that an API?It turns out that Contact.app is, indeed, providing an API. It just\nhappens to be a hypermedia API that a hypermedia\nclient, that is, a browser, understands. We are building an API for\nthe browser to interact with over HTTP, and, thanks to the magic of HTML\nand hypermedia, the browser doesn’t need to know anything about our\nhypermedia API beyond an entry point URL: all the actions and display\ninformation comes, self-contained, within the HTML responses.Building RESTful web applications like this is so natural and simple\nthat you might not think of it as an API at all, but we assure you, it\nis.So, we have a hypermedia API for Contact.app. Should we include a\nData API for Contact.app as well?Sure! The existence of a hypermedia API in no way means that\nyou can’t also have a Data API. In fact, this is a common\nsituation in traditional web applications: there is the “web\napplication” that is entered through that entry point URL, say\nhttps://mywebapp.example.com/. And there is also a\nseparate JSON API that is accessible through another URL,\nperhaps https://api.mywebapp.example.com/v1.This is a perfectly reasonable way to split up the hypermedia\ninterface to your application and the Data API you provide to other,\nnon-hypermedia clients.Why would you want to include a Data API along with a hypermedia API?\nWell, because non-hypermedia clients might also want to\ninteract with your application as well.For example:Perhaps you have a mobile application that isn’t built using\nHyperview. That application will need to interact with your server\nsomehow, and using the existing HTML API would almost certainly be a\npoor fit! You want programmatic access to your system via a Data API,\nand JSON is a natural choice for this.Perhaps you have an automated script that needs to interact with\nthe system on a regular basis. For example, maybe we have a bulk-import\njob that runs nightly, and needs to import/sync thousands of contacts.\nWhile it would be possible to script this against the HTML API, it would\nalso be annoying: parsing HTML in scripts is error prone and tedious. It\nwould be better to have a simple JSON API for this use case.Perhaps there are 3rd party clients who wish to integrate with\nyour system’s data in some way. Maybe a partner wants to synchronize\ndata nightly. As with the bulk-import example, this isn’t a great use\ncase for an HTML-based API, and it would make more sense to provide\nsomething more amenable to scripting.For all of these use cases, a JSON Data API makes sense: in each case\nthe API is not being consumed by a hypermedia client, so presenting an\nHTML-based hypermedia API would be inefficient and complicated for the\nclient to deal with. A simple JSON Data API fits the bill for what we\nwant and, as always, we recommend using the right tool for the job.“What!?! You Want Me To Parse HTML!?!”A confusion we often run into in online discussions when we advocate\na hypermedia approach to building web applications is that people think\nwe mean that they should parse the HTML responses from the server, and\nthen dump the data into their SPA framework or mobile applications.This is, of course, silly.What we mean, instead, is that you should consider using a hypermedia\nAPI with a hypermedia client, like the browser, interpreting\nthe hypermedia response itself and presenting it to the user. A\nhypermedia API can’t simply be welded on top of an existing SPA\napproach. It requires a sophisticated hypermedia client such as the\nbrowser to be consumed effectively.If you are writing code to tease apart your hypermedia only to then\ntreat as data to feed into a client-side model, you are probably doing\nit wrong.Let’s accept for a moment that we are going to have a Data\nAPI for our application, in addition to our hypermedia API. At this\npoint, some developers may be wondering: why have both? Why not have a\nsingle API, the JSON Data API, and have multiple clients use this one\nAPI to communicate with it?Isn’t it redundant to have both types of APIs for our\napplication?This is a reasonable point: we do advocate having multiple APIs to\nyour web application if necessary and, yes, this may lead to some\nredundancy in code. However, there are distinct advantages to both sorts\nof APIs and, even more so, distinct requirements for both sorts of\nAPIs.By supporting both of these types of APIs separately you can get the\nstrengths of both, while keeping their varying styles of code and\ninfrastructure needs cleanly split out.Let’s contrast the needs of JSON APIs with Hypermedia APIs:JSON API NeedsHypermedia APIIt must remain stable over time: you cannot change the API\nwilly-nilly or you risk breaking clients that use the API and expect\ncertain end points to behave in certain ways.There is no need to remain stable over time: all URLs are\ndiscovered via HTML responses, so you can be much more aggressive in\nchanging the shape of a hypermedia API.It must be versioned: related to the first point, when you do\nmake a major change, you need to version the API so that clients that\nare using the old API continue to work.Versioning is not an issue, another strength of the hypermedia\napproach.It should be rate limited: since data APIs are often used by\nother clients, not just your own internal web application, requests\nshould be rate limited, often by user, in order to avoid a single client\noverloading the system.Rate limiting probably isn’t as important beyond the prevention\nof Distributed Denial of Service (DDoS) attacks.It should be a general API: since the API is for all\nclients, not just for your web application, you should avoid specialized\nend points that are driven by your own application needs. Instead, the\nAPI should be general and expressive enough to satisfy as many potential\nclient needs as possible.The API can be very specific to your application needs:\nsince it is designed only for your particular web application, and since\nthe API is discovered through hypermedia, you can add and remove highly\ntuned end points for specific features or optimization needs in your\napplication.Authentication for these sorts of API is typically token based,\nwhich we will discuss in more detail later.Authentication is typically managed through a session cookie\nestablished by a login page.These two different types of APIs have different strengths and needs,\nso it makes sense to use both. The hypermedia approach can be used for\nyour web application, allowing you to specialize the API for the “shape”\nof your application. The Data API approach can be used for other,\nnon-hypermedia clients like mobile, integration partners, etc.Note that by splitting these two APIs apart, you reduce the pressure\nto constantly change a general Data API to address application needs.\nYour Data API can focus on remaining stable and reliable, rather than\nrequiring a new version with every added feature.This is the key advantage of splitting your Data API from your\nHypermedia API.JSON Data APIs vs JSON “REST” APIsUnfortunately, today, for historical reasons, what we are calling\nJSON Data APIs are often referred to as “REST APIs” in the industry.\nThis is ironic, because, by any reasonable reading of Roy Fielding’s\nwork defining what REST means, the vast majority of JSON APIs are\nnot RESTful. Not even close.I am getting frustrated by the number of people calling any\nHTTP-based interface a REST API. Today’s example is the SocialSite REST\nAPI. That is RPC. It screams RPC. There is so much coupling on display\nthat it should be given an X rating.What needs to be done to make the REST architectural style clear on\nthe notion that hypertext is a constraint? In other words, if the engine\nof application state (and hence the API) is not being driven by\nhypertext, then it cannot be RESTful and cannot be a REST API. Period.\nIs there some broken manual somewhere that needs to be fixed? Roy Fielding,\nhttps://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-drivenThe story of how “REST API” came to mean “JSON APIs” in the industry\nis a long and sordid one, and beyond the scope of this book. However, if\nyou are interested, you can refer to an essay by one of the authors of\nthis book entitled “How Did REST Come To Mean The Opposite of REST?” on\nthe htmx\nwebsite.In this book we use the term “Data API” to describe these JSON APIs,\nwhile acknowledging that many people in the industry will continue to\ncall them “REST APIs” for the foreseeable future.Alright, so how are we going to add a JSON Data API to our\napplication? One approach, popularized by the Ruby on Rails web\nframework, is to use the same URL endpoints as your hypermedia\napplication, but use the HTTP Accept header to determine if\nthe client wants a JSON representation or an HTML representation. The\nHTTP Accept header allows a client to specify what sort of\nMultipurpose Internet Mail Extensions (MIME) types, that is file types,\nit wants back from the server: JSON, HTML, text and so on.So, if the client wanted a JSON representation of all contacts, they\nmight issue a GET request that looks like this:A request for a JSON representation of all\ncontactsIf we adopted this pattern then our request handler for\n/contacts/ would need to be updated to inspect this header\nand, depending on the value, return a JSON rather than HTML\nrepresentation for the contacts. Ruby on Rails has support for this\npattern baked into the framework, making it very easy to switch on the\nrequested MIME type.Unfortunately, our experience with this pattern has not been great,\nfor reasons that should be clear given the differences we outlined\nbetween Data and hypermedia APIs: they have different needs and often\ntake on very different “shapes”, and trying to pound them into the same\nset of URLs ends up creating a lot of tension in the application\ncode.Given the different needs of the two APIs and our experience managing\nmultiple APIs like this, we think separating the two, and, therefore,\nbreaking the JSON Data API out to its own set of URLs is the right\nchoice. This will allow us to evolve the two APIs separately from one\nanother, and give us room to improve each independently, in a manner\nconsistent with their own individual strengths.Given that we are going to split our JSON Data API routes out from\nour regular hypermedia routes, where should we place them? One important\nconsideration here is that we want to make sure that we can version our\nAPI cleanly in some way, regardless of the pattern we choose.Looking around, a lot of places use a subdomain for their APIs,\nsomething like https://api.mywebapp.example.com and, in\nfact, often encode versioning in the subdomain:\nhttps://v1.api.mywebapp.example.com.While this makes sense for large companies, it seems like a bit of\noverkill for our modest little Contact.app. Rather than using\nsubdomains, which are a pain for local development, we will use\nsub-paths within the existing application:We will use /api as the root for our Data API\nfunctionalityWe will use /api/v1 as the entry point for version 1\nof our Data APIIf and when we decide to bump the API version, we can move to\n/api/v2 and so on.This approach isn’t perfect, of course, but it will work for our\nsimple application and can be adapted to a subdomain approach or various\nother methods at a later point, when our Contact.app has taken over the\ninternet and we can afford a large team of API developers. :)Let’s add our first Data API endpoint. It will handle an HTTP\nGET request to /api/v1/contacts, and return a\nJSON list of all contacts in the system. In some ways it will look quite\na bit like our initial code for the hypermedia route\n/contacts: we will load all the contacts from the contacts\ndatabase and then render some text as a response.We are also going to take advantage of a nice feature of Flask: if\nyou simply return an object from a handler, it will serialize (that is,\nconvert) that object into a JSON response. This makes it very easy to\nbuild simple JSON APIs in flask!A JSON data API to return all contactsJSON API gets its own path, starting with\n/api.Convert the contacts array into an array of simple dictionary\n(map) objects.Return a dictionary that contains a contacts\nproperty of all the contacts.This Python code might look a little foreign to you if you are not a\nPython developer, but all we are doing is converting our contacts into\nan array of simple name/value pairs and returning that array in an\nenclosing object as the contacts property. This object will\nbe serialized into a JSON response automatically by Flask.With this in place, if we make an HTTP GET request to\n/api/v1/contacts, we will see a response that looks\nsomething like this:Some sample data from our APISo, you can see, we now have a way to get a relatively simple JSON\nrepresentation of our contacts via an HTTP request. Not perfect, but\nit’s a good start. It’s certainly good enough to write some basic\nautomated scripts against. For example, you could use this Data API\nto:Move your contacts to another system on a nightly basisBack your contacts up to a local fileAutomate an email blast to your contactsHaving this small JSON Data API opens up a lot of automation\npossibilities that would be messier to achieve with our existing\nhypermedia API.Let’s move on to the next piece of functionality: the ability to add\na new contact. Once again, our code is going to look similar in some\nways to the code that we wrote for our normal web application. However,\nhere we are also going to see the JSON API and the hypermedia API for\nour web application begin to obviously diverge.In the web application, we needed a separate path,\n/contacts/new to host the HTML form for creating a new\ncontact. In the web application we made the decision to issue a\nPOST to that same path to keep things consistent.In the case of the JSON API, there is no such path needed: the JSON\nAPI “just is”: it doesn’t need to provide any hypermedia representation\nfor creating a new contact. You simply know where to issue a\nPOST to create a contact — likely through some\ndocumentation provided about the API — and that’s it.Because of that fact, we can put the “create” handler on the same\npath as the “list” handler: /api/v1/contacts, but have it\nrespond only to HTTP POST requests.The code here is relatively straightforward: populate a new contact\nwith the information from the POST request, attempt to save\nit, and — if it is not successful — show error messages. Here is the\ncode:Adding contacts with our JSON APIThis handler is on the same path as the first one for our JSON\nAPI, but handles POST requests.We create a new Contact based on values submitted with the\nrequest.We attempt to save the contact and, if successful, render it as a\nJSON object.If the save is not successful, we render an object showing the\nerrors, with a response code of 400 (Bad Request).In some ways this is similar to our contacts_new()\nhandler from our web application; we are creating the contact and\nattempting to save it. In other ways it is very different:There is no redirection happening here on a successful creation,\nbecause we are not dealing with a hypermedia client like the\nbrowser.In the case of a bad request, we simply return an error response\ncode, 400 (Bad Request). This is in contrast with the web\napplication, where we re-render the form with error messages in\nit.These sorts of differences, over time, build up and make the idea of\nkeeping your JSON and hypermedia APIs on the same set of URLs less and\nless appealing.Next, let’s make it possible for a JSON API client to download the\ndetails for a single contact. We will naturally use an HTTP\nGET for this functionality and will follow the convention\nwe established for our regular web application, and put the path at\n/api/v1/contacts/\u003ccontact id\u003e. So, for example, if\nyou want to see the details of the contact with the id 42,\nyou would issue an HTTP GET to\n/api/v1/contacts/42.This code is quite simple:Getting the details of a contact in JSONAdd a new GET route at the path we want to use for\nviewing contact detailsLook the contact up via the id passed in through the\npathConvert the contact to a dictionary, so it can be rendered as\nJSON responseNothing too complicated: we look the contact up by the ID provided in\nthe path to the controller. We then render it as JSON. You have to\nappreciate the simplicity of this code!Next, let’s add updating and deleting a contact as well.As with the create contact API endpoint, because there is no HTML UI\nto produce for them, we can reuse the\n/api/v1/contacts/\u003ccontact id\u003e path. We will use the\nPUT HTTP method for updating a contact and the\nDELETE method for deleting one.Our update code is going to look nearly identical to the create\nhandler, except that, rather than creating a new contact, we will look\nup the contact by ID and update its fields. In this sense we are just\ncombining the code of the create handler and the detail view\nhandler.Updating a contact with our JSON APIWe handle PUT requests to the URL for a given\ncontact.Look the contact up via the id passed in through the\npath.We update the contact’s data from the values included in the\nrequest.From here on the logic is identical to the\njson_contacts_create() handler.Once again, thanks to the built-in functionality in Flask, simple to\nimplement.Let’s look at deleting a contact now. This turns out to be even\nsimpler: as with the update handler we are going to look up the contact\nby id, and then, well, delete it. At that point we can return a simple\nJSON object indicating success.Deleting a contact with our JSON APIWe handle DELETE requests to the URL for a given\ncontact.Look the contact up and invoke the delete() method\non it.Return a simple JSON object indicating that the contact was\nsuccessfully deleted.And, with that, we have our simple little JSON Data API to live\nalongside our regular web application, nicely separated out from the\nmain web application, so it can evolve separately as needed.Now, we would have a lot more to do if we wanted to make this a\nproduction ready JSON API. At minimum we would need to add:Rate limiting, important for any public-facing Data API to avoid\nabusive clients.An authentication mechanism. (We don’t have one for our web\napplication either!)Support for pagination of our contact data.Several small items, such as rendering a proper\n404 (Not Found) response if someone makes a request with a\ncontact id that doesn’t exist.These topics are beyond the scope of this book, but we’d like to\nfocus on one in particular, authentication, in order to show the\ndifference between our hypermedia and JSON API. In order to secure our\napplication we need to add authentication, some mechanism for\ndetermining who a request is coming from, and also\nauthorization, determining if they have the right to perform\nthe request.We will set authorization aside for now and consider only\nauthentication.In the HTML web application world, authentication has traditionally\nbeen done via a login page that asks a user for their username (often\ntheir email) and a password. This password is then checked against a\ndatabase of (hashed) passwords to establish that the user is who they\nsay they are. If the password is correct, then a session cookie\nis established, indicating who the user is. This cookie is then sent\nwith every request that the user makes to the web application, allowing\nthe application to know which user is making a given request.HTTP CookiesHTTP Cookies are kind of a strange feature of HTTP. In some ways they\nviolate the goal of remaining stateless, a major component of the\nRESTful architecture: a server will often use a session cookie as an\nindex into state kept on the server “on the side”, such as a cache of\nthe last action performed by the user.Nonetheless, cookies have proven extremely useful and so people tend\nnot to complain about this aspect of them too much (We are not sure what\nour other options would be here!) An interesting example of pragmatism\ngone (relatively) right in web development.In comparison with the standard web application approach to\nauthentication, a JSON API will typically use some sort of token\nbased authentication: an authentication token will be established\nvia a mechanism like OAuth, and that authentication token will then be\npassed, often as an HTTP Header, with every request that a client\nmakes.At a high level this is similar to what happens in normal web\napplication authentication: a token is established somehow and then that\ntoken is part of every request. However, in practice, the mechanics tend\nto be wildly different:Cookies are part of the HTTP specification and can be easily\nset by an HTTP Server.JSON Authentication tokens, in contrast, often require elaborate\nexchange mechanics like OAuth to be established.These differing mechanics for establishing authentication are yet\nanother good reason for splitting up our JSON and hypermedia APIs.When we were building out our API, we noted that in many cases the\nJSON API didn’t require as many end points as our hypermedia API did: we\ndidn’t need a /contacts/new handler, for example, to\nprovide a hypermedia representation for creating contacts.Another aspect of our hypermedia API to consider was the performance\nimprovement we made: we pulled the total contact count out to a separate\nendpoint and implemented the “Lazy Load” pattern, to improve the\nperceived performance of our application.Now, if we had both our hypermedia and JSON API sharing the same\npaths, would we want to publish this API as a JSON endpoint as well?Maybe, but maybe not. This was a pretty specific need for our web\napplication, and, absent a request from a user of our JSON API, it\ndoesn’t make sense to include it for JSON consumers.And what if, by some miracle, the performance issues with\nContact.count() that we were addressing with the Lazy Load\npattern goes away? Well, in our Hypermedia-Driven Application we can\nsimply revert to the old code and include the count directly in the\nrequest to /contacts. We can remove the\ncontacts/count endpoint and all the logic associated with\nit. Because of the uniform interface of hypermedia, the system will\ncontinue to work just fine.But what if we had tied our JSON API and hypermedia API together, and\npublished /contacts/count as a supported end point for our\nJSON API? In that case we couldn’t simply remove the endpoint: a\n(non-hypermedia) client might be relying on it.Once again you can see the flexibility of the hypermedia approach and\nwhy separating your JSON API out from your hypermedia API lets you take\nmaximum advantage of that flexibility.One thing you may have noticed about the handlers for our JSON API is\nthat they are relatively simple and regular. Most of the hard work of\nupdating data and so forth is done within the contact model itself: the\nhandlers act as simple connectors that provide a go-between the HTTP\nrequests and the model.This is the ideal controller of the Model-View-Controller (MVC)\nparadigm that was so popular in the early web: a controller should be\n“thin”, with the model containing the majority of the logic in the\nsystem.The Model View Controller patternThe Model View Controller design pattern is a classic architectural\npattern in software development, and was a major influence in early web\ndevelopment. It is no longer emphasized as heavily, as web development\nhas split into frontend and backend camps, but most web developers are\nstill familiar with the idea.Traditionally, the MVC pattern mapped into web development like\nso:Model - A collection of “domain” classes that implement all the\nlogic and rules for the particular domain your application is designed\nfor. The model typically provides “resources” that are then presented to\nclients as HTML “representations.”View - Typically views would be some sort of client-side\ntemplating system, and would render the aforementioned HTML\nrepresentation for a given Model instance.Controller - The controller’s job is to take HTTP requests,\nconvert them into sensible requests to the Model and forward those\nrequests on to the appropriate Model objects. It then passes the HTML\nrepresentation back to the client as an HTTP response.Thin controllers make it easy to split your JSON and hypermedia APIs\nout, because all the important logic lives in the domain model that is\nshared by both. This allows you to evolve both separately, while still\nkeeping logic in sync with one another.With properly built “thin” controllers and “fat” models, keeping two\nseparate APIs both in sync and yet still evolving separately is not as\ndifficult or as crazy as it might sound.Microformats is a standard\nfor embedding machine-readable structured data in HTML. It uses classes\nto mark certain elements as containing information to be extracted, with\nconventions for extracting common properties like name, URL and photo\nwithout classes. By adding these classes into the HTML representation of\nan object, we allow the properties of the object to be recovered from\nthe HTML. For example, this simple HTML:can be parsed into this JSON-like structure by a microformats\nparser:Using a variety of properties and nested objects, we could mark up\nevery bit of information about a contact, for example, in a\nmachine-readable way.As explained in the above chapter, trying to use the same mechanism\nfor human and machine interaction is not a good idea. Your human-facing\nand machine-facing interfaces may end up being limited by each other. If\nyou want to expose domain-specific data and actions to users and\ndevelopers, a JSON API is a great option.However, microformats are way easier to adopt. A protocol or standard\nthat requires websites to implement a JSON API has a high technical\nbarrier. In comparison, any website can be augmented with microformats\nsimply by adding a few classes. Other HTML-embedded data formats like\nmicrodata, Open Graph are similarly easy to adopt. This makes\nmicroformats useful for cross-website (dare we say web-scale)\nsystems like the IndieWeb, which uses\nit pervasively."
 },
 {
 "chapter": "Tricks Of The Htmx Masters",
 "content": "In this chapter we are going to look deeper into the htmx toolkit.\nWe’ve accomplished quite a bit with what we’ve learned so far. Still,\nwhen you are developing Hypermedia-Driven Applications, there will be\ntimes when you need to reach for additional options and techniques.We will go over the more advanced attributes in htmx, as well as\nexpand on the advanced details of attributes we have already used.Additionally, we will look at functionality that htmx offers beyond\nsimple HTML attributes: how htmx extends standard HTTP request and\nresponses, how htmx works with (and produces) events, and how to\napproach situations where there isn’t a simple, single target on the\npage to be updated.Finally, we will take a look at practical considerations when doing\nhtmx development: how to debug htmx-based applications effectively,\nsecurity considerations you will need to take into account when working\nwith htmx, and how to configure the behavior of htmx.With the features and techniques in this chapter, you will be able to\npull off extremely sophisticated user interfaces using only htmx and\nperhaps a small bit of hypermedia-friendly client-side scripting.Thus far we have used about fifteen different attributes from htmx in\nour application. The most important ones have been:To specify the AJAX request an element should makeTo specify the event that triggers a requestTo specify how to swap the returned HTML content into the DOMTo specify where in the DOM to swap the returned HTML contentTwo of these attributes, hx-swap and\nhx-trigger, support a number of useful options for creating\nmore advanced Hypermedia-Driven Applications.We’ll start with the hx-swap attribute. This is often not included on\nelements that issue htmx-driven requests because its default behavior —\ninnerHTML, which swaps the inner HTML of the element —\ntends to cover most use cases.We earlier saw situations where we wanted to override the default\nbehavior and use outerHTML, for example. And, in chapter 2,\nwe discussed some other swap options beyond these two,\nbeforebegin, afterend, etc.In chapter 5, we also looked at the swap delay modifier\nfor hx-swap, which allowed us to fade some content out\nbefore it was removed from the DOM.In addition to these, hx-swap offers further control\nwith the following modifiers:Like swap, this allows you to apply a specific delay\nbetween when the content has been swapped into the DOM and when its\nattributes are “settled”, that is, updated from their old values (if\nany) to their new values. This can give you fine-grained control over\nCSS transitions.Allows you to specify an element that should be shown — that is,\nscrolled into the viewport of the browser if necessary — when a request\nis completed.Allows you to specify a scrollable element (that is, an element with\nscrollbars), that should be scrolled to the top or bottom when a request\nis completed.Allows you to specify that htmx should scroll to the focused element\nwhen a request completes. The default for this modifier is “false.”So, for example, if we had a button that issued a GET\nrequest, and we wished to scroll to the top of the body\nelement when the request completed, we would write the following\nHTML:Scrolling to the top of the pageThis tells htmx to show the top of the body after the swap\noccurs.More details and examples can be found online in the\nhx-swap documentation.Like hx-swap, hx-trigger can often be\nomitted when you are using htmx, because the default behavior is\ntypically what you want. Recall the default triggering events are\ndetermined by an element’s type:Requests on input, textarea \u0026\nselect elements are triggered by the change\nevent.Requests on form elements are triggered on the\nsubmit event.Requests on all other elements are triggered by the\nclick event.There are times, however, when you want a more elaborate trigger\nspecification. A classic example is the active search example we\nimplemented in Contact.app:The active search inputAn elaborate trigger specification.This example took advantage of two modifiers available for the\nhx-trigger attribute:Allows you to specify a delay to wait before a request is issued. If\nthe event occurs again, the first event is discarded and the timer\nresets. This allows you to “debounce” requests.Allows you to specify that a request should only be issued when the\nvalue property of the given element has changed.hx-trigger has several additional modifiers. This makes\nsense, because events are fairly complex and we want to be able to take\nadvantage of all the power they offer. We will discuss events in more\ndetail below.Here are the other modifiers available on\nhx-trigger:The given event will only trigger a request once.Allows you to throttle events, only issuing them once every certain\ninterval. This is different than delay in that the first\nevent will trigger immediately, but any following events will not\ntrigger until the throttle time period has elapsed.A CSS selector that allows you to pick another element to listen for\nevents on. We will see an example of this used later in the chapter.A CSS selector that allows you to filter events to only those that\noccur directly on a given element. In the DOM, events “bubble” to their\nancestor elements, so a click event on a button will also\ntrigger a click event on an enclosing div, all\nthe way up to the body element. Sometimes you want to\nspecify an event directly on a given element, and this attribute allows\nyou to do that.If this option is set to true, the triggering event will\nbe cancelled and not propagate to ancestor elements.This option allows you to specify how events are queued in htmx. By\ndefault, when htmx receives a triggering event, it will issue a request\nand start an event queue. If the request is still in flight when another\nevent is received, it will queue the event and, when the request\nfinishes, trigger a new request. By default, it only keeps the last\nevent it receives, but you can modify that behavior using this option:\nfor example, you can set it to none and ignore all\ntriggering events that occur during a request.The hx-trigger attribute also allows you to specify a\nfilter for events by using square brackets enclosing a\nJavaScript expression after the event name.Let’s say you have a complex situation where contacts should only be\nretrievable in certain situations. You have a JavaScript function,\ncontactRetrievalEnabled() that returns a boolean,\ntrue if contacts can be retrieved and false\notherwise. How could you use this function to place a gate on a button\nthat issues a request to /contacts?To do this using an event filter in htmx, you would write the\nfollowing HTML:The active search inputA request is issued on click only when\ncontactRetrievalEnabled() returns\ntrue.The button will not issue a request if\ncontactRetrievalEnabled() returns false, allowing you to\ndynamically control when the request will be made. There are common\nsituations that call for an event trigger, when you only want to issue a\nrequest under specific circumstances:if a certain element has focusif a given form is validif a set of inputs have specific valuesUsing event filters, you can use whatever logic you’d like to filter\nrequests by htmx.In addition to these modifiers, hx-trigger offers a few\n“synthetic” events, that is events that are not part of the regular DOM\nAPI. We have already seen load and revealed in\nour lazy loading and infinite scroll examples, but htmx also gives you\nan intersect event that triggers when an element intersects\nits a viewport.This synthetic event uses the modern Intersection Observer API, which\nyou can read more about at MDN.Intersection gives you fine-grained control over exactly when a\nrequest should be triggered. For example, you can set a threshold and\nspecify that the request be issued only when an element is 50%\nvisible.The hx-trigger attribute certainly is the most complex\nin htmx. More details and examples can be found in its documentation.Htmx offers many other less commonly used attributes for fine-tuning\nthe behavior of your Hypermedia-Driven Application.Here are some of the most useful ones:“Pushes” the request URL (or some other value) into the navigation\nbar.Preserves a bit of the DOM between requests; the original content\nwill be kept, regardless of what is returned.Synchronized requests between two or more elements.Disables htmx behavior on this element and any children. We will come\nback to this when we discuss the topic of security.Let’s take a look at hx-sync, which allows us to\nsynchronize AJAX requests between two or more elements. Consider a\nsimple case where we have two buttons that both target the same element\non the screen:Two competing buttonsThis is fine and will work, but what if a user clicks the “Get\nContacts” button and then the request takes a while to respond? And, in\nthe meantime the user clicks the “Get Settings” button? In this case we\nwould have two requests in flight at the same time.If the /settings request finished first and displayed\nthe user’s setting information, they might be very surprised if they\nbegan making changes and then, suddenly, the /contacts\nrequest finished and replaced the entire body with the contacts\ninstead!To deal with this situation, we might consider using an\nhx-indicator to alert the user that something is going on,\nmaking it less likely that they click the second button. But if we\nreally want to guarantee that there is only one request at a time issued\nbetween these two buttons, the right thing to do is to use the\nhx-sync attribute. Let’s enclose both buttons in a\ndiv and eliminate the redundant hx-target\nspecification by hoisting the attribute up to that div. We\ncan then use hx-sync on that div to coordinate requests\nbetween the two buttons.Here is our updated code:Syncing two buttonsHoist the duplicate hx-target attributes to the\nparent div.Synchronize on the parent div.By placing the hx-sync attribute on the div\nwith the value this, we are saying “Synchronize all htmx\nrequests that occur within this div element with one\nanother.” This means that if one button already has a request in flight,\nother buttons within the div will not issue requests until\nthat has finished.The hx-sync attribute supports a few different\nstrategies that allow you to, for example, replace an existing request\nin flight, or queue requests with a particular queuing strategy. You can\nfind complete documentation, as well as examples, at the htmx.org page\nfor hx-sync.As you can see, htmx offers a lot of attribute-driven functionality\nfor more advanced Hypermedia-Driven Applications. A complete reference\nfor all htmx attributes can be found on the htmx\nwebsite.Thus far we have worked with JavaScript events in htmx primarily via\nthe hx-trigger attribute. This attribute has proven to be a\npowerful mechanism for driving our application using a declarative,\nHTML-friendly syntax.However, there is much more we can do with events. Events play a\ncrucial role both in the extension of HTML as a hypermedia, and, as\nwe’ll see, in hypermedia-friendly scripting. Events are the “glue” that\nbrings the DOM, HTML, htmx and scripting together. You might think of\nthe DOM as a sophisticated “event bus” for applications.We can’t emphasize enough: to build advanced Hypermedia-Driven\nApplications, it is worth the effort to learn about events in\ndepth.In addition to making it easy to respond to events, htmx\nalso emits many useful events. You can use these events to add\nmore functionality to your application, either via htmx itself, or by\nway of scripting.Here are some of the most commonly used events triggered by htmx:Triggered when new content is loaded into the DOM by htmx.Triggered before a request is issued, allowing you to\nprogrammatically configure the request or cancel it entirely.Triggered after a request has responded.A custom event that can be sent to an htmx-powered element to abort\nan open request.Let’s look at an example of how to work with htmx-emitted events.\nWe’ll use the htmx:configRequest event to configure an HTTP\nrequest.Consider the following scenario: your server-side team has decided\nthat they want you to include a server-generated token for extra\nsecurity on every request. The token is going to be stored in\nlocalStorage in the browser, in the slot\nspecial-token.The token is being set via some JavaScript (don’t worry about the\ndetails yet) when the user first logs in:Getting The Token in JavaScriptGet the value of the token then set it into localStorageThe server-side team wants you to include this special token on every\nrequest made by htmx, as the X-SPECIAL-TOKEN header. How\ncould you achieve this? One way would be to catch the\nhtmx:configRequest event and update the\ndetail.headers object with this token from\nlocalStorage.In VanillaJS, it would look something like this, placed in a\n\u003cscript\u003e tag in the \u003chead\u003e of our\nHTML document:Adding the X-SPECIAL-TOKEN\nheaderRetrieve the value from local storage and set it into a\nheader.As you can see, we add a new value to the headers\nproperty of the event’s detail property. After the event handler\nexecutes, this headers property is read by htmx and used to\nconstruct the request headers for the AJAX request it makes.The detail property of the\nhtmx:configRequest event contains a slew of useful\nproperties that you can update to change the “shape” of the request,\nincluding:Allows you to add or remove request parametersAllows you to update the target of the requestAllows you to update HTTP “verb” of the request (e.g.\nGET)So, for example, if the server-side team decided they wanted the\ntoken included as a parameter, rather than as a request header, you\ncould update your code to look like this:Adding the token parameterRetrieve the value from local storage and set it into a\nparameter.As you can see, this gives you a lot of flexibility in updating the\nAJAX request that htmx makes.The full documentation for the htmx:configRequest event\n(and other events you might be interested in) can be found on the htmx\nwebsite.We can listen for any of the many useful events from htmx, and we can\nrespond to those events using hx-trigger. What else can we\ndo with events?It turns out that htmx itself listens for one special event,\nhtmx:abort. When htmx receives this event on an element\nthat has a request in flight, it will abort the request.Consider a situation where we have a potentially long-running request\nto /contacts, and we want to offer a way for the users to\ncancel the request. What we want is a button that issues the request,\ndriven by htmx, of course, and then another button that will send an\nhtmx:abort event to the first one.Here is what the code might look like:A button with an abortA normal htmx-driven GET request to\n/contactsJavaScript to look up the button and send it an\nhtmx:abort eventSo now, if a user clicks on the “Get Contacts” button and the request\ntakes a while, they can click on the “Cancel” button and end the\nrequest. Of course, in a more sophisticated user interface, you may want\nto disable the “Cancel” button unless an HTTP request is in flight, but\nthat would be a pain to implement in pure JavaScript.Thankfully this isn’t too bad to implement in hyperscript, so let’s\ntake a look at what that would look like:A hyperscript-Powered Button With An\nAbortNow we have a “Cancel” button that is enabled only when a request\nfrom the contacts-btn button is in flight. And we are\ntaking advantage of htmx-generated and handled events, as well as the\nevent-friendly syntax of hyperscript, to make it happen. Slick!We are going to talk more about the various ways that htmx enhances\nregular HTTP requests and responses in the next section, but, since it\ninvolves events, we are going to discuss one HTTP Response header that\nhtmx supports: HX-Trigger. We have discussed before how\nHTTP requests and responses support headers, name-value pairs\nthat contain metadata about a given request or response. We took\nadvantage of the HX-Trigger request header, which includes\nthe id of the element that triggered a given request.In addition to this request header, htmx also supports a\nresponse header also named HX-Trigger. This\nresponse header allows you to trigger an event on the element\nthat submitted an AJAX request. This turns out to be a powerful way to\ncoordinate elements in the DOM in a decoupled manner.To see how this might work, let’s consider the following situation:\nwe have a button that grabs new contacts from some remote system on the\nserver. We will ignore the details of the server-side implementation,\nbut we know that if we issue a POST to the\n/sync path, it will trigger a synchronization with the\nsystem.Now, this synchronization may or may not result in new contacts being\ncreated. In the case where new contacts are created, we want to\nrefresh our contacts table. In the case where no contacts are created,\nwe don’t want to refresh the table.To implement this we could conditionally add an\nHX-Trigger response header with the value\ncontacts-updated:Conditionally Triggering a contacts-updated\neventA call to the remote system that synchronized our contact\ndatabase with itIf any contacts were updated we conditionally trigger the\ncontacts-updated event on the clientThis value would trigger the contacts-updated event on\nthe button that made the AJAX request to /sync. We can then\ntake advantage of the from: modifier of the\nhx-trigger attribute to listen for that event. With this\npattern we can effectively trigger htmx requests from the server\nside.Here is what the client-side code might look like:The Contacts TableThe response to this request may conditionally trigger the\ncontacts-updated eventThis table listens for the event and refreshes when it\noccursThe table listens for the contacts-updated event, and it\ndoes so on the body element. It listens on the\nbody element since the event will bubble up from the\nbutton, and this allows us to not couple the button and table together:\nwe can move the button and table around as we like and, via events, the\nbehavior we want will continue to work fine. Additionally, we may want\nother elements or requests to trigger the\ncontacts-updated event, so this provides a general\nmechanism for refreshing the contacts table in our application.We have just seen an advanced feature of HTTP responses supported by\nhtmx, the HX-Trigger response header, but htmx supports\nquite a few more headers for both requests and responses. In chapter 4\nwe discussed the headers present in HTTP Requests. Here are some of the\nmore important headers you can use to change htmx behavior with HTTP\nresponses:Causes a client-side redirection to a new locationPushes a new URL into the location barRefreshes the current pageAllows you to specify a new target to swap the response content into\non the client sideYou can find a reference for all requests and response headers in the\nhtmx\ndocumentation.Even more important than response headers, in terms of information\nconveyed to the client, is the HTTP Response Code. We discussed\nHTTP Response Codes in Chapter 3. By and large htmx handles various\nresponse codes in the manner that you would expect: it swaps content for\nall 200-level response codes and does nothing for others. There are,\nhowever, two “special” 200-level response codes:204 No Content - When htmx receives this response\ncode, it will not swap any content into the DOM (even if the\nresponse has a body)286 - When htmx receives this response code to a\nrequest that is polling, it will stop the pollingYou can override the behavior of htmx with respect to response codes\nby, you guessed it, responding to an event! The\nhtmx:beforeSwap event allows you to change the behavior of\nhtmx with respect to various status codes.Let’s say that, rather than doing nothing when a 404\noccurred, you wanted to alert the user that an error had occurred. To do\nso, you want to invoke a JavaScript method,\nshowNotFoundError(). Let’s add some code to use the\nhtmx:beforeSwap event to make this happen:Showing a 404 dialogHook into the htmx:beforeSwap event.If the response code is a 404, show the user a\ndialog.You can also use the htmx:beforeSwap event to configure\nif the response should be swapped into the DOM and what element the\nresponse should target. This gives you quite a bit of flexibility in\nchoosing how you want to use HTTP Response codes in your application.\nFull documentation on the htmx:beforeSwap event can be\nfound at htmx.org.Above we saw how to use a server-triggered event, via the\nHX-Trigger HTTP response header, to update a piece of the\nDOM based on the response to another part of the DOM. This technique\naddresses the general problem that comes up in Hypermedia-Driven\nApplications: “How do I update other content?” After all, in normal HTTP\nrequests, there is only one “target”, the entire screen, and, similarly,\nin htmx-based requests, there is only one target: either the explicit or\nimplicit target of the element.If you want to update other content in htmx, you have a few\noptions:The first option, and the simplest, is to “expand the target.” That\nis, rather than simply replacing a small part of the screen, expand the\ntarget of your htmx-driven request until it is large enough to enclose\nall the elements that need to be updated on a screen. This has the\ntremendous advantage of being simple and reliable. The downside is that\nit may not provide the user experience that you want, and it may not\nplay well with a particular server-side template layout. Regardless, we\nalways recommend at least thinking about this approach first.A second option, a bit more complex, is to take advantage of “Out Of\nBand” content support in htmx. When htmx receives a response, it will\ninspect it for top-level content that includes the\nhx-swap-oob attribute. That content will be removed from\nthe response, so it will not be swapped into the DOM in the normal\nmanner. Instead, it will be swapped in for the content that it matches\nby id.Let’s look at an example. Consider the situation we had earlier,\nwhere a contacts table needs to be updated if an integration pulls down\nany new contacts. Previously we solved this by using events and a\nserver-triggered event via the HX-Trigger response\nheader.This time, we’ll use the hx-swap-oob attribute in the\nresponse to the POST to /integrations/1. The\nnew contacts table content will “piggyback” on the response.The updated contacts tableThe button still issues a POST to\n/integrations/1.The table no longer listens for an event, but it now has an\nid.Next, the response to the POST to\n/integrations/1 will include the content that needs to be\nswapped into the button, per the usual htmx mechanism. But it will also\ninclude a new, updated version of the contacts table, which will be\nmarked as hx-swap-oob=\"true\". This content will be removed\nfrom the response so that it is not inserted into the button. Instead,\nit is swapped into the DOM in place of the existing table since it has a\nmatching id.A response with out-of-band contentThis content will be placed in the button.This content will be removed from the response and swapped by\nid.Using this piggybacking technique, you can update content wherever\nneeded on a page. The hx-swap-oob attribute supports other\nadditional features, all of which are documented.Depending on how exactly your server-side templating technology\nworks, and what level of interactivity your application requires, out of\nband swapping can be a powerful mechanism for content updates.Finally, the most complex mechanism for updating content is the one\nwe saw back in the events section: using server-triggered events to\nupdate elements. This approach can be very clean, but also requires a\ndeeper conceptual knowledge of HTML and events, and a commitment to the\nevent-driven approach. While we like this style of development, it isn’t\nfor everyone. We typically recommend this pattern only if the htmx\nphilosophy of event-driven hypermedia really speaks to you.If it does speak to you, however, we say: go for it. We’ve\ncreated some very complex and flexible user interfaces using this\napproach, and we are quite fond of it.All of these approaches to the “Updating Other Content” problem will\nwork, and will often work well. However, there may come a point where it\nwould just be simpler to use a different approach for your UI, like the\nreactive one. As much as we like the hypermedia approach, the reality is\nthat there are some UX patterns that simply cannot be implemented easily\nusing it. The canonical example of this sort of pattern, which we have\nmentioned before, is something like a live online spreadsheet: it is\nsimply too complex a user interface, with too many interdependencies, to\nbe done well via exchanges of hypermedia with a server.In cases like this, and any time you feel like an htmx-based solution\nis proving to be more complex than another approach might be, we\nrecommend that you consider a different technology. Be pragmatic, and\nuse the right tool for the job. You can always use htmx for the parts of\nyour application that aren’t as complex and don’t need the full\ncomplexity of a reactive framework, and save that complexity budget for\nthe parts that do.We encourage you to learn many different web technologies, with an\neye to the strengths and weaknesses of each one. This will give you a\ndeep tool chest to reach into when problems present themselves. Our\nexperience is that, with htmx, hypermedia is a tool you can reach for\nfrequently.We are not ashamed to admit: we are big fans of events. They are the\nunderlying technology of almost any interesting user interface, and are\nparticularly useful in the DOM once they have been unlocked for general\nuse in HTML. They let you build nicely decoupled software while often\npreserving the locality of behavior we like so much.However, events are not perfect. One area where events can be\nparticularly tricky to deal with is debugging: you often want\nto know why an event isn’t happening. But where can you set a\nbreak point for something that isn’t happening? The answer, as\nof right now, is: you can’t.There are two techniques that can help in this regard, one provided\nby htmx, the other provided by Chrome, the browser by Google.The first technique, provided by htmx itself, is to call the\nhtmx.logAll() method. When you do this, htmx will log all\nthe internal events that occur as it goes about its business, loading up\ncontent, responding to events and so forth.This can be overwhelming, but with judicious filtering can help you\nzero in on a problem. Here are what (a bit of) the logs look like when\nclicking on the “docs” link on https://htmx.org, with logAll()\nenabled:Htmx logsNot exactly easy on the eyes, is it?But, if you take a deep breath and squint, you can see that it isn’t\nthat bad: a series of htmx events, some of which we have seen\nbefore (there’s htmx:configRequest!), get logged to the\nconsole, along with the element they are triggered on.After a bit of reading and filtering, you will be able to make sense\nof the event stream, and it can help you debug htmx-related issues.The preceding technique is useful if the problem is occurring\nsomewhere within htmx, but what if htmx is never getting\ntriggered at all? This comes up some times, like when, for example, you\nhave accidentally typed an event name incorrectly somewhere.In cases like this you will need recourse to a tool available in the\nbrowser itself. Fortunately, the Chrome browser by Google provides a\nvery useful function, monitorEvents(), that allows you to\nmonitor all events that are triggered on an element.This feature is available only in the console, so you can’t\nuse it in code on your page. But, if you are working with htmx in\nChrome, and are curious why an event isn’t triggering on an element, you\ncan open the developers console and type the following:Htmx logsThis will then print all the events that are triggered on\nthe element with the id some-element to the console. This\ncan be very useful for understanding exactly which events you want to\nrespond to with htmx, or troubleshooting why an expected event isn’t\noccurring.Using these two techniques will help you as you (infrequently, we\nhope) troubleshoot event-related issues when developing with htmx.In general, htmx and hypermedia tends to be more secure than\nJavaScript heavy approaches to building web applications. This is\nbecause, by moving much of the processing to the back end, the\nhypermedia approach tends not to expose as much surface area of your\nsystem to end users for manipulation and shenanigans.However, even with hypermedia, there are still situations that\nrequire care when doing development. Of particular concern are\nsituations where user-generated content is shown to other users: a\nclever user might try to insert htmx code that tricks the other users\ninto clicking on content that triggers actions they don’t want to\ntake.In general, all user-generated content should be escaped on the\nserver-side, and most server-side rendering frameworks provide\nfunctionality for handling this situation. But there is always a risk\nthat something slips through the cracks.In order to help you sleep better at night, htmx provides the\nhx-disable attribute. When this attribute is placed on an\nelement, all htmx attributes within that element will be ignored.A Content Security Policy (CSP) is a browser technology that allows\nyou to detect and prevent certain types of content injection-based\nattacks. A full discussion of CSPs is beyond the scope of this book, but\nwe refer you to the Mozilla\nDeveloper Network article on the topic for more information.A common feature to disable using a CSP is the eval()\nfeature of JavaScript, which allows you to evaluate arbitrary JavaScript\ncode from a string. This has proven to be a security issue and many\nteams have decided that it is not worth the risk to keep it enabled in\ntheir web applications.Htmx does not make heavy use of eval() and, thus, a CSP\nwith this restriction in place will be fine. The one feature that does\nrely on eval() is event filters, discussed above. If you\ndecide to disable eval() for your web application, you will\nnot be able to use the event filtering syntax.There are a large number of configuration options available for htmx.\nSome examples of things you can configure are:The default swap styleThe default swap delayThe default timeout of AJAX requestsA full list of configuration options can be found in the config\nsection of the main htmx\ndocumentation.Htmx is typically configured via a meta tag, found in\nthe header of a page. The name of the meta tag should be\nhtmx-config, and the content attribute should contain the\nconfiguration overrides, formatted as JSON. Here is an example:An htmx configuration via meta\ntagIn this case, we are overriding the default swap style from the usual\ninnerHTML to outerHTML. This might be useful\nif you find yourself using outerHTML more frequently than\ninnerHTML and want to avoid having to explicitly set that\nswap value throughout your application.Telling people to “use semantic HTML” instead of “read the spec” has\nled to a lot of people guessing at the meaning of tags — “looks pretty\nsemantic to me!” — instead of engaging with the spec.I think being asked to write meaningful HTML better lights\nthe path to realizing that it isn’t about what the text means to\nhumans—​it’s about using tags for the purpose outlined in the specs to\nmeet the needs of software like browsers, assistive technologies, and\nsearch engines. https://t-ravis.com/post/doc/semantic_the_8_letter_s-word/We recommend talking about, and writing, conformant HTML.\n(We can always bikeshed further). Use the elements to the full extent\nprovided by the HTML specification, and let the software take from it\nwhatever meaning they can."
 },
 {
 "chapter": "Client Side Scripting",
 "content": "REST allows client functionality to be extended by downloading and\nexecuting code in the form of applets or scripts. This simplifies\nclients by reducing the number of features required to be\npre-implemented. Roy Fielding, Architectural Styles and the Design of Network-based\nSoftware ArchitecturesThus far we have (mostly) avoided writing any JavaScript (or\n_hyperscript) in Contact.app, mainly because the functionality we\nimplemented has not required it. In this chapter we are going to look at\nscripting and, in particular, hypermedia-friendly scripting within the\ncontext of a Hypermedia-Driven Application.A common criticism of the web is that it’s being misused. There is a\nnarrative that WWW was created as a delivery system for “documents”, and\nonly came to be used for “applications” by way of an accident or bizarre\ncircumstances.However, the concept of hypermedia challenges the split of document\nand application. Hypermedia systems like HyperCard, which preceded the\nweb, featured rich capabilities for active and interactive experiences,\nincluding scripting.HTML, as specified and implemented, does lack affordances needed to\nbuild highly interactive applications. This doesn’t mean, however, that\nhypermedia’s purpose is “documents” over “applications.”Rather, while the theoretical foundation is there, the implementation\nis underdeveloped. With JavaScript being the only extension point and\nhypermedia controls not being well integrated to JavaScript (why can’t\none click a link without halting the program?), developers have not\ninternalized hypermedia and have instead used the web as a dumb pipe for\napps that imitate “native” ones.A goal of this book is to show that it is possible to build\nsophisticated web applications using the original technology of the web,\nhypermedia, without the application developer needing to reach for the\nabstractions provided by the large, popular JavaScript frameworks.Htmx itself is, of course, written in JavaScript, and one of its\nadvantages is that hypermedia interactions that go through htmx expose a\nrich interface to JavaScript code with configuration, events, and htmx’s\nown extension support.Htmx expands the expressiveness of HTML enough that it removes the\nneed for scripting in many situations. This makes htmx attractive to\npeople who don’t want to write JavaScript, and there are many of those\nsorts of developers, wary of the complexity of Single Page Application\nframeworks.However, dunking on JavaScript is not the aim of the htmx project.\nThe goal of htmx is not less JavaScript, but less code, more readable\nand hypermedia-friendly code.Scripting has been a massive force multiplier for the web. Using\nscripting, web application developers are not only able to enhance their\nHTML websites, but also create full-fledged client-side applications\nthat can often compete with native, thick client applications.This JavaScript-centric approach to building web applications is a\ntestament to the power of the web and to the sophistication of web\nbrowsers in particular. It has its place in web development: there are\nsituations where the hypermedia approach simply can’t provide the level\nof interaction that an SPA can.However, in addition to this more JavaScript-centric style, we want\nto develop a style of scripting more compatible and consistent with\nHypermedia-Driven Applications.Borrowing from Roy Fielding’s notion of “constraints” defining REST,\nwe offer two constraints of hypermedia-friendly scripting. You are\nscripting in an HDA-compatible manner if the following two constraints\nare adhered to:The main data format exchanged between server and client must be\nhypermedia, the same as it would be without scripting.Client-side state, outside the DOM itself, is kept to a\nminimum.The goal of these constraints is to confine scripting to where it\nshines best and where nothing else comes close: interaction\ndesign. Business logic and presentation logic are the\nresponsibility of the server, where we can pick whichever languages or\ntools are appropriate for our business domain.The ServerKeeping business logic and presentation logic both “on the server”\ndoes not mean these two “concerns” are mixed or coupled. They can be\nmodularized on the server. In fact, they should be modularized\non the server, along with all the other concerns of our application.Note also that, especially in web development parlance, the humble\n“server” is usually a whole fleet of racks, virtual machines, containers\nand more. Even a worldwide network of datacenters is reduced to “the\nserver” when discussing the server-side of a Hypermedia-Driven\nApplication.Satisfying these two constraints sometimes requires us to diverge\nfrom what is typically considered best practice for JavaScript. Keep in\nmind that the cultural wisdom of JavaScript was largely developed in\nJavaScript-centric SPA applications.The Hypermedia-Driven Application cannot as comfortably fall back on\nthis tradition. This chapter is our contribution to the development of a\nnew style and best practices for what we are calling Hypermedia-Driven\nApplications.Unfortunately, simply listing “best practices” is rarely convincing\nor edifying. To be honest, it’s boring.Instead, we will demonstrate these best practices by implementing\nclient-side features in Contact.app. To cover different aspects of\nhypermedia-friendly scripting, we will implement three different\nfeatures:An overflow menu to hold the Edit, View and\nDelete actions, to clean up visual clutter in our list of\ncontacts.An improved interface for bulk deletion.A keyboard shortcut for focusing the search box.The important takeaway in the implementation of each of these\nfeatures is that, while they are implemented entirely on the client-side\nusing scripting, they don’t exchange information with the\nserver via a non-hypermedia format, such as JSON, and that they\ndon’t store a significant amount of state outside of the DOM itself.The primary scripting language for the web is, of course, JavaScript,\nwhich is ubiquitous in web development today.A bit of interesting internet lore, however, is that JavaScript was\nnot always the only built-in option. As the quote from Roy Fielding at\nthe start of this chapter hints, “applets” written in other languages\nsuch as Java were considered to be part of the scripting infrastructure\nof the web. In addition, there was a time period when Internet Explorer\nsupported VBScript, a scripting language based on Visual Basic.Today, we have a variety of transcompilers (often shortened\nto transpilers) that convert many languages to JavaScript, such\nas TypeScript, Dart, Kotlin, ClojureScript, F# and more. There is also\nthe WebAssembly (WASM) bytecode format, which is supported as a\ncompilation target for C, Rust, and the WASM-first language\nAssemblyScript.However, most of these options are not geared towards a\nhypermedia-friendly style of scripting. Compile-to-JS languages are\noften paired with SPA-oriented libraries (Dart and AngularDart,\nClojureScript and Reagent, F# and Elm), and WASM is currently mainly\ngeared toward linking to C/C++ libraries from JavaScript.We will instead focus on three client-side scripting technologies\nthat are hypermedia-friendly:VanillaJS, that is, using JavaScript without depending on any\nframework.Alpine.js, a JavaScript library for adding behavior directly in\nHTML._hyperscript, a non-JavaScript scripting language created\nalongside htmx. Like AlpineJS, _hyperscript is usually embedded in\nHTML.Let’s take a quick look at each of these scripting options, so we\nknow what we are dealing with.Note that, as with CSS, we are going to show you just enough of each\nof these options to give a flavor of how they work and, we hope, spark\nyour interest in looking into any of them more extensively.No code is faster than no code. Merb (Ruby web framework), mottoVanilla JavaScript is simply using plain JavaScript in your\napplication, without any intermediate layers. The term “Vanilla” entered\nfrontend web dev parlance as it became assumed that any sufficiently\n“advanced” web app would use some library with a name ending in “.js”.\nAs JavaScript matured as a scripting language, however, standardized\nacross browsers and provided more and more functionality, these\nframeworks and libraries became less important.Somewhat ironically though, as JavaScript became more powerful and\nremoved the need for the first generation of JavaScript libraries such\nas jQuery, it also enabled people to build complex SPA libraries. These\nSPA libraries are often even more elaborate than the original first\ngeneration of JavaScript libraries.A quote from the website http://vanilla-js.com, which is well\nworth visiting even though it’s slightly out of date, captures the\nsituation well:VanillaJS is the lowest-overhead, most comprehensive framework I’ve\never used. http://vanilla-js.comWith JavaScript having matured as a scripting language, this is\ncertainly the case for many applications. It is especially true in the\ncase of HDAs, since, by using hypermedia, your application will not need\nmany of the features typically provided by more elaborate Single Page\nApplication JavaScript frameworks:Client-side routingAn abstraction over DOM manipulation (i.e., templates that\nautomatically update when referenced variables change)Server side rendering 1Attaching dynamic behavior to server-rendered tags on load (i.e.,\n“hydration”)Network requestsWithout all this complexity being handled in JavaScript, your\nframework needs are dramatically reduced.One of the best things about VanillaJS is how you install it: you\ndon’t have to!You can just start writing JavaScript in your web application, and it\nwill simply work.That’s the good news. The bad news is that, despite improvements over\nthe last decade, JavaScript has some significant limitations as a\nscripting language that can make it less than ideal as a stand-alone\nscripting technology for Hypermedia-Driven Applications:Being as established as it is, it has accreted a lot of features\nand warts.It has a complicated and confusing set of features for working\nwith asynchronous code.Working with events is surprisingly difficult.DOM APIs (a large portion of which were originally designed for\nJava, yes Java) are verbose and don’t have a habit of making\ncommon functionality easy to use.None of these limitations are deal-breakers, of course. Many of them\nare gradually being fixed and many people prefer the “close to the\nmetal” (for lack of a better term) nature of vanilla JavaScript over\nmore elaborate client-side scripting approaches.To dive into vanilla JavaScript as a front end scripting option,\nlet’s create a simple counter widget.Counter widgets are a common “Hello World” example for JavaScript\nframeworks, so looking at how it can be done in vanilla JavaScript (as\nwell as the other options we are going to look at) will be\ninstructive.Our counter widget will be very simple: it will have a number, shown\nas text, and a button that increments the number.One problem with tackling this problem in vanilla JavaScript is that\nit lacks one thing that most JavaScript frameworks provide: a default\ncode and architectural style.With vanilla JavaScript, there are no rules!This isn’t all bad. It presents a great opportunity to take a small\njourney through various styles that people have developed for writing\ntheir JavaScript.To begin, let’s start with the simplest thing imaginable: all of our\nJavaScript will be written inline, directly in the HTML. When the button\nis clicked, we will look up the output element holding the\nnumber, and increment the number contained within it.Counter in vanilla JavaScript, inline\nversionOur output element has an ID to help us find it.We use the onclick attribute to add an event\nlistener.Find the output via a querySelector() call.JavaScript allows us use the ++ operator on\nstrings.Not too bad.It’s not the most beautiful code, and can be irritating especially if\nyou aren’t used to the DOM APIs.It’s a little annoying that we needed to add an id to\nthe output element. The\ndocument.querySelector() function is a bit verbose compared\nwith, say, the $ function, as provided by jQuery.But it works. It’s also easy enough to understand, and crucially it\ndoesn’t require any other JavaScript libraries.So that’s the simple, inline approach with VanillaJS.While the inline implementation is simple in some sense, a more\nstandard way to write this would be to move the code into a separate\nJavaScript file. This JavaScript file would then either be linked to via\na \u003cscript src\u003e tag or placed into an inline\n\u003cscript\u003e tag by a build process.Here we see the HTML and JavaScript separated out from one\nanother, in different files. The HTML is now “cleaner” in that there is\nno JavaScript in it.The JavaScript is a bit more complex than in our inline version: we\nneed to look up the button using a query selector and add an event\nlistener to handle the click event and increment the counter.Counter HTMLCounter JavaScriptFind the output element.Find the button.We use addEventListener, which is preferable to\nonclick for many reasons.The logic stays the same, only the structure around it\nchanges.In moving the JavaScript out to another file, we are following a\nsoftware design principle known as Separation of Concerns\n(SoC).Separation of Concerns posits that the various “concerns” (or\naspects) of a software project should be divided up into multiple files,\nso that they don’t “pollute” one another. JavaScript isn’t markup, so it\nshouldn’t be in your HTML, it should be elsewhere. Styling\ninformation, similarly, isn’t markup, and so it belongs in a separate\nfile as well (A CSS file, for example.)For quite some time, this Separation of Concerns was considered the\n“orthodox” way to build web applications.A stated goal of Separation of Concerns is that we should be able to\nmodify and evolve each concern independently, with confidence that we\nwon’t break any of the other concerns.However, let’s look at exactly how this principle has worked out in\nour simple counter example. If you look closely at the new HTML, it\nturns out that we’ve had to add a class to the button. We added this\nclass so that we could look the button up in JavaScript and add in an\nevent handler for the “click” event.Now, in both the HTML and the JavaScript, this class name is just a\nstring and there isn’t any process to verify that the button\nhas the right classes on it or its ancestors to ensure that the event\nhandler is actually added to the right element.Unfortunately, it has turned out that the careless use of CSS\nselectors in JavaScript can cause what is known as jQuery soup.\njQuery soup is a situation where:The JavaScript that attaches a given behavior to a given element\nis difficult to find.Code reuse is difficult.The code ends up wildly disorganized and “flat”, with lots of\nunrelated event handlers mixed together.The name “jQuery soup” comes from the fact that most JavaScript-heavy\napplications used to be built in jQuery (many still are), which, perhaps\ninadvertently, tended to encourage this style of JavaScript.So, you can see that the notion of Separation of Concerns doesn’t\nalways work as well as promised: our concerns end up intertwined or\ncoupled pretty deeply, even when we separate them into different\nfiles.What concerns?To show that it isn’t just naming between concerns that can get you\ninto trouble, consider another small change to our HTML that\ndemonstrates the problems with our separation of concerns: imagine that\nwe decide to change the number field from an \u003coutput\u003e\ntag to an \u003cinput type=\"number\"\u003e.This small change to our HTML will break our JavaScript, despite the\nfact we have “separated” our concerns.The fix for this issue is simple enough (we would need to change the\n.textContent property to .value property), but\nit demonstrates the burden of synchronizing markup changes and code\nchanges across multiple files. Keeping everything in sync can become\nincreasingly difficult as your application size increases.The fact that small changes to our HTML can break our scripting\nindicates that the two are tightly coupled, despite being\nbroken up into multiple files. This tight coupling suggests that\nseparation between HTML and JavaScript (and CSS) is often an illusory\nseparation of concerns: the concerns are sufficiently related to one\nanother that they aren’t easily separated.In Contact.app we are not concerned with “structure,”\n“styling” or “behavior”; we are concerned with collecting contact info\nand presenting it to users. SoC, in the way it’s formulated in web\ndevelopment orthodoxy, is not really an inviolate architectural\nguideline, but rather a stylistic choice that, as we can see, can even\nbecome a hindrance.It turns out that there is a burgeoning reaction against the\nSeparation of Concerns design principle. Consider the following web\ntechnologies and techniques:JSXLitHTMLCSS-in-JSSingle-File ComponentsFilesystem based routingEach of these technologies colocate code in various\nlanguages that address a single feature (typically a UI\nwidget).All of them mix implementation concerns together in order to\npresent a unified abstraction to the end-user. Separating technical\ndetail concerns just isn’t as much of an, ahem, concern.Locality of Behavior (LoB) is an alternative software design\nprinciple that we coined, in opposition to Separation of Concerns. It\ndescribes the following characteristic of a piece of software:The behavior of a unit of code should be as obvious as possible by\nlooking only at that unit of code. https://htmx.org/essays/locality-of-behaviour/In simple terms: you should be able to tell what a button does by\nsimply looking at the code or markup that creates that button. This does\nnot mean you need to inline the entire implementation, but that you\nshouldn’t need to hunt for it or require prior knowledge of the codebase\nto find it.We will demonstrate Locality of Behavior in all of our examples, both\nthe counter demos and the features we add to Contact.app. Locality of\nbehavior is an explicit design goal of both _hyperscript and Alpine.js\n(which we will cover later) as well as htmx.All of these tools achieve Locality of Behavior by having you embed\nattributes directly within your HTML, as opposed to having code look up\nelements in a document through CSS selectors in order to add event\nlisteners onto them.In a Hypermedia-Driven Application, we feel that the Locality of\nBehavior design principle is often more important than the more\ntraditional Separation of Concerns design principle.So, should we go back to the onclick attribute way of\ndoing things? That approach certainly wins in Locality of Behavior, and\nhas the additional benefit that it is baked into HTML.Unfortunately, however, the on* JavaScript attributes\nalso come with some drawbacks:They don’t support custom events.There is no good mechanism for associating long-lasting variables\nwith an element — all variables are discarded when an event listener\ncompletes executing.If you have multiple instances of an element, you will need to\nrepeat the listener code on each, or use something more clever like\nevent delegation.JavaScript code that directly manipulates the DOM gets verbose,\nand clutters the markup.An element cannot listen for events on another element.Consider this common situation: you have a popup, and you want it to\nbe dismissed when a user clicks outside of it. The listener will need to\nbe on the body element in this situation, far away from the actual popup\nmarkup. This means that the body element would need to have listeners\nattached to it that deal with many unrelated components. Some of these\ncomponents may not even be on the page when it was first rendered, if\nthey are added dynamically after the initial HTML page is rendered.So vanilla JavaScript and Locality of Behavior don’t seem to mesh\nquite as well as we would like them to.The situation is not hopeless, however: it’s important to understand\nthat LoB does not require behavior to be implemented at a use\nsite, but merely invoked there. That is, we don’t need to write\nall our code on a given element, we just need to make it clear that a\ngiven element is invoking some code, which can be located\nelsewhere.Keeping this in mind, it is possible to improve LoB while\nwriting JavaScript in a separate file, provided we have a reasonable\nsystem for structuring our JavaScript.(the “Reasonable System for JavaScript Structure,” https://ricostacruz.com/rsjs/)\nis a set of guidelines for JavaScript architecture targeted at “a\ntypical non-SPA website.” RSJS provides a solution to the lack of a\nstandard code style for vanilla JavaScript that we mentioned\nearlier.Here are the RSJS guidelines most relevant for our counter\nwidget:“Use data- attributes” in HTML: invoking behavior\nvia adding data attributes makes it obvious there is JavaScript\nhappening, as opposed to using random classes or IDs that may be\nmistakenly removed or changed.“One component per file”: the name of the file should match the\ndata attribute so that it can be found easily, a win for LoB.To follow the RSJS guidelines, let’s restructure our current HTML and\nJavaScript files. First, we will use data attributes, that is,\nHTML attributes that begin with data-, a standard feature\nof HTML, to indicate that our HTML is a counter component. We will then\nupdate our JavaScript to use an attribute selector that looks for the\ndata-counter attribute as the root element in our counter\ncomponent and wires in the appropriate event handlers and logic.\nAdditionally, let’s rework the code to use\nquerySelectorAll() and add the counter functionality to\nall counter components found on the page. (You never know how\nmany counters you might want!)Here is what our code looks like now:Counter in vanilla JavaScript, with RSJSInvoke a JavaScript behavior with a data attribute.Mark relevant descendant elements.File should have the same name as the data attribute, so that we\ncan locate it easily.Get all elements that invoke this behavior.Get any child elements we need.Register event handlers.Using RSJS solves, or at least alleviates, many of the problems we\npointed out with our first, unstructured example of VanillaJS being\nsplit out to a separate file:The JS that attaches behavior to a given element is\nclear (though only through naming conventions).Reuse is easy — you can create another counter component\non the page and it will just work.The code is well-organized — one behavior per\nfile.All in all, RSJS is a good way to structure your vanilla JavaScript\nin a Hypermedia-Driven Application. So long as the JavaScript isn’t\ncommunicating with a server via a plain data JSON API, or holding a\nbunch of internal state outside of the DOM, this is perfectly compatible\nwith the HDA approach.Let’s implement a feature in Contact.app using the RSJS/vanilla\nJavaScript approach.Our homepage has “Edit”, “View” and “Delete” links for every contact\nin our table. This uses a lot of space and creates visual clutter. Let’s\nfix that by placing these actions inside a drop-down menu with a button\nto open it.If you’re less familiar with JavaScript and the code here starts to\nfeel too complicated, don’t worry; the Alpine.js and _hyperscript\nexamples — which we’ll look at next — are easier to follow.Let’s begin by sketching the markup we want for our dropdown menu.\nFirst, we need an element, we’ll use a \u003cdiv\u003e, to\nenclose the entire widget and mark it as a menu component. Within this\ndiv, we will have a standard \u003cbutton\u003e that will\nfunction as the mechanism that shows and hides our menu items. Finally,\nwe’ll have another \u003cdiv\u003e that holds the menu items\nthat we are going to show.These menu items will be simple anchor tags, as they are in the\ncurrent contacts table.Here is what our updated, RSJS-structured HTML looks like:Mark the root element of the menu componentThis button will open and close our menuA container for our menu itemsMenu itemsThe roles and ARIA attributes are based on the Menu and Menu Button\npatterns from the ARIA Authoring Practices Guide.What is ARIA?As we web developers create more interactive, app-like websites,\nHTML’s repertoire of elements won’t have all we need. As we have seen,\nusing CSS and JavaScript, we can endow existing elements with extended\nbehavior and appearances, rivaling those of native controls.However, there was one thing web apps couldn’t replicate. While these\nwidgets may look similar enough to the real deal, assistive\ntechnology (e.g., screen readers) could only deal with the underlying\nHTML elements.Even if you take the time to get all the keyboard interactions right,\nsome users often are unable to work with these custom elements\neasily.ARIA was created by W3C’s Web Accessibility Initiative (WAI) in 2008\nto address this problem. At a surface level, it is a set of attributes\nyou can add to HTML to make it meaningful to assistive software such as\na screen reader.ARIA has two main components that interact with one another:The first is the role attribute. This attribute has a\npredefined set of possible values: menu, dialog, radiogroup\netc. The role attribute does not add any behavior\nto HTML elements. Rather, it is a promise you make to the user. When you\nannotate an element as role='menu', you are saying: I\nwill make this element work like a menu.If you add a role to an element but you don’t\nuphold the promise, the experience for many users will be worse\nthan if the element had no role at all. Thus, it is\nwritten:No ARIA is better than Bad ARIA. W3C, Read Me First | APG,\nhttps://www.w3.org/WAI/ARIA/apg/practices/read-me-first/The second component of ARIA is the states and properties,\nall sharing the aria- prefix:\naria-expanded, aria-controls, aria-label etc. These\nattributes can specify various things such as the state of a widget, the\nrelationships between components, or additional semantics. Once again,\nthese attributes are promises, not implementations.Rather than learn all the roles and attributes and try to combine\nthem into a usable widget, the best course of action for most developers\nis to rely on the ARIA Authoring Practices Guide (APG), a web resource\nwith practical information aimed directly at web developers.If you’re new to ARIA, check out the following W3C resources:ARIA: Read Me First: https://www.w3.org/WAI/ARIA/apg/practices/read-me-first/ARIA UI patterns: https://www.w3.org/WAI/ARIA/apg/patterns/ARIA Good Practices: https://www.w3.org/WAI/ARIA/apg/practices/Always remember to test your website for\naccessibility to ensure all users can interact with it easily and\neffectively.On the JS side of our implementation, we’ll begin with the RSJS\nboilerplate: query for all elements with some data attribute, iterate\nover them, get any relevant descendants.Note that, below, we’ve modified the RSJS boilerplate a bit to\nintegrate with htmx; we load the overflow menu when htmx loads new\ncontent.With RSJS, you’ll be writing\ndocument.querySelectorAll(…​).forEach a lot.To keep the HTML clean, we use ARIA attributes rather than custom\ndata attributes here.Use the spread operator to convert a NodeList into a\nnormal Array.Initialize all overflow menus when the page is loaded or content\nis inserted by htmx.Conventionally, we would keep track of whether the menu is open using\na JavaScript variable or a property in a JavaScript state object. This\napproach is common in large, JavaScript-heavy web applications.However, this approach has some drawback:We would need to keep the DOM in sync with the state (harder\nwithout a framework).We would lose the ability to serialize the HTML (as this open\nstate isn’t stored in the DOM, but rather in JavaScript).Instead of taking this approach, we will use the DOM to store our\nstate. We’ll lean on the hidden attribute on the menu\nelement to tell us it’s closed. If the HTML of the page is snapshotted\nand restored, the menu can be restored as well by simply re-running the\nJS.We get the list of menu items at the start. This implementation\nwill not support dynamically adding or removing menu items.The hidden attribute is helpfully reflected as a\nhidden property, so we don’t need to use\ngetAttribute.We’ll also make the menu items non-tabbable, so we can manage their\nfocus ourselves.Now let’s implement toggling the menu in JavaScript:Optional parameter to specify desired state. This allows us to\nuse one function to open, close, or toggle the menu.Focus first item of menu when opened.Call toggleMenu with current state, to initialize\nelement attributes.Toggle menu when button is clicked.Close menu when focus moves away.Let’s also make the menu close when we click outside it, a nice\nbehavior that mimics how native drop-down menus work. This will require\nan event listener on the whole window.Note that we need to be careful with this kind of listener: you may\nfind that listeners accumulate as components add listeners and fail to\nremove them when the component is removed from the DOM. This,\nunfortunately, leads to difficult to track down memory leaks.There is not an easy way in JavaScript to execute logic when an\nelement is removed. The best option is what is known as the\nMutationObserver API. A MutationObserver is\nvery useful, but the API is quite heavy and a bit arcane, so we won’t be\nusing it for our example.Instead, we will use a simple pattern to avoid leaking event\nlisteners: when our event listener runs, we will check if the attaching\ncomponent is still in the DOM, and, if the element is no longer in the\nDOM, we will remove the listener and exit.This is a somewhat hacky, manual form of garbage collection.\nAs is (usually) the case with other garbage collection algorithms, our\nstrategy removes listeners in a nondeterministic amount of time after\nthey are no longer needed. Fortunately for us, With a frequent event\nlike “the user clicks anywhere in the page” driving the collection, it\nshould work well enough for our system.This line is the garbage collection.If the click is outside the menu, close the menu.Now, let’s move on to the keyboard interactions for our dropdown\nmenu. The keyboard handlers turn out to all be pretty similar to one\nanother and not particularly intricate, so let’s knock them all out in\none go:Helper: Get the index in the items array of the currently focused\nmenu item (0 if none).Move focus to the previous menu item when the up arrow key is\npressed.Move focus to the next menu item when the down arrow key is\npressed.Activate the currently focused element when the space key is\npressed.Move focus to the first menu item when Home is pressed.Move focus to the last menu item when End is pressed.Close menu when Escape is pressed.Return focus to menu button when closing menu.That should cover all our bases, and we’ll admit that’s a lot of\ncode. But, in fairness, it’s code that encodes a lot of behavior.Now, our drop-down menu isn’t perfect, and it doesn’t handle a lot of\nthings. For example, we don’t support submenus, or menu items being\nadded or removed dynamically to the menu. If we needed more menu\nfeatures like this, it might make more sense to use an off-the-shelf\nlibrary, such as GitHub’s details-menu-element.But, for our relatively simple use case, vanilla JavaScript does a\nfine job, and we got to explore ARIA and RSJS while implementing it.OK, so that’s an in-depth look at how to structure plain\nVanillaJS-style JavaScript. Let’s turn our attention to an actual\nJavaScript framework that enables a different approach for adding\ndynamic behavior to your application, Alpine.js.Alpine is a relatively new JavaScript library that allows developers\nto embed JavaScript code directly in HTML, akin to the on*\nattributes available in plain HTML and JavaScript. However, Alpine takes\nthis concept of embedded scripting much further than on*\nattributes.Alpine bills itself as a modern replacement for jQuery, the widely\nused, older JavaScript library. As you will see, it definitely lives up\nto this promise.Installing Alpine is very easy: it is a single file and is\ndependency-free, so you can simply include it via a CDN:Installing AlpineYou can also install it via a package manager such as NPM, or vendor\nit from your own server.Alpine provides a set of HTML attributes, all of which begin with the\nx- prefix, the main one of which is x-data.\nThe content of x-data is a JavaScript expression which\nevaluates to an object. The properties of this object can, then, be\naccessed within the element that the x-data attribute is\nlocated.To get a flavor of AlpineJS, let’s look at how to implement our\ncounter example using it.For the counter, the only state we need to keep track of is the\ncurrent number, so let’s declare a JavaScript object with one property,\ncount, in an x-data attribute on the div for\nour counter:Counter with Alpine, line 1This defines our state, that is, the data we are going to be using to\ndrive dynamic updates to the DOM. With the state declared like this, we\ncan now use it within the div element it is declared on. Let’s\nadd an output element with an x-text\nattribute.Next, we will bind the x-text attribute to the\ncount attribute we declared in the x-data\nattribute on the parent div element. This will have the\neffect of setting the text of the output element to\nwhatever the value of count is: if count is\nupdated, so will the text of the output. This is “reactive”\nprogramming, in that the DOM will “react” to changes to the backing\ndata.Counter with Alpine, lines 1-2The x-text attribute.Next, we need to update the count, using a button. Alpine allows you\nto attach event listeners with the x-on attribute.To specify the event to listen for, you add a colon and then the\nevent name after the x-on attribute name. Then, the value\nof the attribute is the JavaScript you wish to execute. This is similar\nto the plain on* attributes we discussed earlier, but it\nturns out to be much more flexible.We want to listen for a click event, and we want to\nincrement count when a click occurs, so here is what the\nAlpine code will look like:Counter with Alpine, the full thingWith x-on, we specify the event in the attribute\nname.And that’s all it takes. A simple component like a counter should be\nsimple to code, and Alpine delivers.As we said, the Alpine x-on:click attribute (or its\nshorthand, the @click attribute) is similar to the built-in\nonclick attribute. However, it has additional features that\nmake it significantly more useful:You can listen for events from other elements. For example, the\n.outside modifier lets you listen to any click event that\nis not within the element.You can use other modifiers to:throttle or debounce event listenersignore events that are bubbled up from descendant\nelementsattach passive listenersYou can listen to custom events. For example, if you wanted to\nlisten for the htmx:after-request event you could write\nx-on:htmx:after-request=\"doSomething()\".We hope you’ll agree that the AlpineJS version of the counter widget\nis better, in general, than the VanillaJS implementation, which was\neither somewhat hacky or spread out over multiple files.A big part of the power of AlpineJS is that it supports a notion of\n“reactive” variables, allowing you to bind the count of the\ndiv element to a variable that both the output\nand the button can reference, and properly updating all the\ndependencies when a mutation occurs. Alpine allows for much more\nelaborate data bindings than we have demonstrated here, and it is an\nexcellent general purpose client-side scripting library.Let’s implement a feature in Contact.app with Alpine. As it stands\ncurrently, Contact.app has a “Delete Selected Contacts” button at the\nvery bottom of the page. This button has a long name, is not easy to\nfind and takes up a lot of room. If we wanted to add additional “bulk”\nactions, this wouldn’t scale well visually.In this section, we’ll replace this single button with a toolbar.\nFurthermore, the toolbar will only appear when the user starts selecting\ncontacts. Finally, it will show how many contacts are selected and let\nyou select all contacts in one go.The first thing we will need to add is an x-data\nattribute, to hold the state that we will use to determine if the\ntoolbar is visible or not. We will need to place this on an ancestor\nelement of both the toolbar that we are going to add, as well as the\ncheckboxes, which will be updating the state when they are checked and\nunchecked. The best option given our current HTML is to place the\nattribute on the form element that surrounds the contacts\ntable. We will declare a property, selected, which will be\nan array that holds the selected contact ids, based on the checkboxes\nthat are selected.Here is what our form tag will look like:This form wraps around the contacts table.Next, at the top of the contacts table, we are going to add a\ntemplate tag. A template tag is not rendered by a\nbrowser, by default, so you might be surprised that we are using it.\nHowever, by adding an Alpine x-if attribute, we can tell\nAlpine: if a condition is true, show the HTML within this template.Recall that we want to show the toolbar if and only if one or more\ncontacts are selected. But we know that we will have the ids of the\nselected contacts in the selected property. Therefore, we\ncan check the length of that array to see if there are any\nselected contacts, quite easily:Show this HTML if there are 1 or more selected contacts.We will implement these buttons in just a moment.The next step is to ensure that toggling a checkbox for a given\ncontact adds (or removes) a given contact’s id from the\nselected property. To do this, we will need to use a new\nAlpine attribute, x-model. The x-model\nattribute allows you to bind a given element to some underlying\ndata, or its “model.”In this case, we want to bind the value of the checkbox inputs to the\nselected property. This is how we do this:The x-model attribute binds the value\nof this input to the selected propertyNow, when a checkbox is checked or unchecked, the\nselected array will be updated with the given row’s contact\nid. Furthermore, mutations we make to the selected array\nwill similarly be reflected in the checkboxes” state. This is known as a\ntwo-way binding.With this code written, we can make the toolbar appear and disappear,\nbased on whether contact checkboxes are selected.Very slick.Before we move on, you may have noticed our code here includes some\n“class=” references. These are for css styling, and are not part of\nAlpine.js. We’ve included them only as a reminder that the menu bar\nwe’re building will require css to work well. The classes in the code\nabove refer to a minimal css library called Missing.css. If you use\nother css libraries, such as Bootstrap, Tailwind, Bulma, Pico.css, etc.,\nyour styling code will be different.Now that we have the mechanics of showing and hiding the toolbar,\nlet’s look at how to implement the buttons within the toolbar.Let’s first implement the “Clear” button, because it is quite easy.\nAll we need to do is, when the button is clicked, clear out the\nselected array. Because of the two-way binding that Alpine\nprovides, this will uncheck all the selected contacts (and then hide the\ntoolbar)!For the Cancel button, our job is simple:Reset the selected array.Once again, AlpineJS makes this very easy.The “Delete” button, however, will be a bit more complicated. It will\nneed to do two things: first it will confirm if the user indeed intends\nto delete the contacts selected. Then, if the user confirms the action,\nit will use the htmx JavaScript API to issue a DELETE\nrequest.Confirm the user wishes to delete the selected number of\ncontacts.Issue a DELETE using the htmx JavaScript\nAPI.Note that we are using the short-circuiting behavior of the\n\u0026\u0026 operator in JavaScript to avoid the call to\nhtmx.ajax() if the confirm() call returns\nfalse.The htmx.ajax() function is just a way to access the\nnormal, HTML-driven hypermedia exchange that htmx’s HTML attributes give\nyou directly from JavaScript.Looking at how we call htmx.ajax, we first pass in that\nwe want to issue a DELETE to /contacts. We\nthen pass in two additional pieces of information: source\nand target. The source property is the element\nfrom which htmx will collect data to include in the request. We set this\nto $root, which is a special symbol in Alpine that will be\nthe element that has the x-data attribute declared on it.\nIn this case, it will be the form containing all of our contacts. The\ntarget, or where the response HTML will be placed, is just\nthe entire document’s body, since the DELETE handler\nreturns a whole page when it completes.Note that we are using Alpine here in a Hypermedia-Driven Application\ncompatible manner. We could have issued an AJAX request\ndirectly from Alpine and perhaps updated an x-data property\ndepending on the results of that request. But, instead, we delegated to\nhtmx’s JavaScript API, which made a hypermedia exchange with\nthe server.This is the key to scripting in a hypermedia-friendly manner within a\nHypermedia-Driven Application.So, with all of this in place, we now have a much improved experience\nfor performing bulk actions on contacts: less visual clutter and the\ntoolbar can be extended with more options without creating bloat in the\nmain interface of our app.The final scripting technology we are going to look at is a bit\nfurther afield: _hyperscript. The\nauthors of this book initially created _hyperscript as a sibling project\nto htmx. We felt that JavaScript wasn’t event-oriented enough, which\nmade adding small scripting enhancements to htmx applications\ncumbersome.While the previous two examples are JavaScript-oriented, _hyperscript\nhas a completely different syntax than JavaScript, based on an older\nlanguage called HyperTalk. HyperTalk was the scripting language for a\ntechnology called HyperCard, an old hypermedia system available on early\nMacintosh Computers.The most noticeable thing about _hyperscript is that it resembles\nEnglish prose more than it resembles other programming languages.Like Alpine, _hyperscript is a modern jQuery replacement. Also like\nAlpine, _hyperscript allows you to write your scripting inline, in\nHTML.Unlike Alpine, however, _hyperscript is not reactive. It\ninstead focuses on making DOM manipulations in response to events easy\nto write and easy to read. It has built-in language constructs for many\nDOM operations, preventing you from needing to navigate the\nsometimes-verbose JavaScript DOM APIs.We will give a small taste of what scripting in the _hyperscript\nlanguage is like, so you can pursue the language in more depth later if\nyou find it interesting.Like htmx and AlpineJS, _hyperscript can be installed via a CDN or\nfrom npm (package name hyperscript.org):Installing _hyperscript via CDN_hyperscript uses the _ (underscore) attribute for\nputting scripting on DOM elements. You may also use the\nscript or data-script attributes, depending on\nyour HTML validation needs.Let’s look at how to implement the simple counter component we have\nbeen looking at using _hyperscript. We will place an output\nelement and a button inside of a div. To\nimplement the counter, we will need to add a small bit of _hyperscript\nto the button. On a click, the button should increment the text of the\nprevious output tag.As you’ll see, that last sentence is close to the actual _hyperscript\ncode:The _hyperscript code added inline to the button.Let’s go through each component of this script:on click is an event listener, telling the button to\nlisten for a click event and then executing the remaining\ncode.increment is a “command” in _hyperscript that\n“increments” things, similar to the ++ operator in\nJavaScript.the doesn’t have any semantic meaning in\n_hyperscript, but can be used to make scripts more readable.textContent of is one form of property\naccess in _hyperscript. You are probably familiar with the\nJavaScript syntax a.b, meaning “Get the property\nb on object a. _hyperscript supports this\nsyntax, but also supports the forms b of a and\na’s b. Which one you use should depend on which one is most\nreadable.previous is an expression in _hyperscript that finds\nthe previous element in the DOM that matches some condition.\u003coutput /\u003e is a query literal, which\nis a CSS selector wrapped between \u003c and\n/\u003e.In this code, the previous keyword (and the accompanying\nnext keyword) is an example of how _hyperscript makes DOM\noperations easier: there is no such native functionality to be found in\nthe standard DOM API, and implementing this in VanillaJS is trickier\nthan you might think!So, you can see, _hyperscript is very expressive, particularly when\nit comes to DOM manipulations. This makes it easier to embed scripts\ndirectly in HTML: since the scripting language is more powerful, scripts\nwritten in it tend to be shorter and easier to read.Natural Language Programming?Seasoned programmers may be suspicious of _hyperscript: There have\nbeen many “natural language programming” (NLP) projects that target\nnon-programmers and beginner programmers, assuming that being able to\nread code in their “natural language” will give them the ability to\nwrite it as well. This has led to some badly written and structured code\nand has failed to live up to the (often over the top) hype._hyperscript is not an NLP programming language. Yes, its\nsyntax is inspired in many places by the speech patterns of web\ndevelopers. But _hyperscript’s readability is achieved not through\ncomplex heuristics or fuzzy NLP processing, but rather through judicious\nuse of common parsing tricks, coupled with a culture of readability.As you can see in the above example, with the use of a query\nreference, \u003coutput/\u003e, _hyperscript does not shy\naway from using DOM-specific, non-natural language when appropriate.While the counter demo is a good way to compare various approaches to\nscripting, the rubber meets the road when you try to actually implement\na useful feature with an approach. For _hyperscript, let’s add a\nkeyboard shortcut to Contact.app: when a user hits Alt+S in our app, we\nwill focus the search field.Since our keyboard shortcut focuses the search input, let’s put the\ncode for it on that search input, satisfying locality.Here is the original HTML for the search input:We will add an event listener using the on keydown\nsyntax, which will fire whenever a keydown occurs. Further, we can use\nan event filter syntax in _hyperscript using square brackets\nafter the event. In the square brackets we can place a filter\nexpression that will filter out keydown events we\naren’t interested in. In our case, we only want to consider events where\nthe Alt key is held down and where the “S” key is being pressed. We can\ncreate a boolean expression that inspects the altKey\nproperty (to see if it is true) and the code\nproperty (to see if it is \"KeyS\") of the event to achieve\nthis.So far our _hyperscript looks like this:A start on our keyboard shortcutNow, by default, _hyperscript will listen for a given event on\nthe element where it is declared. So, with the script we have, we\nwould only get keydown events if the search box is already\nfocused. That’s not what we want! We want to have this key work\nglobally, no matter which element has focus.Not a problem! We can listen for the keyDown event\nelsewhere by using a from clause in our event handler. In\nthis case we want to listen for the keyDown from the\nwindow, and our code ends up looking, naturally, like this:Listening globallyUsing the from clause, we can attach the listener to the\nwindow while, at the same time, keeping the code on the element it\nlogically relates to.Now that we’ve picked out the event we want to use to focus the\nsearch box, let’s implement the actual focusing by calling the standard\n.focus() method.Here is the entire script, embedded in HTML:Our final script“me” refers to the element that the script is written\non.Given all the functionality, this is surprisingly terse, and, as an\nEnglish-like programming language, pretty easy to read.This is all well and good, but you may be thinking “An entirely new\nscripting language? That seems excessive.” And, at some level, you are\nright: JavaScript is a decent scripting language, is very well optimized\nand is widely understood in web development. On the other hand, by\ncreating an entirely new front end scripting language, we had the\nfreedom to address some problems that we saw generating ugly and verbose\ncode in JavaScript:In _hyperscript, asynchronous functions (i.e., functions that return\nPromise instances) can be invoked as if they were\nsynchronous. Changing a function from sync to async does not break\nany _hyperscript code that calls it. This is achieved by checking for a\nPromise when evaluating any expression, and suspending the running\nscript if one exists (only the current event handler is suspended and\nthe main thread is not blocked). JavaScript, instead, requires either\nthe explicit use of callbacks or the use of explicit\nasync annotations (which can’t be mixed with synchronous\ncode).In _hyperscript, accessing a property on an array (other than\nlength or a number) will return an array of the values of\nproperty on each member of that array, making array property access act\nlike a flat-map operation. jQuery has a similar feature, but only for\nits own data structure.In _hyperscript, you can use things like CSS class and ID literals,\nor CSS query literals, directly in the language, rather than needing to\ncall out to a wordy DOM API, as you do in JavaScript.Working with events in _hyperscript is far more pleasant than working\nwith them in JavaScript, with native support for responding to and\nsending events, as well as for common event-handling patterns such as\n“debouncing” or rate limiting events. _hyperscript also provides\ndeclarative mechanisms for synchronizing events within a given element\nand across multiple elements.Again we wish to stress that, in this example, we are not stepping\noutside the lines of a Hypermedia-Driven Application: we are only adding\nfrontend, client-side functionality with our scripting. We are not\ncreating and managing a large amount of state outside of the DOM itself,\nor communicating with the server in a non-hypermedia exchange.Additionally, since _hyperscript embeds so well in HTML, it keeps the\nfocus on the hypermedia, rather than on the scripting\nlogic.It may not fit all scripting styles or needs, but _hyperscript can\nprovide an excellent scripting experience for Hypermedia-Driven\nApplications. It is a small and obscure programming language worth a\nlook to understand what it is trying to achieve.That concludes our look at three different options for your\nscripting infrastructure, that is, the code that you write to\nenhance your Hypermedia-Driven Application. However, there is another\nmajor area to consider when discussing client side scripting: “off the\nshelf” components. That is, JavaScript libraries that other people have\ncreated that offer some sort of functionality, such as showing modal\ndialogs.Components have become very popular in the web development world,\nwith libraries like DataTables\nproviding rich user experiences with very little JavaScript code on the\npart of a user. Unfortunately, if these libraries aren’t integrated well\ninto a website, they can begin to make an application feel “patched\ntogether.” Furthermore, some libraries go beyond simple DOM\nmanipulation, and require that you integrate with a server endpoint,\nalmost invariably with a JSON data API. This means you are no longer\nbuilding a Hypermedia-Driven Application, simply because a particular\nwidget demands something different. A shame!Web ComponentsWeb Components is the collective name of a few standards; Custom\nElements and Shadow DOM, and \u003ctemplate\u003e and\n\u003cslot\u003e.All of these standards bring useful capabilities to the table.\n\u003ctemplate\u003e elements remove their contents from the\ndocument, while still parsing them as HTML (unlike comments) and making\nthem accessible to JavaScript. Custom Elements let us initialize and\ntear down behaviors when elements are added or removed, which would\npreviously require manual work or MutationObservers. Shadow DOM lets us\nencapsulate elements, leaving the “light” (non-shadow) DOM clean.However, trying to reap these benefits is often frustrating. Some\ndifficulties are simply growing pains of new standards (like the\naccessibility problems of Shadow DOM) that are actively being worked on.\nOthers are the result of Web Components trying to be too many things at\nthe same time:An extension mechanism for HTML. To this end, each custom element\nis a tag we add to the language.A lifecycle mechanism for behaviors. Methods like\ncreatedCallback, connectedCallback, etc. allow\nbehavior to be added to elements without needing to be manually invoked\nwhen those elements are added.A unit of encapsulation. Shadow DOM insulates elements from their\nsurroundings.The result is that if you want any one of these things, the others\ncome along for the ride. If you want to attach some behaviors to some\nelements using lifecycle callbacks, you need to create a new tag, which\nmeans you can’t have multiple behaviors on one element, and you isolate\nelements you add from elements already in the page, which is a problem\nif they need to have ARIA relationships.When should we use Web Components? A good rule of thumb is to ask\nyourself: “Could this reasonably be a built-in HTML element?” For\nexample, a code editor is a good candidate, since HTML already has\n\u003ctextarea\u003e and contenteditable elements.\nIn addition, a fully-featured code editor will have many child elements\nthat won’t provide much information anyway. We can use features like Shadow\nDOM to encapsulate these elements2. We can create a custom\nelement, \u003ccode-area\u003e, that we can drop into our\npage whenever we want.The best JavaScript libraries to work with when you are building a\nHypermedia-Driven Application are ones that:Mutate the DOM but don’t communicate with a server over\nJSONRespect HTML norms (e.g., using input elements to\nstore values)Trigger many custom events as the library updates thingsThe last point, triggering many custom events (over the alternative\nof using lots of methods and callbacks) is especially important, as\nthese custom events can be dispatched or listened to without additional\nglue code written in a scripting language.Let’s take a look at two different approaches to scripting, one using\nJavaScript call backs, and one using events.To make things concrete, let’s implement a better confirmation dialog\nfor the DELETE button we created in Alpine in the previous\nsection. In the original example we used the confirm()\nfunction built in to JavaScript, which shows a pretty bare-bones system\nconfirmation dialog. We will replace this function with a popular\nJavaScript library, SweetAlert2, that shows a much nicer looking\nconfirmation dialog. Unlike the confirm() function, which\nblocks and returns a boolean (true if the user confirmed,\nfalse otherwise), SweetAlert2 returns a\nPromise object, which is a JavaScript mechanism for hooking\nin a callback once an asynchronous action (such as waiting for a user to\nconfirm or deny an action) completes.With SweetAlert2 installed as a library, you have access to the\nSwal object, which has a fire() function on it\nto trigger showing an alert. You can pass in arguments to the\nfire() method to configure exactly what the buttons on the\nconfirmation dialog look like, what the title of the dialog is, and so\nforth. We won’t get into these details too much, but you will see what a\ndialog looks like in a bit.So, given we have installed the SweetAlert2 library, we can swap it\nin place of the confirm() function call. We then need to\nrestructure the code to pass a callback to the\nthen() method on the Promise that\nSwal.fire() returns. A deep dive into Promises is beyond\nthe scope of this chapter, but suffice to say that this callback will be\ncalled when a user confirms or denies the action. If the user confirmed\nthe action, then the result.isConfirmed property will be\ntrue.Given all that, our updated code will look like this:A callback-based confirmation dialogInvoke the Swal.fire() functionConfigure the dialogHandle the result of the user’s selectionAnd now, when this button is clicked, we get a nice looking dialog in\nour web application ([fig-swal-screenshot]) — much nicer than the system\nconfirmation dialog. Still, this feels a little wrong. This is a lot of\ncode to write just to trigger a slightly nicer confirm(),\nisn’t it? And the htmx JavaScript code we are using here feels awkward.\nIt would be more natural to move the htmx out to attributes on the\nbutton, as we have been doing, and then trigger the request via\nevents.A SweetAlert dialog boxSo let’s take a different approach and see how that looks.To clean this code up, we will pull the Swal.fire() code\nout to a custom JavaScript function we will create called\nsweetConfirm(). sweetConfirm() will take the\ndialog options that are passed into the fire() method, as\nwell as the element that is confirming an action. The big difference\nhere is that the new sweetConfirm() function, rather than\ncalling some htmx directly, will instead trigger a\nconfirmed event on the button when the user confirms they\nwish to delete.Here is what our JavaScript function looks like:An event-based confirmation dialogPass the config through to the fire()\nfunction.If the user confirmed the action, trigger a\nconfirmed event.With this method available, we can now tighten up our delete button\nquite a bit. We can remove all the SweetAlert2 code that we had in the\n@click Alpine attribute, and simply call this new\nsweetConfirm() method, passing in the arguments\n$el, which is the Alpine syntax for getting “the current\nelement” that the script is on, and then the exact configuration we want\nfor our dialog.If the user confirms the action, a confirmed event will\nbe triggered on the button. This means that we can go back to using our\ntrusty htmx attributes! Namely, we can move DELETE to an\nhx-delete attribute, and we can use hx-target\nto target the body. And then, and here is the crucial step, we can use\nthe confirmed event that is triggered in the\nsweetConfirm() function, to trigger the request, but adding\nan hx-trigger for it.Here is what our code looks like:An Event-based Confirmation DialogOur htmx attributes are back.We pass the button in to the function, so an event can be\ntriggered on it.We pass through the SweetAlert2 configuration\ninformation.As you can see, this event-based code is much cleaner and certainly\nmore “HTML-ish.” The key to this cleaner implementation is that our new\nsweetConfirm() function fires an event that htmx is able to\nlisten for.This is why a rich event model is important to look for when choosing\na library to work with, both with htmx and with Hypermedia-Driven\nApplications in general.Unfortunately, due to the prevalence and dominance of the\nJavaScript-first mindset today, many libraries are like SweetAlert2:\nthey expect you to pass a callback in the first style. In these cases\nyou can use the technique we have demonstrated here, wrapping the\nlibrary in a function that triggers events in a callback, to make the\nlibrary more hypermedia and htmx-friendly.In case of conflict, consider users over authors over implementors\nover specifiers over theoretical purity. W3C, HTML Design Principles § 3.2 Priority of ConstituenciesWe have looked at several tools and techniques for scripting in a\nHypermedia-Driven Application. How should you pick between them? The sad\ntruth is that there will never be a single, always correct answer to\nthis question.Are you committed to vanilla JavaScript-only, perhaps due to company\npolicy? Well, you can use vanilla JavaScript effectively to script your\nHypermedia-Driven Application.Do you have more leeway and like the look of Alpine.js? That’s a\ngreat way to add more structured, localized JavaScript to your\napplication, and offers some nice reactive features as well.Are you a bit more bold in your technical choices? Maybe _hyperscript\nis worth a look. (We certainly think so.)Sometimes you might even consider picking two (or more) of these\napproaches within an application. Each has its own strengths and\nweaknesses, and all of them are relatively small and self-contained, so\npicking the right tool for the job at hand might be the best\napproach.In general, we encourage a pragmatic approach to scripting:\nwhatever feels right is probably right (or, at least, right\nenough) for you. Rather than being concerned about which\nparticular approach is taken for your scripting, we would focus on these\nmore general concerns:Avoid communicating with the server via JSON data APIs.Avoid storing large amounts of state outside of the DOM.Favor using events, rather than hard-coded callbacks or method\ncalls.And even on these topics, sometimes a web developer has to do what a\nweb developer has to do. If the perfect widget for your application\nexists but uses a JSON data API? That’s OK.Just don’t make it a habit.A prevalent meme among developers suggests that HTML was designed for\n“documents” and is unsuitable for “applications.” In reality, hypermedia\nis not only a sophisticated, modern architecture for applications, but\nit can allow us to do away with this artificial app/document split for\ngood.When I say Hypertext, I mean the simultaneous presentation of\ninformation and controls such that the information becomes the\naffordance through which the user obtains choices and selects\nactions. Roy Fielding, A\nlittle REST and RelaxationHTML allows documents to contain rich multimedia including images,\naudio, video, JavaScript programs, vector graphics and (with some help)\n3D environments. More importantly, however, it allows interactive\ncontrols to be embedded within these documents, allowing the information\nitself to be the app through which it is accessed.Consider: Is it not mind-boggling that a single application — which\nworks on all types of computers and OSs — can let you read news, place\nvideo calls, compose documents, enter virtual worlds, and do almost any\nother everyday computing task?Unfortunately, it is the interactive capabilities of HTML that is its\nleast developed aspect. For reasons unknown to us, while HTML made it to\nversion 5 and became a Living Standard, accreting many game-changing\nfeatures on the way, the data interactions in it are still mainly\nrestricted to links and forms. It’s up to developers to extend HTML, and\nwe want to do so in a way that doesn’t abstract over its simplicity with\nan imitation of classical “native” toolkits.Software was not supposed to use native\ntoolkitsYears of windows UI libraries yet\nno real-world use found for going lower\nlevel than the WebWanted a window anyway for a laugh? We had a tool for that: It\nwas called “Electron”“yes I would love to write 4 different copies of the same UI” - Statements\ndreamed up by the Utterly Deranged Leah Clark, @leah@tilde.zoneRendering here refers to HTML generation. Framework\nsupport for server-side rendering is not needed in a HDA because\ngenerating HTML on the server is the default.↩︎Beware that Shadow DOM is a newer web platform feature\nthat’s still in development at the time of writing. In particular, there\nare some accessibility bugs that may occur when elements inside and\noutside the shadow root interact.↩︎"
 },
 {
 "chapter": "A Dynamic Archive UI",
 "content": "Contact.app has come a long way from a traditional web 1.0-style web\napplication: we’ve added active search, bulk delete, some nice\nanimations, and a slew of other features. We have reached a level of\ninteractivity that most web developers would assume requires some sort\nof Single-Page Application JavaScript framework, but we’ve done it using\nhtmx-powered hypermedia instead.Let’s look at how we can add a final significant feature to\nContact.app: downloading an archive of all the contacts.From a hypermedia perspective, downloading a file isn’t exactly\nrocket science: using the HTTP Content-Disposition response\nheader, we can easily tell the browser to download and save a file to\nthe local computer.However, let’s make this problem more interesting: let’s add in the\nfact that the export can take a bit of time, from five to ten seconds,\nor sometimes even longer, to complete.This means that if we implemented the download as a “normal” HTTP\nrequest, driven by a link or a button, the user might sit with very\nlittle visual feedback, wondering if the download is actually happening,\nwhile the export is being completed. They might even give up in\nfrustration and click the download hypermedia control again, causing a\nsecond archive request. Not good.This turns out to be a classic problem in web app development. When\nfaced with potentially long-running process like this, we ultimately\nhave two options:When the user triggers the action, block until it is complete and\nthen respond with the result.Begin the action and return immediately, showing some sort of UI\nindicating that things are in progress.Blocking and waiting for the action to complete is certainly the\nsimpler way to handle it, but it can be a bad user experience,\nespecially if the action takes a while to complete. If you’ve ever\nclicked on something in a web 1.0-style application and then had to sit\nthere for what seems like an eternity before anything happens, you’ve\nseen the practical results of this choice.The second option, starting the action asynchronously (say, by\ncreating a thread, or submitting it to a job runner system) is much\nnicer from a user experience perspective: the server can respond\nimmediately and the user doesn’t need to sit there wondering what’s\ngoing on.But the question is, what do you respond with? The job\nprobably isn’t complete yet, so you can’t provide a link to the\nresults.We have seen a few different “simple” approaches in this scenario in\nvarious web applications:Let the user know that the process has started and that they will\nbe emailed a link to the completed process results when it is\nfinished.Let the user know that the process has started and recommend that\nthey should manually refresh the page to see the status of the\nprocess.Let the user know that the process has started and automatically\nrefresh the page every few seconds using some JavaScript.All of these will work, but none of them is a great user\nexperience.What we’d really like in this scenario is something more\nlike what you see when, for example, you download a large file via the\nbrowser: a nice progress bar indicating where in the process you are,\nand, when the process is complete, a link to click immediately to view\nthe result of the process.This may sound like something impossible to implement with\nhypermedia, and, to be honest, we’ll need to push htmx pretty hard to\nmake this all work, but, when it is done, it won’t be that much\ncode, and we will be able to achieve the user experience we want for\nthis archiving feature.Before we dive into the implementation, let’s discuss in broad terms\nwhat our new UI should look like: we want a button in the application\nlabeled “Download Contact Archive.” When a user clicks on that button,\nwe want to replace that button with a UI that shows the progress of the\narchiving process, ideally with a progress bar. As the archive job makes\nprogress, we want to move the progress bar along towards completion.\nThen, when the archive job is done, we want to show a link to the user\nto download the contact archive file.In order to actually do the archiving, we are going to use a python\nclass, Archiver, that implements all the functionality that\nwe need. As with the Contact class, we aren’t going to go\ninto the implementation details of Archiver, because that’s\nbeyond the scope of this book. For now you just need to know is that it\nprovides all the server-side behavior necessary to start a contact\narchive process and get the results when that process is done.Archiver gives us the following methods to work\nwith:status() - A string representing the status of the\ndownload, either Waiting, Running or\nCompleteprogress() - A number between 0 and 1, indicating\nhow much progress the archive job has maderun() - Starts a new archive job (if the current\nstatus is Waiting)reset() - Cancels the current archive job, if any,\nand resets to the “Waiting” statearchive_file() - The path to the archive file that\nhas been created on the server, so we can send it to the clientget() - A class method that lets us get the Archiver\nfor the current userA fairly uncomplicated API.The only somewhat tricky aspect to the whole API is that the\nrun() method is non-blocking. This means that it\ndoes not immediately create the archive file, but rather it\nstarts a background job (as a thread) to do the actual archiving. This\ncan be confusing if you aren’t used to multithreading in code: you might\nbe expecting the run() method to “block”, that is, to\nactually execute the entire export and only return when it is finished.\nBut, if it did that, we wouldn’t be able to start the archive process\nand immediately render our desired archive progress UI.We now have everything we need to begin implementing our UI: a\nreasonable outline of what it is going to look like, and the domain\nlogic to support it.So, to start, note that this UI is largely self-contained: we want to\nreplace the button with the download progress bar, and then the progress\nbar with a link to download the results of the completed archive\nprocess.The fact that our archive user interface is all going to be within a\nspecific part of the UI is a strong hint that we will want to create a\nnew template to handle it. Let’s call this template\narchive_ui.html.Also note that we are going to want to replace the entire download UI\nin multiple cases:When we start the download, we will want to replace the button\nwith a progress bar.As the archive process proceeds, we will want to replace/update\nthe progress bar.When the archive process completes, we will want to replace the\nprogress bar with a download link.To update the UI in this way, we need to set a good target for the\nupdates. So, let’s wrap the entire UI in a div tag, and\nthen use that div as the target for all our operations.Here is the start of the template for our new archive user\ninterface:Our initial archive UI templateThis div will be the target for all elements within it.Replace the entire div every time using\nouterHTML.Next, lets add the “Download Contact Archive” button to the\ndiv that will kick off the archive-then-download process.\nWe’ll use a POST to the path /contacts/archive\nto trigger the start of the archiving process:Adding the archive buttonThis button will issue a POST to\n/contacts/archive.Finally, let’s include this new template in our main\nindex.html template, above the contacts table:Our initial archive UI templateThis template will now be included in the main template.With that done, we now have a button showing up in our web\napplication to get the download going. Since the enclosing\ndiv has an hx-target=\"this\" on it, the button\nwill inherit that target and replace that enclosing div\nwith whatever HTML comes back from the POST to\n/contacts/archive.Our next step is to handle the POST that our button is\nmaking. We want to get the Archiver for the current user\nand invoke the run() method on it. This will start the\narchive process running. Then we will render some new content indicating\nthat the process is running.To do that, we want to reuse the archive_ui template to\nhandle rendering the archive UI for both states, when the archiver is\n“Waiting” and when it is “Running.” (We will handle the “Complete” state\nin a bit).This is a very common pattern: we put all the different potential UIs\nfor a given chunk of the user interface into a single template, and\nconditionally render the appropriate interface. By keeping everything in\none file, it makes it much easier for other developers (or for us, if we\ncome back after a while!) to understand exactly how the UI works on the\nclient side.Since we are going to conditionally render different user interfaces\nbased on the state of the archiver, we will need to pass the archiver\nout to the template as a parameter. So, again: we need to invoke\nrun() on the archiver in our controller and then pass the\narchiver along to the template, so it can render the UI appropriate for\nthe current status of the archive process.Here is what the code looks like:Server-side code to start the archive\nprocessHandle POST to\n/contacts/archive.Look up the Archiver.Invoke the non-blocking run() method on it.Render the archive_ui.html template, passing in the\narchiver.Now let’s turn our attention to updating our archiving UI by setting\narchive_ui.html to conditionally render different content\ndepending on the state of the archive process.Recall that the archiver has a status() method. When we\npass the archiver through as a variable to the template, we can consult\nthis status() method to see the status of the archive\nprocess.If the archiver has the status Waiting, we want to\nrender the “Download Contact Archive” button. If the status is\nRunning, we want to render a message indicating that\nprogress is happening. Let’s update our template code to do just\nthat:Adding conditional renderingOnly render the archive button if the status is\n“Waiting.”Render different content when status is “Running.”For now, just some text saying the process is running.OK, great, we have some conditional logic in our template view, and\nthe server-side logic to support kicking off the archive process. We\ndon’t have a progress bar yet, but we’ll get there! Let’s see how this\nworks as it stands, and refresh the main page of our application…​Something Went WrongOuch!We get an error message right out of the box. Why? Ah, we are\nincluding the archive_ui.html in the\nindex.html template, but now the\narchive_ui.html template expects the archiver to be passed\nthrough to it, so it can conditionally render the correct UI.That’s an easy fix: we just need to pass the archiver through when we\nrender the index.html template as well:Including the archiver when we render\nindex.htmlPass through archiver to the main templateNow with that done, we can load up the page. And, sure enough, we can\nsee the “Download Contact Archive” button.When we click on it, the button is replaced with the content\n“Running…​”, and we can see in our development console on the server-side\nthat the job is indeed getting kicked off properly.That’s definitely progress, but we don’t exactly have the best\nprogress indicator here: just some static text telling the user that the\nprocess is running.We want to make the content update as the process makes progress and,\nideally, show a progress bar indicating how far along it is. How can we\ndo that in htmx using plain old hypermedia?The technique we want to use here is called “polling”, where we issue\na request on an interval and update the UI based on the new state of the\nserver.Polling? Really?Polling has a bit of a bad rap, and it isn’t the sexiest technique in\nthe world: today developers might look at a more advanced technique like\nWebSockets or Server Sent Events (SSE) to address this situation.But, say what one will, polling works and it is drop-dead\nsimple. You need to be careful not to overwhelm your system with polling\nrequests, but, with a bit of care, you can create a reliable, passively\nupdated component in your UI using it.Htmx offers two types of polling. The first is “fixed rate polling”,\nwhich uses a special hx-trigger syntax to indicate that\nsomething should be polled on a fixed interval.Here is an example:Fixed interval pollingTrigger a GET to /messages every three\nseconds.This works great in situations when you want to poll indefinitely,\nfor example if you want to constantly poll for new messages to display\nto the user. However, fixed rate polling isn’t ideal when you have a\ndefinite process after which you want to stop polling: it keeps polling\nforever, until the element it is on is removed from the DOM.In our case, we have a definite process with an ending to it. So, it\nwill be better to use the second polling technique, known as “load\npolling.” In load polling, we take advantage of the fact that htmx\ntriggers a load event when content is loaded into the DOM.\nWe can create a trigger on this load event, and add a bit\nof a delay so that the request doesn’t trigger immediately.With this, we can conditionally render the hx-trigger on\nevery request: when a process has completed we simply do not include the\nload trigger, and the load polling stops. This offers a\nnice and simple way to poll until a definite process finishes.Let’s use load polling to update our UI as the archiver makes\nprogress. To show the progress, let’s use a CSS-based progress bar,\ntaking advantage of the progress() method which returns a\nnumber between 0 and 1 indicating how close the archive process is to\ncompletion.Here is the snippet of HTML we will use:A CSS-based progress barThe width of the inner element corresponds to the\nprogress.This CSS-based progress bar has two components: an outer\ndiv that provides the wire frame for the progress bar, and\nan inner div that is the actual progress bar indicator. We\nset the width of the inner progress bar to some percentage (note we need\nto multiply the progress() result by 100 to get a\npercentage) and that will make the progress indicator the appropriate\nwidth within the parent div.What About The \nElement?We are perhaps dipping our toes into the “div soup” here, using a\ndiv tag when there is a perfectly good HTML5 tag, the progress\nelement, that is designed specifically for showing, well, progress.We decided not to use the progress element for this\nexample because we want our progress bar to update smoothly, and we will\nneed to use a CSS technique not available for the progress\nelement to make that happen. That’s unfortunate, but sometimes we have\nto play with the cards we are dealt.We will, however, use the proper progress\nbar roles to make our div-based progress bar play well\nwith assistive technologies.Let’s update our progress bar to have the proper ARIA roles and\nvalues:A CSS-based progress barThis element will act as a progress barThe progress will be the percentage completeness of the archiver,\nwith 100 indicating fully completeFinally, for completeness, here is the CSS we’ll use for this\nprogress bar:The CSS for our progress barOur CSS-Based Progress Bar, as implemented in [lst]:progress-bar-cssLet’s add the code for our progress bar into our\narchive_ui.html template for the case when the archiver is\nrunning, and let’s update the copy to say “Creating Archive…​”:Adding the progress barOur shiny new progress barNow when we click the “Download Contact Archive” button, we get the\nprogress bar. But it still doesn’t update because we haven’t implemented\nload polling yet: it just sits there, at zero.To get the progress bar updating dynamically, we’ll need to implement\nload polling using hx-trigger. We can add this to pretty\nmuch any element inside the conditional block for when the archiver is\nrunning, so let’s add it to that div that is wrapping\naround the “Creating Archive…​” text and the progress bar.Let’s make it poll by issuing an HTTP GET to the same\npath as the POST: /contacts/archive.Implementing load pollingIssue a GET to /contacts/archive 500\nmilliseconds after the content loads.When this GET is issued to\n/contacts/archive, it is going to replace the\ndiv with the id archive-ui, not just itself.\nThe hx-target attribute on the div with the id\narchive-ui is inherited by all child elements\nwithin that div, so the children will all target that\noutermost div in the archive_ui.html file.Now we need to handle the GET to\n/contacts/archive on the server. Thankfully, this is quite\neasy: all we want to do is re-render archive_ui.html with\nthe archiver:Handling progress updateshandle GET to the /contacts/archive\npathjust re-render the archive_ui.html templateLike so much else with hypermedia, the code is very readable and not\ncomplicated.Now, when we click the “Download Contact Archive”, sure enough, we\nget a progress bar that updates every 500 milliseconds. As the result of\nthe call to archiver.progress() incrementally updates from\n0 to 1, the progress bar moves across the screen for us. Very cool!We have one final state to handle, the case when\narchiver.status() is set to “Complete”, and there is a JSON\narchive of the data ready to download. When the archiver is complete, we\ncan get the local JSON file on the server from the archiver via the\narchive_file() call.Let’s add another case to our if statement to handle the “Complete”\nstate, and, when the archive job is complete, lets render a link to a\nnew path, /contacts/archive/file, which will respond with\nthe archived JSON file. Here is the new code:Rendering A Download Link When Archiving\nCompletesIf the status is “Complete”, render a download link.The link will issue a GET to\n/contacts/archive/file.Note that the link has hx-boost set to\nfalse. It has this so that the link will not inherit the\nboost behavior that is present for other links and, thus, will not be\nissued via AJAX. We want this “normal” link behavior because an AJAX\nrequest cannot download a file directly, whereas a plain anchor tag\ncan.The final step is to handle the GET request to\n/contacts/archive/file. We want to send the file that the\narchiver created down to the client. We are in luck: Flask has a\nmechanism for sending a file as a downloaded response, the\nsend_file() method.As you see in the code that follows, we pass three arguments to\nsend_file(): the path to the archive file that the archiver\ncreated, the name of the file that we want the browser to create, and if\nwe want it sent “as an attachment.” This last argument tells Flask to\nset the HTTP response header Content-Disposition to\nattachment with the given filename; this is what triggers\nthe browser’s file-downloading behavior.Sending A File To The ClientSend the file to the client via Flask’s send_file()\nmethod.Perfect. Now we have an archive UI that is very slick. You click the\n“Download Contacts Archive” button and a progress bar appears. When the\nprogress bar reaches 100%, it disappears and a link to download the\narchive file appears. The user can then click on that link and download\ntheir archive.We’re offering a user experience that is much more user-friendly than\nthe common click-and-wait experience of many websites.As nice as this UI is, there is one minor annoyance: as the progress\nbar updates it “jumps” from one position to the next. This feels a bit\nlike a full page refresh in web 1.0 style applications. Is there a way\nwe can fix this? (Obviously there is, this why we went with a\ndiv rather than a progress element!)Let’s walk through the cause of this visual problem and how we might\nfix it. (If you’re in a hurry to get to an answer, feel free to jump\nahead to “our solution.”)It turns out that there is a native HTML technology for smoothing out\nchanges on an element from one state to another: the CSS Transitions\nAPI, the same one that we discussed in Chapter 4. Using CSS Transitions,\nyou can smoothly animate an element between different styling by using\nthe transition property.If you look back at our CSS definition of the\n.progress-bar class, you will see the following transition\ndefinition: transition: width .6s ease;. This means that\nwhen the width of the progress bar is changed from, say 20% to 30%, the\nbrowser will animate over a period of .6 seconds using the “ease”\nfunction (which has a nice accelerate/decelerate effect).So why isn’t that transition being applied in our current UI? The\nreason is that, in our example, htmx is replacing the progress\nbar with a new one every time it polls. It isn’t updating the width of\nan existing element. CSS transitions, unfortunately, only apply\nwhen the properties of an existing element change inline, not when the\nelement is replaced.This is a reason why pure HTML-based applications can feel jerky and\nunpolished when compared with their SPA counterparts: it is hard to use\nCSS transitions without some JavaScript.But there is some good news: htmx has a way to utilize CSS\ntransitions even when it replaces content in the DOM.When we discussed the htmx swap model in Chapter 4, we focused on the\nclasses that htmx adds and removes, but we skipped over the process of\n“settling.” In htmx, settling involves several steps: when htmx is about\nto replace a chunk of content, it looks through the new content and\nfinds all elements with an id on it. It then looks in the\nexisting content for elements with the same\nid.If there is one, it does the following somewhat elaborate\nshuffle:The new content gets the attributes of the old\ncontent temporarily.The new content is inserted.After a small delay, the new content has its attributes reverted\nto their actual values.So, what is this strange little dance supposed to achieve?Well, if an element has a stable id between swaps, you can now write\nCSS transitions between various states. Since the new content\nbriefly has the old attributes, the normal CSS transition\nmechanism will kick in when the actual values are restored.So, we arrive at our fix.All we need to do is add a stable ID to our progress-bar\nelement.Smoothing things outThe progress bar div now has a stable id across\nrequests.Despite the complicated mechanics going on behind the scenes in htmx,\nthe solution is as simple as adding a stable id attribute\nto the element we want to animate.Now, rather than jumping on every update, the progress bar should\nsmoothly move across the screen as it is updating, using the CSS\ntransition defined in our style sheet. The htmx swapping model allows us\nto achieve this even though we are replacing the content with new\nHTML.And voila: we have a nice, smoothly animated progress bar for our\ncontact archiving feature. The result has the look and feel of a\nJavaScript-based solution, but we did it with the simplicity of an\nHTML-based approach.Now that, dear reader, does spark joy.Some users may change their mind, and decide not to download the\narchive. They may never witness our glorious progress bar, but that’s\nOK. We’re going to give these users a button to dismiss the download\nlink and return to the original export UI state.To do this, we’ll add a button that issues a DELETE to\nthe path /contacts/archive, indicating that the current\narchive can be removed or cleaned up.We’ll add it after the download link, like so:Clearing the downloadA simple button that issues a DELETE to\n/contacts/archive.Now the user has a button that they can click on to dismiss the\narchive download link. But we will need to hook it up on the server\nside. As usual, this is pretty straightforward: we create a new handler\nfor the DELETE HTTP Action, invoke the reset()\nmethod on the archiver, and re-render the archive_ui.html\ntemplate.Since this button is picking up the same hx-target and\nhx-swap configuration as everything else, it “just\nworks.”Here is the server-side code:The handler to reset the downloadCall reset() on the archiverThis looks pretty similar to our other handlers, doesn’t it?Sure does! That’s the idea!While we prefer the current user experience for archiving contacts,\nthere are other alternatives. Currently, a progress bar shows the\nprogress of the process and, when it completes, the user is presented\nwith a link to actually download the file. Another pattern that we see\non the web is “auto-downloading”, where the file downloads immediately\nwithout the user needing to click a link.We can add this functionality quite easily to our application with\njust a bit of scripting. We will discuss scripting in a\nHypermedia-Driven Application in more depth in chapter 9, but, put\nbriefly: scripting is perfectly acceptable in a HDA, as long as it\ndoesn’t replace the core hypermedia mechanics of the application.For our auto-download feature we will use _hyperscript, our preferred scripting\noption. JavaScript would also work here, and would be nearly as simple;\nagain, we’ll discuss scripting options in detail in Chapter 9.All we need to do to implement the auto-download feature is the\nfollowing: when the download link renders, automatically click on the\nlink for the user.The _hyperscript code reads almost the same as the previous sentence\n(which is a major reason why we love hyperscript):Auto-downloadingA bit of _hyperscript to make the file auto-download.Crucially, the scripting here is simply enhancing the\nexisting hypermedia, rather than replacing it with a non-hypermedia\nrequest. This is hypermedia-friendly scripting, as we will cover in more\ndepth in a bit.In this chapter we’ve managed to create a dynamic UI for our contact\narchive functionality, with a progress bar and auto-downloading, and\nwe’ve done nearly all of it — with the exception of a small bit of\nscripting for auto-download — in pure hypermedia. It took about 16 lines\nof front end code and 16 lines of backend code to build the whole\nthing.HTML, with a bit of help from a hypermedia-oriented JavaScript\nlibrary such as htmx, can in fact be extremely powerful and\nexpressive.Markdown soup is the lesser known sibling of\n\u003cdiv\u003e soup. This is the result of web developers\nlimiting themselves to the set of elements that the Markdown language\nprovides shorthand for, even when these elements are incorrect. More\nseriously, it’s important to be aware of the full power of our tools,\nincluding HTML. Consider the following example of an IEEE-style\ncitation:The reference number is written in brackets.Underscores around the book title creates an \u003cem\u003e\nelement.Here, \u003cem\u003e is used because it’s the only Markdown element that\nis presented in italics by default. This indicates that the book title\nis being stressed, but the purpose is to mark it as the title of a work.\nHTML has the \u003ccite\u003e element that’s intended for this\nexact purpose.Furthermore, even though this is a numbered list perfect for the\n\u003col\u003e element, which Markdown supports, plain text is\nused for the reference numbers instead. Why could this be? The IEEE\ncitation style requires that these numbers are presented in square\nbrackets. This could be achieved on an \u003col\u003e with CSS,\nbut Markdown doesn’t have a way to add a class to elements meaning the\nsquare brackets would apply to all ordered lists.Don’t shy away from using embedded HTML in Markdown. For larger\nsites, also consider Markdown extensions.Many Markdown dialects let us add ids, classes and attributes\nusing curly braces.We can now use the \u003col\u003e element, and create the brackets in\nCSS.We use \u003ccite\u003e to mark the title of the work\nbeing cited (not the whole citation!)You can also use custom processors to produce extra-detailed HTML\ninstead of writing it by hand:reference_list is a macro that will transform the\nplain text to highly-detailed HTML.A processor can also resolve identifiers, so we don’t have to\nmanually keep the reference list in order and the in-text citations in\nsync."
 },
 {
 "chapter": "Hyperview: A Mobile Hypermedia",
 "content": "You may be forgiven for thinking the hypermedia architecture is\nsynonymous with the web, web browsers, and HTML. No doubt, the web is\nthe largest hypermedia system, and web browsers are the most popular\nhypermedia client. The dominance of the web in discussions about\nhypermedia make it easy to forget that hypermedia is a general concept,\nand can be applied to all types of platforms and applications. In this\nchapter, we will see the hypermedia architecture applied to a non-web\nplatform: native mobile applications.Mobile as a platform has different constraints than the web. It\nrequires different trade-offs and design decisions. Nonetheless, the\nconcepts of hypermedia, HATEOAS, and REST can be directly applied to\nbuild delightful mobile applications.In this chapter we will cover shortcomings with the current state of\nmobile app development, and how a hypermedia architecture can address\nthese problems. We will then look at a path toward hypermedia on mobile:\nHyperview, a mobile app framework that uses the hypermedia architecture.\nWe’ll conclude with an overview of HXML, the hypermedia format used by\nHyperview.Before we can discuss how to apply hypermedia to mobile platforms, we\nneed to understand how native mobile apps are commonly built. I’m using\nthe word “native” to refer to code written against an SDK provided by\nthe phone’s operating system (typically Android or iOS). This code is\npackaged into an executable binary, and uploaded \u0026 approved through\napp stores controlled by Google and Apple. When users install or update\nan app, they’re downloading this executable and running the code\ndirectly on their device’s OS. In this way, mobile apps have a lot in\ncommon with old-school desktop apps for Mac, Windows, or Linux. There is\none important difference between PC desktop apps of yesteryear and\ntoday’s mobile apps. These days, almost all mobile apps are “networked”.\nBy networked, we mean the app needs to read and write data over the\nInternet to deliver its core functionality. In other words, a networked\nmobile app needs to implement the client-server architecture.When implementing the client-server architecture, the developer needs\nto make a decision: Should the app be designed as a thin client or thick\nclient? The current mobile ecosystems strongly push developers towards a\nthick-client approach. Why? Remember, Android and iOS require that a\nnative mobile app be packaged and distributed as an executable binary.\nThere’s no way around it. Since the developer needs to write code to\npackage into an executable, it seems logical to implement some of the\napp’s logic in that code. The code may as well initiate HTTP calls to\nthe server to retrieve data, and then render that data using the\nplatform’s UI libraries. Thus, developers are naturally led into a\nthick-client pattern that looks something like this:The client contains code to make API requests to the server, and\ncode to translate those responses to UI updatesThe server implements an HTTP API that speaks JSON, and knows\nlittle about the state of the clientJust like with SPAs on the web, this architecture has a big downside:\nthe app’s logic gets spread across the client and server. Sometimes,\nthis means that logic gets duplicated (like to validate form data).\nOther times, the client and server each implement disjoint parts of the\napp’s overall logic. To understand what the app does, a developer needs\nto trace interactions between two very different codebases.There’s another downside that affects mobile apps more than SPAs: API\nchurn. Remember, the app stores control how your app gets distributed\nand updated. Users can even control if and when they get updated\nversions of your app. As a mobile developer, you can’t assume that every\nuser will be on the latest version of your app. Your frontend code gets\nfragmented across many versions, and now your backend needs to support\nall of them.We’ve seen that the hypermedia architecture can address the\nshortcomings of SPAs on the web. But can hypermedia work for mobile apps\nas well? The answer is yes!Just like on the web, we can use hypermedia formats on mobile and let\nit serve as the engine of application state. All of the logic is\ncontrolled from the backend, rather than being spread between two\ncodebases. Hypermedia architecture also solves the annoying problem of\nAPI churn on mobile apps. Since the backend serves a hypermedia response\ncontaining both data and actions, there’s no way for the data and UI to\nget out of sync. No more worries about backwards compatibility or\nmaintaining multiple API versions.So how can you use hypermedia for your mobile app? There are two\napproaches employing hypermedia to build \u0026 ship native mobile apps\ntoday:Web views, which wraps the trusty web platform in a mobile app\nshellHyperview, a new hypermedia system we designed specifically for\nmobile appsThe simplest way to use hypermedia architecture on mobile is by\nleveraging web technologies. Both Android and iOS SDKs provide “web\nviews”: chromeless web browsers that can be embedded in native apps.\nTools like Apache Cordova make it easy to take the URL of a website, and\nspit out native iOS and Android apps based on web views. If you already\nhave a responsive web app, you can get a “native” mobile HDA for free.\nSounds too good to be true, right?Of course, there is a fundamental limitation with this approach. The\nweb platform and mobile platforms have different capabilities and UX\nconventions. HTML doesn’t natively support common UI patterns of mobile\napps. One of the biggest differences is around how each platform handles\nnavigation. On the web, navigation is page-based, with one page\nreplacing another and the browser providing back/forward buttons to\nnavigate the page history. On mobile, navigation is more complex, and\ntuned for the physicality of gesture-based interactions.To drill down, screens slide on top of each other, forming stacks\nof screens.Tab bars at the top or bottom of the app allow switching between\nvarious stacks of screens.Modals slide up from the bottom of the app, covering the other\nstacks and tab bar.Unlike with web pages, all of these screens are still present in\nmemory, rendered and updating based on app state.The navigation architecture is a major difference between how mobile\nand web apps function. But it’s not the only one. Many other UX patterns\nare present in mobile apps, but are not natively supported on the\nweb:pull-to-refresh to refresh content in a screenhorizontal swipe on UI elements to reveal actionssectioned lists with sticky headersWhile these interactions are not natively supported by web browsers,\nthey can be simulated with JS libraries. Of course, these libraries will\nnever have the same feel and performance as native gestures. And using\nthem usually requires embracing a JS-heavy SPA architecture like React.\nThis puts us back at square 1! To avoid using the typical thick-client\narchitecture of native mobile apps, we turned to a web view. The web\nview allows us to use good-old hypermedia-based HTML. But to get the\ndesired look \u0026 feel of a mobile app, we end up building a SPA in JS,\nlosing the benefits of Hypermedia in the process.To build a mobile HDA that acts and feels like a native app, HTML\nisn’t going to cut it. We need a format designed to represent the\ninteractions and patterns of native mobile apps. That’s exactly what\nHyperview does.Hyperview is an open-source hypermedia system that provides:A hypermedia format for defining mobile apps called HXMLA hypermedia client for HXML that works on iOS and\nAndroidExtension points in HXML and the client to customize the\nframework for a given appHXML was designed to feel familiar to web developers, used to working\nwith HTML. Thus the choice of XML for the base format. In addition to\nfamiliar ergonomics, XML is compatible with server-side rendering\nlibraries. For example, Jinja2 is perfectly suited as a templating\nlibrary to render HXML. The familiarity of XML and the ease of\nintegration on the backend make it simple to adopt in both new and\nexisting codebases. Take a look at a “Hello World” app written in HXML.\nThe syntax should be familiar to anyone who’s worked with HTML:Hello WorldBut HXML is not just a straight port of HTML with differently named\ntags. In previous chapters, we’ve seen how htmx enhances HTML with a\nhandful of new attributes. These additions maintain the declarative\nnature of HTML, while giving developers the power to create rich web\napps. In HXML, the concepts of htmx are built into the spec.\nSpecifically, HXML is not limited to “click a link” and “submit a form”\ninteractions like basic HTML. It supports a range of triggers and\nactions for modifying the content on a screen. These interactions are\nbundled together in a powerful concept of “behaviors.” Developers can\neven define new behavior actions to add new capabilities to their app,\nwithout the need for scripting. We will learn more about behaviors later\nin this chapter.Hyperview provides an open-source HXML client library written in\nReact Native. With a little bit of configuration and a few steps on the\ncommand line, this library compiles into native app binaries for iOS or\nAndroid. Users install the app on their device via an app store. On\nlaunch, the app makes an HTTP request to the configured URL, and renders\nthe HXML response as the first screen.It may seem a little strange that developing a HDA using Hyperview\nrequires a single-purpose client binary. After all, we don’t ask users\nto first download and install a binary to view a web app. No, users just\nenter a URL in the address bar of a general-purpose web browser. A\nsingle HTML client renders apps from any HTML server ([fig-1clientmanyserver]).One HTML client, multiple HTML serversIt is theoretically possible to build an equivalent general-purpose\n“Hyperview browser.” This HXML client would render apps from any HXML\nserver, and users would enter a URL to specify the app they want to use.\nBut iOS and Android are built around the concept of single-purpose apps.\nUsers expect to find and install apps from an app store, and launch them\nfrom the home screen of their device. Hyperview embraces this\napp-centric paradigm of today’s popular mobile platforms. That means\nthat the HXML client (app binary) renders its UI from a single\npre-configured HXML server ([fig-1client1server]).One HXML client, one HXML serverLuckily, developers do not need to write a HXML client from scratch;\nthe open-source client library does 99% of the work. And as we will see\nin the next section, there are major benefits to controlling both the\nclient and server in a HDA.To understand the benefits of Hyperview’s architecture, we need to\nfirst discuss the drawbacks of the web architecture. On the web, any web\nbrowser can render HTML from any web server. This level of compatibility\ncan only happen with well-defined standards such as HTML5. But defining\nand evolving standards is a laborious process. For example, the W3C took\nover 7 years to go from first draft to recommendation on the HTML5 spec.\nIt’s not surprising, given the level of thoughtfulness that needs to go\ninto a change that impacts so many people. But it means that progress\nhappens slowly. As a web developer, you may need to wait years for\nbrowsers to gain widespread support for the feature you need.So what are the benefits of Hyperview’s architecture? In a Hyperview\napp, your mobile app only renders HXML from your\nserver. You don’t need to worry about compatibility between your server\nand other mobile apps, or between your mobile app and other servers.\nThere is no standards body to consult. If you want to add a blink\nfeature to your mobile app, go ahead and implement a\n\u003cblink\u003e element in the client, and start returning\n\u003cblink\u003e elements in the HXML responses from your\nserver. In fact, the Hyperview client library was built with this type\nof extensibility in mind. There are extension points for custom UI\nelements and custom behavior actions. We expect and encourage developers\nto use these extensions to make HXML more expressive and customized to\ntheir app’s functionality.And by extending the HXML format and client itself, there’s no need\nfor Hyperview to include a scripting layer in HXML. Features that\nrequire client-side logic get “built-in” to the client binary. HXML\nresponses remain pure, with UI and interactions represented in\ndeclarative XML.We’ve discussed two approaches for creating mobile apps using\nhypermedia systems:create a backend that returns HTML, and serve it in a mobile app\nthrough a web viewcreate a backend that returns HXML, and serve it in a mobile app\nwith the Hyperview clientI purposefully described the two approaches in a way to highlight\ntheir similarities. After all, they are both based on hypermedia\nsystems, just with different formats and clients. Both approaches solve\nthe fundamental issues with traditional, SPA-like mobile app\ndevelopment:The backend controls the full state of the app.Our app’s logic is all in one place.The app always runs the latest version, there’s no API churn to\nworry about.So which approach should you use for a mobile HDA? Based on our\nexperience building both types of apps, we believe the Hyperview\napproach results in a better user experience. The web-view will always\nfeel out-of-place on iOS and Android; there’s just no good way to\nreplicate the patterns of navigation and interaction that mobile users\nexpect. Hyperview was created specifically to address the limitations of\nthick-client and web view approaches. After the initial investment to\nlearn Hyperview, you’ll get all of the benefits of the Hypermedia\narchitecture, without the downsides of a degraded user experience.Of course, if you already have a simple, mobile-friendly web app,\nthen using a web-view approach is sensible. You will certainly save time\nfrom not having to serve your app as HXML in addition to HTML. But as we\nwill show at the end of this chapter, it doesn’t take a lot of work to\nconvert an existing Hypermedia-driven web app into a Hyperview mobile\napp. But before we get there, we need to introduce the concepts of\nelements and behaviors in Hyperview. Then, we’ll re-build our contacts\napp in Hyperview.When Shouldn’t You Use Hypermedia to Build a Mobile\nApp?Hypermedia is not always the right choice to build a mobile app. Just\nlike on the web, apps that require highly dynamic UIs (such as a\nspreadsheet application) are better implemented with client-side code.\nAdditionally, some apps need to function while fully offline. Since HDAs\nrequire a server to render UI, offline-first mobile apps are not a good\nfit for this architecture. However, just like on the web, developers can\nuse a hybrid approach to build their mobile app. The highly dynamic\nscreens can be built with complex client-side logic, while the less\ndynamic screens can be built with web views or Hyperview. In this way,\ndevelopers can spend their complexity budget on the core of the\napplication, and keep the simple screens simple.HXML was designed to feel natural to web developers coming from HTML.\nLet’s take a closer look at the “Hello World” app defined in HXML:Hello World, revisitedThe root element of the HXML appThe element representing a screen of the appThe element representing the UI of the screenThe element representing the top header of the screenA wrapper element around the content shown on the screenThe text content shown on the screenNothing too strange here, right? Just like HTML, the syntax defines a\ntree of elements using start tags (\u003cscreen\u003e) and end\ntags (\u003c/screen\u003e). Elements can contain other elements\n(\u003cview\u003e) or text (Hello World!).\nElements can also be empty, represented with an empty tag\n(\u003cstyles /\u003e). However, you’ll notice that the names\nof the HXML element are different from those in HTML. Let’s take a\ncloser look at each of those elements to understand what they do.\u003cdoc\u003e is the root of the HXML app. Think of it as\nequivalent to the \u003chtml\u003e element in HTML. Note that\nthe \u003cdoc\u003e element contains an attribute\nxmlns=\"https://hyperview.org/hyperview\". This defines the\ndefault namespace for the doc. Namespaces are a feature of XML that\nallow one doc to contain elements defined by different developers. To\nprevent conflicts when two developers use the same name for their\nelement, each developer defines a unique namespace. We will talk more\nabout namespaces when we discuss custom elements \u0026 behaviors later\nin this chapter. For now, it’s enough to know that elements in a HXML\ndoc without an explicit namespace are considered to be part of the\nhttps://hyperview.org/hyperview namespace.\u003cscreen\u003e represents the UI that gets rendered on a\nsingle screen of a mobile app. It’s possible for one\n\u003cdoc\u003e to contain multiple \u003cscreen\u003e\nelements, but we won’t get into that now. Typically, a\n\u003cscreen\u003e element will contain elements that define\nthe content and styling of the screen.\u003cstyles\u003e defines the styles of the UI on the\nscreen. We won’t get too much into styling in Hyperview in this chapter.\nSuffice it to say, unlike HTML, Hyperview does not use a separate\nlanguage (CSS) to define styles. Instead, styling rules such as colors,\nspacing, layout, and fonts are defined in HXML. These rules are then\nexplicitly referenced by UI elements, much like using classes in\nCSS.\u003cbody\u003e defines the actual UI of the screen. The\nbody includes all text, images, buttons, forms, etc that will be shown\nto the user. This is equivalent to the \u003cbody\u003e element\nin HTML.\u003cheader\u003e defines the header of the screen.\nTypically in mobile apps, the header includes some navigation (like a\nback button), and the title of the screen. It’s useful to define the\nheader separately from the rest of the body. Some mobile OSes will use a\ndifferent transition for the header than the rest of the screen\ncontent.\u003cview\u003e is the basic building block for layouts and\nstructure within the screen’s body. Think of it like a\n\u003cdiv\u003e in HTML. Note that unlike in HTML, a\n\u003cdiv\u003e cannot directly contain text.\u003ctext\u003e elements are the only way to render text in\nthe UI. In this example, “Hello World” is contained within a\n\u003ctext\u003e element.That’s all there is to define a basic “Hello World” app in HXML. Of\ncourse, this isn’t very exciting. Let’s cover some other built-in\ndisplay elements.A very common pattern in mobile apps is to scroll through a list of\nitems. The physical properties of a phone screen (long \u0026 vertical)\nand the intuitive gesture of swiping a thumb up \u0026 down makes this a\ngood choice for many screens.HXML has dedicated elements for representing lists and items.List elementElement representing a listElement representing an item in the list, with a unique\nkeyThe content of the item in the list.Lists are represented with two new elements. The\n\u003clist\u003e wraps all of the items in the list. It can be\nstyled like a generic \u003cview\u003e (width, height, etc). A\n\u003clist\u003e element only contains\n\u003citem\u003e elements. Of course, these represent each\nunique item in the list. Note that \u003citem\u003e is required\nto have a key attribute, which is unique among all items in\nthe list.You might be asking, “Why do we need a custom syntax for lists of\nitems? Can’t we just use a bunch of \u003cview\u003e\nelements?”. Yes, for lists with a small number of items, using nested\n\u003cviews\u003e will work quite well. However, often the\nnumber of items in a list can be long enough to require optimizations to\nsupport smooth scrolling interactions. Consider browsing a feed of posts\nin a social media app. As you keep scrolling through the feed, it’s not\nunusual for the app to show hundreds if not thousands of posts. At any\ntime, you can flick your finger to scroll to almost any part of the\nfeed. Mobile devices tend to be memory-constrained. Keeping the\nfully-rendered list of items in memory could consume more resources than\navailable. That’s why both iOS and Android provide APIs for optimized\nlist UIs. These APIs know which part of the list is currently on-screen.\nTo save memory, they clear out the non-visible list items, and recycle\nthe item UI objects to conserve memory. By using explicit\n\u003clist\u003e and \u003citem\u003e elements in\nHXML, the Hyperview client knows to use these optimized list APIs to\nmake your app more performant.It’s also worth mentioning that HXML supports section lists. Section\nlists are useful for building list-based UIs, where the items in the\nlist can be grouped for the user’s convenience. For example, a UI\nshowing a restaurant menu could group the offerings by dish type:Section list elementElement representing a list with sectionsThe first section of appetizer offeringsElement for the title of the section, rendering the text\n“Appetizers”An item representing an appetizerA section for entree offeringsYou’ll notice a couple of differences between\n\u003clist\u003e and \u003csection-list\u003e. The\nsection list element only contains \u003csection\u003e\nelements, representing a group of items. A section can contain a\n\u003csection-title\u003e element. This is used to render some\nUI that acts as the header of the section. This header is “sticky”,\nmeaning it stays on screen while scrolling through items that belong to\nthe corresponding section. Finally, \u003citem\u003e elements\nact the same as in the regular list, but can only appear within a\n\u003csection\u003e.Showing images in Hyperview is pretty similar to HTML, but there are\na few differences.Image elementThe source attribute specifies how to load the image.\nLike in HTML, the source can be an absolute or relative URL.\nAdditionally, the source can be an encoded data URI, for example\ndata:image/png;base64,iVBORw. However, the source can also\nbe a “local” URL, referring to an image that is bundled as an asset in\nthe mobile app. The local URL is prefixed with ./:Image element, pointing to local sourceUsing Local URLs is an optimization. Since the images are on the\nmobile device, they don’t require a network request and will appear\nquickly. However, bundling the image with the mobile app binary\nincreases the binary size. Using local images is a good trade-off for\nimages that are frequently accessed but rarely change. Good examples\ninclude the app logo, or common button icons.The other thing to note is the presence of the style\nattribute on the \u003cimage\u003e element. In HXML, images are\nrequired to have a style that has rules for the image’s\nwidth and height. This is different from HTML,\nwhere \u003cimg\u003e elements do not need to explicitly set a\nwidth and height. web browsers will re-flow the content of a web page\nonce the image is fetched and the dimensions are known. While re-flowing\ncontent is a reasonable behavior for web-based documents, users do not\nexpect mobile apps to re-flow as content loads. To maintain a static\nlayout, HXML requires the dimensions to be known before the image\nloads.There’s a lot to cover about inputs in Hyperview. Since this is meant\nto be an introduction and not an exhaustive resource, I’ll highlight\njust a few types of inputs. Let’s start with an example of the simplest\ntype of input, a text field.Text field elementThe name used when serializing data from this inputThe style class applied to the UI elementThe current value set in the fieldA placeholder to display when the value is emptyThis element should feel familiar to anyone who’s created a text\nfield in HTML. One difference is that most inputs in HTML use the\n\u003cinput\u003e element with a type attribute,\neg \u003cinput type=\"text\"\u003e. In Hyperview, each input has\na unique name, in this case \u003ctext-field\u003e. By using\ndifferent names, we can use more expressive XML to represent the\ninput.For example, let’s consider a case where we want to render a UI that\nlets the user select one among several options. In HTML, we would use a\nradio button input, something like\n\u003cinput type=\"radio\" name=\"choice\" value=\"option1\" /\u003e.\nEach choice is represented as a unique input element. This never struck\nme as ideal. Most of the time, radio buttons are grouped together to\naffect the same name. The HTML approach leads to a lot of boilerplate\n(duplication of type=\"radio\" and name=\"choice\"\nfor each choice). Also, unlike radio buttons on desktop, mobile OSes\ndon’t provide a strong standard UI for selecting one option. Most mobile\napps use richer, custom UIs for these interactions. So in HXML, we\nimplement this UI using an element called\n\u003cselect-single\u003e:Select-single elementElement representing an input where a single choice is selected.\nThe name of the selection is defined once here.Element representing one of the choices. The choice value is\ndefined here.The UI of the selection. In this example, we use text, but we can\nuse any UI elements.The \u003cselect-single\u003e element is the parent of the\ninput for selecting one choice out of many. This element contains the\nname attribute used when serializing the selected choice.\n\u003coption\u003e elements within\n\u003cselect-single\u003e represent the available choices. Note\nthat each \u003coption\u003e element has a value\nattribute. When pressed, this will be the selected value of the input.\nThe \u003coption\u003e element can contain any other UI\nelements within it. This means that we’re not hampered by rendering the\ninput as a list of radio buttons with labels. We can render the options\nas radios, tags, images, or anything else that would be intuitive for\nour interface. HXML styling supports modifiers for pressed and selected\nstates, letting us customize the UI to highlight the selected\noption.Describing all features of inputs in HXML would take an entire\nchapter. Instead, I’ll summarize a few other input elements and their\nfeatures.- \u003cselect-multiple\u003e works like\n\u003cselect-single\u003e, but it supports toggling multiple\noptions on \u0026 off. This replaces checkbox inputs in HTML. - The\n\u003cswitch\u003e element renders an on/off switch that is\ncommon in mobile UIs - The \u003cdate-field\u003e element\nsupports entering in specific dates, and comes with a wide range of\ncustomizations for formatting, settings ranges, etc.Two more things to mention about inputs. First is the\n\u003cform\u003e element. The \u003cform\u003e element\nis used to group together inputs for serialization. When a user takes an\naction that triggers a backend request, the Hyperview client will\nserialize all inputs in the surrounding \u003cform\u003e and\ninclude them in the request. This is true for both GET and\nPOST requests. We will cover this in more detail when\ntalking about behaviors later in this chapter. Also later in this\nchapter, I’ll talk about support for custom elements in HXML. With\ncustom elements, you can also create your own input elements. Custom\ninput elements allow you to build incredible powerful interactions with\nsimple XML syntax that integrates well with the rest of HXML.So far, we haven’t mentioned how to apply styling to all of the HXML\nelements. We’ve seen from the Hello World app that each\n\u003cscreen\u003e can contain a \u003cstyles\u003e\nelement. Let’s re-visit the Hello World app and fill out the\n\u003cstyles\u003e element.UI styling exampleElement encapsulating all of the styling for the screenExample of a definition of a style class for “body”Applying the “body” style class to a UI elementExample of applying multiple style classes (h1 and info) to an\nelementYou’ll note that in HXML, styling is part of the XML format, rather\nthan using a separate language like CSS. However, we can draw some\nparallels between CSS rules and the \u003cstyle\u003e element.\nA CSS rule consists of a selector and declarations. In the current\nversion of HXML, the only available selector is a class name, indicated\nby the class attribute. The rest of the attributes on the\n\u003cstyle\u003e element are declarations, consisting of\nproperties and property values.UI elements within the \u003cscreen\u003e can reference the\n\u003cstyle\u003e rules by adding the class names to their\n\u003cstyle\u003e property. Note the \u003ctext\u003e\nelement around “Hello World!” references two style classes:\nh1 and info. The styles from the corresponding\nclasses are merged together in the order they appear on the element.\nIt’s worth noting that styling properties are similar to those in CSS\n(color, margins/padding, borders, etc). Currently, the only available\nlayout engine is based on flexbox.Style rules can get quite verbose. For the sake of brevity, we won’t\ninclude the \u003cstyles\u003e element in the rest of the\nexamples in this chapter unless necessary.The core UI elements that ship with Hyperview are quite basic. Most\nmobile apps require richer elements to deliver a great user experience.\nLuckily, HXML can easily accommodate custom elements in its syntax. This\nis because HXML is really just XML, aka “Extensible Markup Language”.\nExtensibility is already built into the format! Developers are free to\ndefine new elements and attributes to represent custom elements.Let’s see this in action with a concrete example. Assume that we want\nto add a map element to our Hello World app. We want the map to display\na defined area, and one or more markers at specific coordinates in that\narea. Let’s translate these requirements into XML:An \u003carea\u003e element will represent the area\ndisplayed by the map. To specify the area, the element will include\nattributes for latitude and longitude for the\ncenter of the area, and a latitude-delta and\nlongitude-delta indicating the +/- display area around the\ncenter.A \u003cmarker\u003e element will represent a marker in\nthe area. The coordinates of the marker will be defined by\nlatitude and longitude attributes on the\nmarker.Using these custom XML elements, an instance of the map in our app\nmight look like this:Custom elements in HXMLCustom element representing the area rendered by the mapCustom element representing a marker rendered at specific\ncoordinates on the mapThe syntax feels right at home among the core HXML elements. However,\nthere’s a potential problem. “area” and “marker” are pretty generic\nnames. I could see \u003carea\u003e and\n\u003cmarker\u003e elements being used by a customization to\nrender charts \u0026 graphs. If our app renders both maps and charts, the\nHXML markup would be ambiguous. What should the client render when it\nsees \u003carea\u003e or \u003cmarker\u003e?This is where XML namespaces come in. XML namespaces eliminate\nambiguity and collisions between elements and attributes used to\nrepresent different things. Remember that the \u003cdoc\u003e\nelement declares that https://hyperview.org/hyperview is\nthe default namespace for the entire document. Since no other elements\ndefine namespaces, every element in the example above is part of the\nhttps://hyperview.org/hyperview namespace.Let’s define a new namespace for our map elements. Since this\nnamespace will not be the default for the document, we also need to\nassign the namespace to a prefix we will add to our elements:This new attribute declares that the map: prefix is\nassociated with the namespace “https://mycompany.com/hyperview-map”.\nThis namespace could be anything, but remember the goal is to use\nsomething unique that won’t have collisions. Using your company/app\ndomain is a good way to guarantee uniqueness. Now that we have a\nnamespace and prefix, we need to use it for our elements:Namespacing the custom elementsDefinition of namespace aliased to “map”Adding the namespace to the “area” start tagAdding the namespace to the “marker” self-closing tagAdding the namespace to the “area” end tagThat’s it! If we introduced a custom charting library with “area” and\n“marker” elements, we would create a unique namespace for those elements\nas well. Within the HXML doc, we could easily disambiguate\n\u003cmap:area\u003e from \u003cchart:area\u003e.At this point you might be wondering, “how does the Hyperview client\nknow to render a map when my doc includes \u003cmap:area\u003e?” It’s true,\nso far we only defined the custom element format, but we haven’t\nimplemented the element as a feature in our app. We will get into the\ndetails of implementing custom elements in the next chapter.As discussed in earlier chapters, HTML supports two basic types of\ninteractions:Clicking a hyperlink: the client will make a GET request and\nrender the response as a new web page.Submitting a form: the client will (typically) make a POST\nrequest with the serialized content of the form, and render the response\nas a new web page.Clicking hyperlinks and submitting forms is enough to build simple\nweb applications. But relying on just these two interactions limits our\nability to build richer UIs. What if we want something to happen when\nthe user mouses over a certain element, or perhaps when they scroll some\ncontent into the viewport? We can’t do that with basic HTML.\nAdditionally, both clicks and form submits result in loading a full new\nweb page. What if we only want to update a small part of the current\npage? This is a very common scenario in rich web applications, where\nusers expect to fetch and update content without navigating to a new\npage.So with basic HTML, interactions (clicks and submits) are limited and\ntightly coupled to a single action (loading a new page). Of course,\nusing JavaScript, we can extend HTML and add some new syntax to support\nour desired interactions. Htmx does exactly that with a new set of\nattributes:Interactions can be added to any element, not just links and\nforms.The interaction can be triggered via a click, submit, mouseover,\nor any other JavaScript event.The actions resulting from the trigger can modify the current\npage, not just request a new page.By decoupling elements, triggers, and actions, htmx allows us to\nbuild rich Hypermedia-driven applications in a way that feels very\ncompatible with HTML syntax and server-side web development.HXML takes the idea of defining interactions via triggers \u0026\nactions and builds them into the spec. We call these interactions\n“behaviors.” We use a special \u003cbehavior\u003e element to\ndefine them. Here’s an example of a simple behavior that pushes a new\nmobile screen onto the navigation stack:Basic behaviorThe element encapsulating an interaction on the parent\n\u003ctext\u003e element.The trigger that will execute the interaction, in this case\npressing the \u003ctext\u003e element.The action that will execute when triggered, in this case pushing\na new screen onto the current stack.The href to load on the new screen.Let’s break down what’s happening in this example. First, we have a\n\u003ctext\u003e element with the content “Press me!”. We’ve\nshown \u003ctext\u003e elements before in examples of HXML, so\nthis is nothing new. But now, the \u003ctext\u003e element\ncontains a new child element, \u003cbehavior\u003e. This\n\u003cbehavior\u003e element defines an interaction on the\nparent \u003ctext\u003e element. It contains two attributes\nthat are required for any behavior:trigger: defines the user action that triggers the\nbehavioraction: defines what happens when triggeredIn this example, the trigger is set to\npress, meaning this interaction will happen when the user\npresses the \u003ctext\u003e element. The action\nattribute is set to push. push is an action\nthat will push a new screen onto the navigation stack. Finally,\nHyperview needs to know what content to load on the newly pushed screen.\nThis is where the href attribute comes in. Notice we don’t\nneed to define the full URL. Much like in HTML, the href\ncan be an absolute or relative URL.So that’s a first example of behaviors in HXML. You may be thinking\nthis syntax seems quite verbose. Indeed, pressing elements to navigate\nto a new screen is one of the most common interactions in a mobile app.\nIt would be nice to have a simpler syntax for the common case. Luckily,\ntrigger and action attributes have default\nvalues of press and push, respectively.\nTherefore, they can be omitted to clean up the syntax:Basic behavior with defaultsWhen pressed, this behavior will open a new screen with the given\nURL.This markup for the \u003cbehavior\u003e will produce the\nsame interaction as the earlier example. With the default attributes,\nthe \u003cbehavior\u003e element looks similar to an anchor\n\u003ca\u003e in HTML. But the full syntax achieves our goals\nof decoupling elements, triggers, and actions:Behaviors can be added to any element, they are not limited to\nlinks and forms.Behaviors can specify an explicit trigger, not just\nclicks or form submits.Behaviors can specify an explicit action, not just a\nrequest for a new page.Extra attributes like href provide more context for\nthe action.Additionally, using a dedicated \u003cbehavior\u003e element\nmeans a single element can define multiple behaviors. This lets us\nexecute several actions from the same trigger. Or, we can execute\ndifferent actions for different triggers on the same element. We will\nshow examples of the power of multiple behaviors at the end of this\nchapter. First we need to show the variety of supported actions and\ntriggers.Behavior actions in Hyperview fall into four general categories:Navigation actions, which load new screens and move between\nthemUpdate actions, which modify the HXML of the current\nscreenSystem actions, which interact with OS-level\ncapabilities.Custom actions, which can execute any code you add to the\nclient.We’ve already seen the simplest type of action, push. We\nclassify push as a “navigation action”, since it’s related\nto navigating screens in the mobile app. Pushing a screen onto the\nnavigation stack is just one of several navigation actions supported in\nHyperview. Users also need to be able to go back to previous screens,\nopen and close modals, switch between tabs, or jump to arbitrary\nscreens. Each of these types of navigation is supported through a\ndifferent value for the action attribute:push: Push a new screen into the current navigation\nstack. This looks like a screen sliding in from the right, on top of the\ncurrent screen.new: Open a new navigation stack as a modal. This\nlooks like a screen sliding in from the bottom, on top of the current\nscreen.back: This is a complement to the push\naction. It pops the current screen off of the navigation stack (sliding\nit to the right).close: This is a complement to the new\naction. It closes the current navigation stack (sliding it\ndown).reload: Similar to a browser’s “refresh” button,\nthis will re-request the content of the current screen.navigate: This action will attempt to find a screen\nwith the given href already loaded in the app. If the\nscreen exists, the app will jump to that screen. If it doesn’t exist, it\nwill act the same as push.push, new, and navigate all\nload a new screen. Thus, they require an href attribute so\nthat Hyperview knows what content to request for the new screen.\nback and close do not load new screens, and\nthus do not require the href attribute. reload\nis an interesting case. By default, it will use the URL of the screen\nwhen re-requesting the content for the screen. However, if you want to\nreplace the screen with a different one, you can provide an\nhref attribute with reload on the behavior\nelement.Let’s look at an example “widgets” app that uses several navigation\nactions on one screen:Navigation action examplesTakes the user to the previous screenOpens a new modal to add a widgetReloads the content of the screen, showing new widgets from the\nbackendPushes a new screen with details for a specific widgetMost screens in your app will need a way for the user to backtrack to\nthe previous screen. This is usually done with a button in the header\nthat uses either a “back” or “close” action, depending on how the screen\nwas opened. In this example, we’re assuming the widgets screen was\npushed onto the navigation stack, so the “back” action is appropriate.\nThe header contains a second button that allows the user to enter data\nfor a new widget. Pressing this button will open a modal with a “New\nWidget” screen. Since this “New Widget” screen will open as a modal, it\nwill need a corresponding “close” action to dismiss itself and show our\n“widgets” screen again. Finally, to see more details about a specific\nwidget, each \u003citem\u003e element contains a behavior with\na “push” action. This action will push a “Widget Detail” screen onto the\ncurrent navigation stack. Like in the “Widgets” screen, “Widget Detail”\nwill need a button in the header that uses the “back” action to let the\nuser backtrack.On the web, the browser handles basic navigation needs such as going\nback/forward, reloading the current page, or jumping to a bookmark. iOS\nand Android don’t provide this sort of universal navigation for native\nmobile apps. It’s on the app developers to handle this themselves.\nNavigation actions in HXML provide an easy but powerful way for\ndevelopers to build an architecture that makes sense for their app.Behavior actions are not just limited to navigating between screens.\nThey can also be used to change the content on the current screen. We\ncall these “update actions”. Much like navigation actions, update\nactions make a request to the backend. However, the response is not an\nentire HXML document, but a fragment of HXML. This fragment is added to\nthe HXML of the current screen, resulting in an update to the UI. The\naction attribute of the \u003cbehavior\u003e\ndetermines how the fragment gets incorporated into the HXML. We also\nneed to introduce a new target attribute on\n\u003cbehavior\u003e to define where the fragment gets\nincorporated in the existing doc. The target attribute is\nan ID reference to an existing element on the screen.Hyperview currently supports these update actions, representing\ndifferent ways to incorporate the fragment into the screen:replace: replaces the entire target element with the\nfragmentreplace-inner: replaces the children of the target\nelement with the fragmentappend: adds the fragment after the last child of\nthe target elementprepend: adds the fragment before the first child of\nthe target element.Let’s look at some examples to make this more concrete. For these\nexamples, let’s assume our backend accepts GET requests to\n/fragment, and the response is a fragment of HXML that\nlooks like \u003ctext\u003eMy fragment\u003c/text\u003e.Update action examplesReplaces the area1 element with fetched fragmentReplaces the child elements of area2 with fetched\nfragmentAppends the fetched fragment to area3Prepends the fetched fragment to area4In this example, we have a screen with four buttons corresponding to\nthe four update actions: replace,\nreplace-inner, append, prepend.\nBelow each button, there’s a corresponding \u003cview\u003e\ncontaining some text. Note that the id of each view matches\nthe target on the behaviors of the corresponding\nbutton.When the user presses the first button, the Hyperview client makes a\nrequest for /fragment. Next, it looks for the target, ie\nthe element with id “area1”. Finally, it replaces the\n\u003cview id=\"area1\"\u003e element with the fetched fragment,\n\u003ctext\u003eMy fragment\u003c/text\u003e. The existing view and\ntext contained in that view will be replaced. To the user, it will look\nlike “Existing content” was changed to “My fragment”. In the HXML, the\nelement \u003cview id=\"area1\"\u003e will also be gone.The second button behaves in a similar way to the first one. However,\nthe replace-inner action does not remove the target element\nfrom the screen, it only replaces the children. This means the resulting\nmarkup will look like\n\u003cview id=\"area2\"\u003e\u003ctext\u003eMy fragment\u003c/text\u003e\u003c/view\u003e.The third and fourth buttons do not remove any content from the\nscreen. Instead, the fragment will be added either after (in the case of\nappend) or before (prepend) the children of\nthe target element.For completeness, let’s look at the state of the screen after a user\npresses all four buttons:Update actions, after pressing buttonsFragment completely replaced the target using\nreplace actionFragment replaced the children of the target using\nreplace-inner actionFragment added as last child of the target using\nappend actionfragment added as the first child of the target using\nprepend actionThe examples above show actions making GET requests to\nthe backend. But these actions can also make POST requests\nby setting verb=\"post\" on the \u003cbehavior\u003e\nelement. For both GET and POST requests, the\ndata from the parent \u003cform\u003e element will be\nserialized and included in the request. For GET requests,\nthe content will be URL-encoded and added as query params. For\nPOST requests, the content will be form-URL encoded and set\non the request body. Since they support POST and form data,\nupdate actions are often used to send data to the backend.So far, our example of update actions require getting new content\nfrom the backend and adding it to the screen. But sometimes we just want\nto change the state of existing elements. The most common state to\nchange for an element is its visibility. Hyperview has\nhide, show, and toggle actions\nthat do just that. Like the other update actions, hide,\nshow, and toggle use the target\nattribute to apply the action to an element on the current screen.Show, hide, and toggle actionsHides the element with id “area”.Shows the element with id “area”.Toggles the visibility of the element with id “area”.The element targeted by the actions.In this example, the three buttons labeled “Hide”, “Show”, and\n“Toggle” will modify the display state of the \u003cview\u003e\nwith ID “area”. Pressing “Hide” multiple times will have no affect once\nthe view is hidden. Likewise, pressing “Show” multiple times will have\nno affect once the view is showing. Pressing “Toggle” will keep flipping\nthe visibility status of the element between showing and hidden.Hyperview comes with other actions that modify the existing HXML. We\nwon’t cover them in detail, but I’ll mention them briefly here:set-value: this action can set the value of an input\nelement such as \u003ctext-field\u003e,\n\u003cswitch\u003e, \u003cselect-single\u003e,\netc.select-all and unselect-all work with\nthe \u003cselect-multiple\u003e element to select/deselect all\noptions.Some standard Hyperview actions don’t interact with the HXML at all.\nInstead, they expose functionality provided by the mobile OS. For\nexample, both Android and iOS support a system-level “Share” UI. This UI\nallows sharing URLs and messages from one app to another app. Hyperview\nhas a share action to support this interaction. It involves\na custom namespace, and share-specific attributes.System share actionDefines the namespace for the share action.The action of this behavior will bring up the share\nsheet.URL to be shared.Message to be shared.We’ve seen XML namespaces when talking about custom elements. Here,\nwe are using a namespace for the url and\nmessage attributes on the \u003cbehavior\u003e.\nThese attribute names are generic and likely used by other components\nand behaviors, so the namespace ensures there will be no ambiguity. When\npressed, the “share” action will trigger. The values of the\nurl and message attributes will be passed to\nthe system Share UI. From there, the user will be able to share the URL\n\u0026 message via SMS, email, or other communication apps.The share action shows how a behavior action can use\ncustom attributes to pass along extra data needed for the interactions.\nBut some actions require even more structured data. This can be provided\nvia child elements on the \u003cbehavior\u003e. Hyperview uses\nthis to implement the alert action. The alert\naction shows a customized system-level dialog box. This dialog needs\nconfiguration for a title and message, but also for customized buttons.\nEach button needs to then trigger another behavior when pressed. This\nlevel of configuration cannot be done with just attributes, so we use\ncustom child elements to represent the behavior of each button.System alert actionDefines the namespace for the alert action.The action of this behavior will bring up a system dialog\nbox.Title of the dialog box.Content of the dialog box.A “continue” option in the dialog boxWhen “continue” is pressed, push a new screen onto the navigation\nstack.A “cancel” option that dismisses the dialog box.Like the share behavior, alert uses a\nnamespace to define some attributes and elements. The\n\u003cbehavior\u003e element itself contains the\ntitle and message attributes for the dialog\nbox. The button options for the dialog are defined using a new\n\u003coption\u003e element nested in the\n\u003cbehavior\u003e. Notice that each\n\u003coption\u003e element has a label, and then optionally\ncontains a \u003cbehavior\u003e itself! This structure of the\nHXML allows the system dialog to trigger any interaction that can be\ndefined as a \u003cbehavior\u003e. In the example above,\npressing the “Continue” button will open a new screen. But we could just\nas easily trigger an update action to change the current screen. We\ncould even open a share sheet, or a second dialog box. But please don’t\ndo that in a real app! With great power comes great responsibility.You can build a lot of mobile UIs with Hyperview’s standard\nnavigation, update, and system actions. But the standard set may not\ncover all interactions you will need for your mobile app. Luckily, the\naction system is extensible. In the same way you can add custom elements\nto Hyperview, you can also add custom behavior actions. Custom actions\nhave a similar syntax to the share and alert\nactions, using namespaces for attributes that pass along extra data.\nCustom actions also have full access to the HXML of the current screen,\nso they can modify the state or add/remove elements from the current\nscreen. In the next chapter, we will create a custom behavior action to\nenhance our mobile contacts app.We’ve already seen the simplest type of trigger, a press\non an element. Hyperview supports many other common triggers used in\nmobile apps.Closely related to a press is a long-press. A behavior with\ntrigger=\"longPress\" will trigger when the user presses and\nholds on the element. “Long-press” interactions are often used for\nshortcuts and power features. Sometimes, elements will support different\nactions for both a press and longPress. This\nis done using multiple \u003cbehavior\u003e elements on the\nsame UI element.Long-press trigger exampleNormal press will open the next screen.Long press will open a different screen.In this example, a normal press will open a new screen and request\ncontent from /next-screen. However, a long press will open\na new screen with content from /secret-screen. This is a\ncontrived example for the sake of brevity. A better UX would be for the\nlong-press to bring up a contextual menu of shortcuts and advanced\noptions. This could be achieved by using action=\"alert\" and\nopening a system dialog box with the shortcuts.Sometimes we want an action to trigger as soon as the screen loads.\ntrigger=\"load\" does exactly this. One use case is to\nquickly load a shell of the screen, and then fill in the main content on\nthe screen with a second update action.Load trigger exampleContainer element without the actual contentBehavior that immediately fires off a request for /content to\nreplace the containerLoading UI that appears until the content is fetched and\nreplaced.In this example, We load a screen with a heading (“My app”) but no\ncontent. Instead, we show a \u003cview\u003e with ID\n“container” and some “Loading…​” text. As soon as this screen loads, the\nbehavior with trigger=load fires off the\nreplace action. It requests content from the\n/content path and replaces the container view with the\nresponse.Unlike load, the visible trigger will only\nexecute the behavior when the element with the behavior is scrolled into\nthe viewport on the mobile device. The visible action is\ncommonly used to implement an infinite-scroll interaction on a\n\u003clist\u003e of \u003citem\u003e elements. The\nlast item in the list includes a behavior with\ntrigger=\"visible\". The append action will\nfetch the next page of items and append them to the list.This trigger captures a “pull to refresh” action on\n\u003clist\u003e and \u003cview\u003e items. This\ninteraction is associated with fetching up-to-date content from the\nbackend. Thus, it’s typically paired with an update or reload action to\nshow the latest data on the screen.Pull-to-refresh trigger exampleWhen the view is pulled down to refresh, reload the\nscreen.Note that adding a behavior with trigger=\"refresh\" to a\n\u003cview\u003e or \u003clist\u003e will add the\npull-to-refresh interaction to the element, including showing a spinner\nas the element is pulled down.These triggers are related to interactions with input elements. Thus,\nthey will only trigger behaviors attached to elements like\n\u003ctext-field\u003e. focus and\nblur will trigger when the user focuses and blurs the input\nelement, respectively. change will trigger when the value\nof the input element changes, like when the user types a letter in a\ntext field. These triggers are often used with behaviors that need to\nperform some server-side validation on the form fields. For example,\nwhen the user types in a username and then blurs the field, a behavior\ncould trigger on blur to make a request to the backend and\ncheck for uniqueness of the username. If the entered username is not\nunique, the response could include an error message letting the user\nknow they need to pick a different username.Most of the examples shown above attach a single\n\u003cbehavior\u003e to an element. But there’s no such\nlimitation in Hyperview; elements can define multiple behaviors. We\nalready saw an example where a single element had different actions\ntriggered on press and longPress. But we can\nalso trigger multiple actions on the same trigger.In this admittedly contrived example, we want to hide two elements on\nthe screen when pressing the “Hide” button. The two elements are far\napart in the HXML, and cannot be hidden by hiding a common ancestor\nelement. But, we can trigger two behaviors at the same time, each one\nexecuting a “hide” action but targeting different elements.Multiple behaviors triggering on pressHide element with ID “area1” when pressed.Hide element with ID “area2” when pressed.Hyperview processes behaviors in the order they appear in the markup.\nIn this case, the element with ID “area1” will be hidden first, followed\nby the element with ID “area2”. Since “hide” is an instantaneous action\n(ie, it doesn’t make an HTTP request), both elements will appear to hide\nsimultaneously. But what if we triggered two actions that depend on\nresponses from HTTP requests (like “replace-inner“)? In that case, each\nindividual action is processed as soon as Hyperview receives the HTTP\nresponse. Depending on network latency, the two actions could take\neffect in any order, and they are not guaranteed to be applied\nsimultaneously.We’ve seen elements with multiple behaviors and different triggers.\nAnd we’ve seen elements with multiple behaviors with the same trigger.\nThese concepts can be mixed together too. It’s not unusual for a\nproduction Hyperview app to contain several behaviors, some triggering\ntogether and others triggering on different interactions. Using multiple\nbehaviors with custom actions keeps HXML declarative, without\nsacrificing functionality.We’re covering a lot of new concepts here, and this introduction to\nHXML just scratches the surface. To learn more about HXML, we recommend\nconsulting the official reference\ndocumentation. For now, we hope you come away with a few key\ntakeaways.First, HXML looks and feels similar to HTML. Web developers\ncomfortable with server-side rendering frameworks can use the same\ntechniques to write HXML. In addition to basic UI elements\n(\u003cview\u003e, \u003ctext\u003e,\n\u003cimage\u003e), HXML specifies elements to implement\nmobile-specific UIs. This includes layout patterns\n(\u003cscreen\u003e, \u003clist\u003e,\n\u003csection-list\u003e) and input elements\n(\u003cswitch\u003e, \u003cselect-single\u003e,\n\u003cselect-multiple\u003e).Second, interactions in HXML are defined using behaviors. Inspired by\nhtmx, \u003cbehavior\u003e elements decouple user interactions\n(triggers) from the resulting actions. There are three broad categories\nof behavior actions:Navigation actions (push, back) enable\nnavigating between the screens of a mobile appUpdate actions (replace, append) enable\nupdating a screen with new fragments of HXML requested from the\nserver.System actions (alert, share) enable\ninteracting with system-level functionality on iOS and Android.Finally, HXML itself was designed for customization. Developers can\ndefine custom elements and custom behavior actions to expand the\npossible user interactions with their apps.There is a strong case for Hypermedia-Driven Applications on mobile.\nMobile app platforms push developers towards a thick-client\narchitecture. But apps that use a thick client suffer from the same\nproblems as SPAs on the web. Using the hypermedia architecture for\nmobile apps can solve these problems.Hyperview, based on a new format called HXML, offers a path here. It\nprovides an open-source mobile thin client to render HXML. And HXML\nopens a toolkit of elements and patterns that correspond to mobile UIs.\nDevelopers can evolve Hyperview to suit their apps” requirements, while\nfully embracing the hypermedia architecture. That’s a win.Yes, hypermedia can work for mobile apps, too. In the next two\nchapters we’ll show how by turning the Contact.app web application into\na native mobile app using Hyperview.In the Hyperview sections of the book, since we aren’t using HTML, we\nare going to make broader observations on hypermedia rather than offer\nHTML-specific advice and thoughts.A big advantage of the hypermedia-driven approach is that it makes\nthe server-side environment far more important when building your web\napplication. Rather than simply producing JSON, your back end is an\nintegral component in the user experience of your hypermedia\napplication.Because of this, it makes sense to look deeply into the functionality\navailable there. Many older web frameworks, for example, have incredibly\ndeep functionality available around producing HTML. Features like\nserver-side caching can make the difference between an incredibly snappy\nweb application and a sluggish user experience.Take time to learn all the tools available to you.A good rule of thumb is to shoot to have server responses in your\nhypermedia-driven application take less than 100ms to complete, and\nmature server-side frameworks have tools to help make this happen.Server-side environments often have extremely mature mechanisms for\nfactoring (or organizing) your code properly. The Model/View/Controller\npattern is well-developed in most environments, and tools like modules,\npackages, etc. provide an excellent way to organize your code.Whereas today’s SPA and mobile user interfaces are typically\norganized via components, hypermedia-driven applications are typically\norganized via template inclusion, where the server-side templates are\nbroken up according to the hypermedia-rendering needs of the\napplication, and then included in one another as needed. This tends to\nlead to fewer, chunkier files than you would find in a component-based\napplication.Another technology to look for are Template Fragments, which allow\nyou to render only part of a template file. This can reduce even further\nthe number of template files required for your server-side\napplication.A related tip is to take advantage of direct access to the data\nstore. When an application is built using a thick client approach, the\ndata store typically lives behind a data API (e.g. JSON). This level of\nindirection often prevents front end developers from being able to take\nfull advantage of the tools available in the data store. GraphQL, for\nexample, can help address this issue, but comes with security-related\nissues that do not appear to be well understood by many developers.When you produce your hypermedia on the server side, on the other\nhand, the developer creating that hypermedia can have full access to the\ndata store and take advantage of, for example, joins and aggregation\nfunctions in SQL stores.This puts far more expressive power directly in the hands of the\ndeveloper producing the final hypermedia. Because your hypermedia API\ncan be structured around your UI needs, you can tune each endpoint to\nissue as few data store requests as possible.A good rule of thumb is that every request to your server should\nshoot to have three or fewer data-store accesses. If you follow this\nrule of thumb, your hypermedia-driven application should be extremely\nsnappy."
 },
 {
 "chapter": "More Htmx Patterns",
 "content": "So far so good with Contact.app: we have a nice little web\napplication with some significant improvements over a plain HTML-based\napplication. We’ve added a proper “Delete Contact” button, done some\ndynamic validation of input and looked at different approaches to add\npaging to the application. As we have said, many web developers would\nexpect that a lot of JavaScript-based scripting would be required to get\nthese features, but we’ve done it all in relatively pure HTML, using\nonly htmx attributes.We will eventually add some client-side scripting to our\napplication: hypermedia is powerful, but it isn’t all powerful\nand sometimes scripting might be the best (or only) way to achieve a\ngiven goal. For now, however, let’s see what we can accomplish with\nhypermedia.The first advanced htmx feature we will create is known as the\n“Active Search” pattern. Active Search is when, as a user types text\ninto a search box, the results of that search are dynamically shown.\nThis pattern was made popular when Google adopted it for search results,\nand many applications now implement it.To implement Active Search, we are going to use techniques closely\nrelated to the way we did email validation in the previous chapter. If\nyou think about it, the two features are similar in many ways: in both\ncases we want to issue a request as the user types into an input and\nthen update some other element with a response. The server-side\nimplementations will, of course, be very different, but the frontend\ncode will look fairly similar due to htmx’s general approach of “issue a\nrequest on an event and replace something on the screen.”Let’s recall what the search field in our application currently looks\nlike:Our search formThe q or “query” parameter our client-side code uses\nto search.Recall that we have some server-side code that looks for the\nq parameter and, if it is present, searches the contacts\nfor that term.As it stands right now, the user must hit enter when the search input\nis focused, or click the “Search” button. Both of these events will\ntrigger a submit event on the form, causing it to issue an\nHTTP GET and re-rendering the whole page.Currently, thanks to hx-boost, the form will use an AJAX\nrequest for this GET, but we don’t yet get that nice\nsearch-as-you-type behavior we want.To add active search behavior, we will attach a few htmx attributes\nto the search input. We will leave the current form as it is, with an\naction and method, so that the normal search\nbehavior works even if a user does not have JavaScript enabled. This\nwill make our “Active Search” improvement a nice “progressive\nenhancement.”So, in addition to the regular form behavior, we also want\nto issue an HTTP GET request when a key up occurs. We want\nto issue this request to the same URL as the normal form submission.\nFinally, we only want to do this after a small pause in typing has\noccurred.As we said, this functionality is very similar to what we needed for\nemail validation. We can, in fact copy the hx-trigger\nattribute directly from our email validation example, with its small\n200-millisecond delay, to allow a user to stop typing before a request\nis triggered.This is another example of how common patterns come up again and\nagain when using htmx.Adding active search behaviorKeep the original attributes, so search will work if JavaScript\nis not available.Issue a GET to the same URL as the form.Nearly the same hx-trigger specification as for the\nemail input validation.We made a small change to the hx-trigger attribute: we\nswitched out the change event for the search\nevent. The search event is triggered when someone clears\nthe search or hits the enter key. It is a non-standard event, but it\ndoesn’t hurt to include here. The main functionality of the feature is\nprovided by the second triggering event, the keyup. As in\nthe email example, this trigger is delayed with the\ndelay:200ms modifier to “debounce” the input requests and\navoid hammering our server with requests on every keyup.What we have is close to what we want, but we need to set up the\ncorrect target. Recall that the default target for an element is itself.\nAs things currently stand, an HTTP GET request will be\nissued to the /contacts path, which will, as of now, return\nan entire HTML document of search results, and then this whole document\nwill be inserted into the inner HTML of the search input.This is, in fact, nonsense: input elements aren’t\nallowed to have any HTML inside of them. The browser will, sensibly,\njust ignore the htmx request to put the response HTML inside the input.\nSo, at this point, when a user types anything into our input, a request\nwill be issued (you can see it in your browser development console if\nyou try it out) but, unfortunately, it will appear to the user as if\nnothing has happened at all.To fix this issue, what do we want to target with the update instead?\nIdeally we’d like to just target the actual results: there is no reason\nto update the header or search input, and that could cause an annoying\nflash as focus jumps around.The hx-target attribute allows us to do exactly that.\nLet’s use it to target the results body, the tbody element\nin the table of contacts:Adding active search behaviorTarget the tbody tag on the page.Because there is only one tbody on the page, we can use\nthe general CSS selector tbody and htmx will target the\nbody of the table on the page.Now if you try typing something into the search box, we’ll see some\nresults: a request is made and the results are inserted into the\ndocument within the tbody. Unfortunately, the content that\nis coming back is still an entire HTML document.Here we end up with a “double render” situation, where an entire\ndocument has been inserted inside another element, with all the\nnavigation, headers and footers and so forth re-rendered within that\nelement. This is an example of one of those mis-targeting issues we\nmentioned earlier.Thankfully, it is pretty easy to fix.Now, we could use the same trick we reached for in the “Click To\nLoad” and “Infinite Scroll” features: the hx-select\nattribute. Recall that the hx-select attribute allows us to\npick out the part of the response we are interested in using a CSS\nselector.So we could add this to our input:Using “hx-select” for active searchAdding an hx-select that picks out the table rows in\nthe tbody of the response.However, that isn’t the only fix for this problem, and, in this case,\nit isn’t the most efficient one. Instead, let’s change the\nserver-side of our Hypermedia-Driven Application to serve\nonly the HTML content needed.In this section, we’ll look at another, more advanced technique for\ndealing with a situation where we only want a partial bit of\nHTML, rather than a full document. Currently, we are letting the server\ncreate the full HTML document as response and then, on the client side,\nwe filter the HTML down to the bits that we want. This is easy to do,\nand, in fact, might be necessary if we don’t control the server side or\ncan’t easily modify responses.In our application, however, since we are doing “Full Stack”\ndevelopment (that is: we control both frontend and backend\ncode, and can easily modify either) we have another option: we can\nmodify our server responses to return only the content necessary, and\nremove the need to do client-side filtering.This turns out to be more efficient, since we aren’t returning all\nthe content surrounding the bit we are interested in, saving bandwidth\nas well as CPU and memory on the server side. So let’s explore returning\ndifferent HTML content based on the context information that htmx\nprovides with the HTTP requests it makes.Here’s a look again at the current server-side code for our search\nlogic:Server-side searchThis is where the search logic happens.We simply re-render the index.html template every\ntime, no matter what.How do we want to change this? We want to render two different bits\nof HTML content conditionally:If this is a “normal” request for the entire page, we want to\nrender the index.html template in the current manner. In\nfact, we don’t want anything to change if this is a “normal”\nrequest.However, if this is an “Active Search” request, we only want to\nrender the content that is within the tbody, that is, just\nthe table rows of the page.So we need some way to determine exactly which of these two different\ntypes of requests to the /contact URL is being made, in\norder to know exactly which content we want to render.It turns out that htmx helps us distinguish between these two cases\nby including a number of HTTP Request Headers when it makes\nrequests. Request Headers are a feature of HTTP, allowing clients (e.g.,\nweb browsers) to include name/value pairs of metadata associated with\nrequests to help the server understand what the client is\nrequesting.Here is an example of (some of) the headers the FireFox browser\nissues when requesting https://hypermedia.systems:HTTP headersHtmx takes advantage of this feature of HTTP and adds additional\nheaders and, therefore, additional context to the HTTP requests\nthat it makes. This allows you to inspect those headers and choose what\nlogic to execute on the server, and what sort of HTML response you want\nto send to the client.Here is a table of the HTTP headers that htmx includes in HTTP\nrequests:This will be the string “true” if the request is made via an element\nusing hx-boostThis will be the current URL of the browserThis will be the string “true” if the request is for history\nrestoration after a miss in the local history cacheThis will contain the user response to an hx-promptThis value is always “true” for htmx-based requestsThis value will be the id of the target element if it existsThis value will be the name of the triggered element if it existsThis value will be the id of the triggered element if it existsLooking through this list of headers, the last one stands out: we\nhave an id, search on our search input. So the value of the\nHX-Trigger header should be set to search when\nthe request is coming from the search input, which has the id\nsearch.Let’s add some conditional logic to our controller to look for that\nheader and, if the value is search, we render only the rows\nrather than the whole index.html template:Updating our server-side searchIf the request header HX-Trigger is equal to\n“search” we want to do something different.We need to learn how to render just the table rows.OK, so how do we render only the result rows?Now we come to a common pattern in htmx: we want to factor\nour server-side templates. This means that we want to break our\ntemplates up a bit so that they can be called from multiple contexts. In\nthis case, we want to break the rows of the results table out to a\nseparate template we will call rows.html. We will include\nit from the original index.html template, and also use it\nin our controller to render it by itself when we want to respond with\nonly the rows for Active Search requests.Here’s what the table in our index.html file currently\nlooks like:The contacts tableThe for loop in this template is what produces all the\nrows in the final content generated by index.html. What we\nwant to do is to move the for loop and, therefore, the rows\nit creates out to a separate template file so that only that\nsmall bit of HTML can be rendered independently from\nindex.html.Again, let’s call this new template rows.html:Our new rows.html fileUsing this template we can render only the tr elements\nfor a given collection of contacts.Of course, we still want to include this content in the\nindex.html template: we are sometimes going to be\nrendering the entire page, and sometimes only rendering the rows. In\norder to keep the index.html template rendering properly,\nwe can include the rows.html template by using the jinja\ninclude directive at the position we want the content from\nrows.html inserted:Including the new fileThis directive “includes” the rows.html file,\ninserting its content into the current template.So far, so good: our /contacts page is still rendering\nproperly, just as it did before we split the rows out of the\nindex.html template.The last step in factoring our templates is to modify our web\ncontroller to take advantage of the new rows.html template\nfile when it responds to an active search request.Since rows.html is just another template, just like\nindex.html, all we need to do is call the\nrender_template function with rows.html rather\nthan index.html. This will render only the row\ncontent rather than the entire page:Updating our server-side searchRender the new template in the case of an active search.Now, when an Active Search request is made, rather than getting an\nentire HTML document back, we only get a partial bit of HTML, the table\nrows for the contacts that match the search. These rows are then\ninserted into the tbody on the index page, without any need\nfor hx-select or other client-side processing.And, as a bonus, the old form-based search still works. We\nconditionally render the rows only when the search input\nissues the HTTP request via htmx. Again, this is a progressive\nenhancement to our application.HTTP Headers \u0026 CachingOne subtle aspect of the approach we are taking here, using headers\nto determine the content of what we return, is a feature baked into\nHTTP: caching. In our request handler, we are now returning different\ncontent depending on the value of the HX-Trigger header. If\nwe were to use HTTP Caching, we might get into a situation where someone\nmakes a non-htmx request (e.g., refreshing a page) and yet the\nhtmx content is returned from the HTTP cache, resulting in a\npartial page of content for the user.The solution to this problem is to use the HTTP Response\nVary header and call out the htmx headers that you are\nusing to determine what content you are returning. A full explanation of\nHTTP Caching is beyond the scope of this book, but the MDN\narticle on the topic is quite good, and the htmx documentation discusses\nthis issue as well.One shortcoming of our current Active Search implementation, when\ncompared with the normal form submission, is that when you submit the\nform version it updates the navigation bar of the browser to include the\nsearch term. So, for example, if you search for “joe” in the search box,\nyou will end up with a url that looks like this in your browser’s nav\nbar:The updated location after a form searchThis is a nice feature of browsers: it allows you to bookmark this\nsearch or to copy the URL and send it to someone else. All they have to\ndo is to click on the link, and they will repeat the exact same search.\nThis is also tied in with the browser’s notion of history: if you click\nthe back button it will take you to the previous URL that you came from.\nIf you submit two searches and want to go back to the first one, you can\nsimply hit back and the browser will “return” to that search.As it stands right now, during our Active Search, we are not updating\nthe browser’s navigation bar. So, users aren’t getting links that can be\ncopied and pasted, and you aren’t getting history entries either, which\nmeans no back button support. Fortunately, we’ve already seen how to fix\nthis: with the hx-push-url attribute.The hx-push-url attribute lets you tell htmx “Please\npush the URL of this request into the browser’s navigation bar.” Push\nmight seem like an odd verb to use here, but that’s the term that the\nunderlying browser history API uses, which stems from the fact that it\nmodels browser history as a “stack” of locations: when you go to a new\nlocation, that location is “pushed” onto the stack of history elements,\nand when you click “back”, that location is “popped” off the history\nstack.So, to get proper history support for our Active Search, all we need\nto do is to set the hx-push-url attribute to\ntrue.Updating the URL during active searchBy adding the hx-push-url attribute with the value\ntrue, htmx will update the URL when it makes a\nrequest.Now, as Active Search requests are sent, the URL in the browser’s\nnavigation bar is updated to have the proper query in it, just like when\nthe form is submitted.You might not want this behavior. You might feel it would be\nconfusing to users to see the navigation bar updated and have history\nentries for every Active Search made, for example. Which is fine: you\ncan simply omit the hx-push-url attribute and it will go\nback to the behavior you want. The goal with htmx is to be flexible\nenough to achieve the UX that you want, while staying within\nthe declarative HTML model.A final touch for our Active Search pattern is to add a request\nindicator to let the user know that a search is in progress. As it\nstands the user has no explicit signal that the active search\nfunctionality is handling a request. If the search takes a bit, a user\nmay end up thinking that the feature isn’t working. By adding a request\nindicator we let the user know that the hypermedia application is busy\nand they should wait (hopefully not too long!) for the request to\ncomplete.Htmx provides support for request indicators via the\nhx-indicator attribute. This attribute takes, you guessed\nit, a CSS selector that points to the indicator for a given element. The\nindicator can be anything, but it is typically some sort of animated\nimage, such as a gif or svg file, that spins or otherwise communicates\nvisually that “something is happening.”Let’s add a spinner after our search input:Adding a request indicator to searchThe hx-indicator attribute points to the indicator\nimage after the input.The indicator is a spinning circle svg file, and has the\nhtmx-indicator class on it.We have added the spinner right after the input. This visually\nco-locates the request indicator with the element making the request,\nand makes it easy for a user to see that something is in fact\nhappening.It just works, but how does htmx make the spinner appear and\ndisappear? Note that the indicator img tag has the\nhtmx-indicator class on it. htmx-indicator is\na CSS class that is automatically injected into the page by htmx. This\nclass sets the default opacity of an element to\n0, which hides the element from view, while at the same\ntime not disrupting the layout of the page.When an htmx request is triggered that points to this indicator,\nanother class, htmx-request is added to the indicator which\ntransitions its opacity to 1. So you can use just about anything as an\nindicator, and it will be hidden by default. Then, when a request is in\nflight, it will be shown. This is all done via standard CSS classes,\nallowing you to control the transitions and even the mechanism by which\nthe indicator is shown (e.g., you might use display rather\nthan opacity).Use Request Indicators!Request indicators are an important UX aspect of any distributed\napplication. It is unfortunate that browsers have de-emphasized their\nnative request indicators over time, and it is doubly unfortunate that\nrequest indicators are not part of the JavaScript ajax APIs.Be sure not to neglect this significant aspect of your application.\nRequests might seem instant when you are working on your application\nlocally, but in the real world they can take quite a bit longer due to\nnetwork latency. It’s often a good idea to take advantage of browser\ndeveloper tools that allow you to throttle your local browser’s response\ntimes. This will give you a better idea of what real world users are\nseeing, and show you where indicators might help users understand\nexactly what is going on.With this request indicator, we now have a pretty sophisticated user\nexperience when compared with plain HTML, but we’ve built it all as a\nhypermedia-driven feature. No JSON or JavaScript to be seen. And our\nimplementation has the benefit of being a progressive enhancement; the\napplication will continue to work for clients that don’t have JavaScript\nenabled.With Active Search behind us, let’s move on to a very different sort\nof enhancement: lazy loading. Lazy loading is when the loading of a\nparticular bit of content is deferred until later, when needed. This is\ncommonly used as a performance enhancement: you avoid the processing\nresources necessary to produce some data until that data is actually\nneeded.Let’s add a count of the total number of contacts to Contact.app,\njust below the bottom of our contacts table. This will give us a\npotentially expensive operation that we can use to demonstrate how to\nadd lazy loading with htmx.First let’s update our server code in the /contacts\nrequest handler to get a count of the total number of contacts. We will\npass that count through to the template to render some new HTML.Adding a count to the UIGet the total count of contacts from the Contact model.Pass the count out to the index.html template to use\nwhen rendering.As with the rest of the application, in the interest of staying\nfocused on the hypermedia part of Contact.app, we’ll skip over\nthe details of how Contact.count() works. We just need to\nknow that:It returns the total count of contacts in the contact\ndatabase.It may be slow (for the sake of our example).Next lets add some HTML to our index.html that takes\nadvantage of this new bit of data, showing a message next to the “Add\nContact” link with the total count of users. Here is what our HTML looks\nlike:Adding a contact count element to the\napplicationA simple span with some text showing the total number of\ncontacts.Well that was easy, wasn’t it? Now our users will see the total\nnumber of contacts next to the link to add new contacts, to give them a\nsense of how large the contact database is. This sort of rapid\ndevelopment is one of the joys of developing web applications the old\nway.[fig-totalcontacts] is\nwhat the feature looks like in our application. Beautiful.Total contact count displayOf course, as you probably suspected, all is not perfect.\nUnfortunately, upon shipping this feature to production, we start\ngetting complaints from users that the application “feels slow.” Like\nall good developers faced with a performance issue, rather than guessing\nwhat the issue might be, we try to get a performance profile of the\napplication to see what exactly is causing the problem.It turns out, surprisingly, that the problem is that innocent looking\nContacts.count() call, which is taking up to a second and a\nhalf to complete. Unfortunately, for reasons beyond the scope of this\nbook, it is not possible to improve that load time, nor is possible to\ncache the result.This leaves us with two options:Remove the feature.Come up with some other way to mitigate the performance\nissue.Let’s assume that we can’t remove the feature, and therefore look at\nhow we can mitigate this performance issue by using htmx instead.The first step in implementing the Lazy Load pattern is to pull the\nexpensive code — that is, the call to Contacts.count() —\nout of the request handler for the /contacts endpoint.Let’s put this function call into its own HTTP request handler as a\nnew HTTP endpoint that we will put at /contacts/count. For\nthis new endpoint, we won’t need to render a template at all: its sole\njob is going to be to render that small bit of text that is in the span,\n“(22 total Contacts).”Here is what the new code will look like:Pulling the expensive code outWe no longer call Contacts.count() in this\nhandler.Count is no longer passed out to the template to\nrender in the /contacts handler.We create a new handler at the /contacts/count path\nthat does the expensive calculation.Return the string with the total number of contacts.So now we have moved the performance issue out of the\n/contacts handler code, which renders the main contacts\ntable, and created a new HTTP endpoint that will produce this\nexpensive-to-create count string for us.Now we need to get the content from this new handler into\nthe span, somehow. As we said earlier, the default behavior of htmx is\nto place any content it receives for a given request into the\ninnerHTML of an element, and that turns out to be exactly\nwhat we want here: we want to retrieve this text and put it into the\nspan. So we can simply place an hx-get\nattribute on the span, pointing to this new path, and do exactly\nthat.However, recall that the default event that will trigger a\nrequest for a span element in htmx is the\nclick event. Well, that’s not what we want! Instead, we\nwant this request to trigger immediately, when the page loads.To do this, we can add the hx-trigger attribute to\nupdate the trigger of the requests for the element, and use the\nload event.The load event is a special event that htmx triggers on\nall content when it is loaded into the DOM. By setting\nhx-trigger to load, we will cause htmx to\nissue the GET request when the span element is\nloaded into the page.Here is our updated template code:Adding a contact count element to the\napplicationIssue a GET to /contacts/count when the\nload event occurs.Note that the span starts empty: we have removed the\ncontent from it, and we are allowing the request to\n/contacts/count to populate it instead.And, check it out, our /contacts page is fast again!\nWhen you navigate to the page it feels very snappy and profiling shows\nthat yes, indeed, the page is loading much more quickly. Why is that?\nWell, we’ve deferred the expensive calculation to a secondary request,\nallowing the initial request to finish loading faster.You might say “OK, great, but it’s still taking a second or two to\nget the total count on the page.” True, but often the user may not be\nparticularly interested in the total count. They may just want to come\nto the page and search for an existing user, or perhaps they may want to\nedit or add a user. The total count of contacts is just a “nice to have”\nbit of information in these cases.By deferring the calculation of the count in this manner we let users\nget on with their use of the application while we perform the expensive\ncalculation.Yes, the total time to get all the information on the screen takes\njust as long. It actually will be a bit longer, since we now need two\nHTTP requests to get all the information for the page. But the\nperceived performance for the end user will be much better:\nthey can do what they want nearly immediately, even if some information\nisn’t available instantaneously.Lazy Loading is a great tool to have in your belt when optimizing web\napplication performance.A shortcoming of the current implementation is that currently there\nis no indication that the count request is in flight, it just appears at\nsome point when the request finishes.This isn’t ideal. What we want here is an indicator, just like we\nadded in our Active Search example. And, in fact, we can simply reuse\nthat same exact spinner image, copy-and-pasted into the new HTML we have\ncreated.Now, in this case, we have a one-time request and, once the request\nis over, we are not going to need the spinner anymore. So it doesn’t\nmake sense to use the exact same approach we did with the active search\nexample. Recall that in that case we placed a spinner after the\nspan and using the hx-indicator attribute to point to\nit.In this case, since the spinner is only used once, we can put it\ninside the content of the span. When the request completes the\ncontent in the response will be placed inside the span, replacing the\nspinner with the computed contact count. It turns out that htmx allows\nyou to place indicators with the htmx-indicator class on\nthem inside of elements that issue htmx-powered requests. In the absence\nof an hx-indicator attribute, these internal indicators\nwill be shown when a request is in flight.So let’s add that spinner from the active search example as the\ninitial content in our span:Adding an indicator to our lazily loaded\ncontentYep, that’s it.Now when the user loads the page, rather than having the total\ncontact count magically appear, there is a nice spinner indicating that\nsomething is coming. Much better.Note that all we had to do was copy and paste our indicator from the\nactive search example into the span. Once again we see how\nhtmx provides flexible, composable features and building blocks.\nImplementing a new feature is often just copy-and-paste, maybe a tweak\nor two, and you are done.You might say “OK, but that’s not really lazy. We are still loading\nthe count immediately when the page is loaded, we are just doing it in a\nsecond request. You aren’t really waiting until the value is actually\nneeded.”Fine. Let’s make it lazy lazy: we’ll only issue the request\nwhen the span scrolls into view.To do that, lets recall how we set up the infinite scroll example: we\nused the revealed event for our trigger. That’s all we want\nhere, right? When the element is revealed we issue the request?Yep, that’s it. Once again, we can mix and match concepts across\nvarious UX patterns to come up with solutions to new problems in\nhtmx.Making it truly lazyChange the hx-trigger to\nrevealed.Now we have a truly lazy implementation, deferring the expensive\ncomputation until we are absolutely sure we need it. A pretty cool\ntrick, and, again, a simple one-attribute change demonstrates the\nflexibility of both htmx and the hypermedia approach.For our next hypermedia trick, we are going to implement the “Inline\nDelete” pattern. With this feature, a contact can be deleted directly\nfrom the table of all contacts, rather than requiring the user to\nnavigate all the way to the edit view of particular contact, in order to\naccess the “Delete Contact” button we added in the last chapter.Recall that we already have “Edit” and “View” links for each row, in\nthe rows.html template:The existing row actionsNow we want to add a “Delete” link as well. And, thinking on it, we\nwant that link to act an awful lot like the “Delete Contact” button from\nedit.html, don’t we? We’d like to issue an HTTP\nDELETE to the URL for the given contact and we want a\nconfirmation dialog to ensure the user doesn’t accidentally delete a\ncontact.Here is the “Delete Contact” button html:The existing row actionsAs you may suspect by now, this is going to be another copy-and-paste\njob.One thing to note is that, in the case of the “Delete Contact”\nbutton, we wanted to re-render the whole screen and update the URL,\nsince we are going to be returning from the edit view for the contact to\nthe list view of all contacts. In the case of this link, however, we are\nalready on the list of contacts, so there is no need to update the URL,\nand we can omit the hx-push-url attribute.Here is the code for our inline “Delete” link:The existing row actionsAlmost a straight copy of the “Delete Contact” button.As you can see, we have added a new anchor tag and given it a blank\ntarget (the # value in its href attribute) to\nretain the correct mouse-over styling behavior of the link. We’ve also\ncopied the hx-delete, hx-confirm and\nhx-target attributes from the “Delete Contact” button, but\nomitted the hx-push-url attributes since we don’t want to\nupdate the URL of the browser.We now have inline delete working, even with a confirmation dialog. A\nuser can click on the “Delete” link and the row will disappear from the\nUI as the entire page is re-rendered.A Style SidebarOne side effect of adding this delete link is that we are starting to\npile up the actions in a contact row:That’s a lot of actionsIt would be nice if we didn’t show the actions all in a row, and,\nadditionally, it would be nice if we only showed the actions when the\nuser indicated interest in a given row. We will return to this problem\nafter we look at the relationship between scripting and a\nHypermedia-Driven Application in a later chapter.For now, let’s just tolerate this less-than-ideal user interface,\nknowing that we will fix it later.We can get even fancier here, however. What if, rather than\nre-rendering the whole page, we just removed the row for the contact?\nThe user is looking at the row anyway, so is there really a need to\nre-render the whole page?To do this, we’ll need to do a couple of things:We’ll need to update this link to target the row that it is\nin.We’ll need to change the swap to outerHTML, since we\nwant to replace (really, remove) the entire row.We’ll need to update the server side to render empty content when\nthe DELETE is issued from a “Delete” link rather than from\nthe “Delete Contact” button on the contact edit page.First things first, update the target of our “Delete” link to be the\nrow that the link is in, rather than the entire body. We can once again\ntake advantage of the relative positional closest feature\nto target the closest tr, like we did in our “Click To\nLoad” and “Infinite Scroll” features:The existing row actionsUpdated to target the closest enclosing tr (table\nrow) of the link.Now we need to update the server side. We want to keep the “Delete\nContact” button working as well, and in that case the current logic is\ncorrect. So we’ll need some way to differentiate between\nDELETE requests that are triggered by the button and\nDELETE requests that come from this anchor.The cleanest way to do this is to add an id attribute to\nthe “Delete Contact” button, so that we can inspect the\nHX-Trigger HTTP Request header to determine if the delete\nbutton was the cause of the request. This is a simple change to the\nexisting HTML:Adding an id to the “delete contact”\nbuttonAn id attribute has been added to the\nbutton.By giving this button an id attribute, we now have a mechanism for\ndifferentiating between the delete button in the edit.html\ntemplate and the delete links in the rows.html template.\nWhen this button issues a request, it will look something like this:You can see that the request now includes the id of the\nbutton. This allows us to write code very similar to what we did for the\nactive search pattern, using a conditional on the\nHX-Trigger header to determine what we want to do. If that\nheader has the value delete-btn, then we know the request\ncame from the button on the edit page, and we can do what we are\ncurrently doing: delete the contact and redirect to\n/contacts page.If it does not have that value, then we can simply delete\nthe contact and return an empty string. This empty string will replace\nthe target, in this case the row for the given contact, thereby removing\nthe row from the UI.Let’s refactor our server-side code to do this:Updating our server code to handle two different delete)\npatternsIf the delete button on the edit page submitted this request,\nthen continue to do the previous logic.If not, simply return an empty string, which will delete the\nrow.And that’s our server-side implementation: when a user clicks\n“Delete” on a contact row and confirms the delete, the row will\ndisappear from the UI. Once again, we have a situation where just\nchanging a few lines of simple code gives us a dramatically different\nbehavior. Hypermedia is powerful in this manner.This is pretty cool, but there is another improvement we can make if\nwe take some time to understand the htmx content swapping model: it\nwould be nice if, rather than just instantly deleting the row, we faded\nit out before we removed it. The fade would make it clear that the row\nis being removed, giving the user some nice visual feedback on the\ndeletion.It turns out we can do this pretty easily with htmx, but to do so\nwe’ll need to dig in to exactly how htmx swaps content.You might think that htmx simply puts the new content into the DOM,\nbut that’s not in fact how it works. Instead, content goes through a\nseries of steps as it is added to the DOM:When content is received and about to be swapped into the DOM,\nthe htmx-swapping CSS class is added to the target\nelement.A small delay then occurs (we will discuss why this delay exists\nin a moment).Next, the htmx-swapping class is removed from the\ntarget and the htmx-settling class is added.The new content is swapped into the DOM.Another small delay occurs.Finally, the htmx-settling class is removed from the\ntarget.There is more to the swap mechanic (settling, for example, is a more\nadvanced topic that we will discuss in a later chapter) but this is\nenough for now.Now, there are small delays in the process here, typically on the\norder of a few milliseconds. Why so? It turns out that these small\ndelays allow CSS transitions to occur.CSS TransitionsCSS transitions are a technology that allow you to animate a\ntransition from one style to another. So, for example, if you changed\nthe height of something from 10 pixels to 20 pixels, by using a CSS\ntransition you can make the element smoothly animate to the new height.\nThese sorts of animations are fun, often increase application usability,\nand are a great mechanism to add polish to your web application.Unfortunately, CSS transitions are difficult to access in plain HTML:\nyou usually have to use JavaScript and add or remove classes to get them\nto trigger. This is why the htmx swap model is more complicated than you\nmight initially think. By swapping in classes and adding small delays,\nyou can access CSS transitions purely within HTML, without needing to\nwrite any JavaScript!OK, so, let’s go back and look at our inline delete mechanic: we\nclick an htmx-enhanced link which deletes the contact and then swaps\nsome empty content in for the row. We know that before the\ntr element is removed, it will have the\nhtmx-swapping class added to it. We can take advantage of\nthat to write a CSS transition that fades the opacity of the row to 0.\nHere is what that CSS looks like:Adding a fade out transitionWe want this style to apply to tr elements with the\nhtmx-swapping class on them.The opacity will be 0, making it invisible.The opacity will transition to 0 over a 1 second\ntime period, using the ease-out function.Again, this is not a CSS book and we are not going to go deeply into\nthe details of CSS transitions, but hopefully the above makes sense to\nyou, even if this is the first time you’ve seen CSS transitions.So, think about what this means from the htmx swapping model: when\nhtmx gets content back to swap into the row it will put the\nhtmx-swapping class on the row and wait a bit. This will\nallow the transition to a zero opacity to occur, fading the row out.\nThen the new (empty) content will be swapped in, which will effectively\nremove the row.Sounds good, and we are nearly there. There is one more thing we need\nto do: the default “swap delay” for htmx is very short, a few\nmilliseconds. That makes sense in most cases: you don’t want to have\nmuch of a delay before you put the new content into the DOM. But, in\nthis case, we want to give the CSS animation time to complete before we\ndo the swap, we want to give it a second, in fact.Fortunately htmx has an option for the hx-swap\nannotation that allows you to set the swap delay: following the swap\ntype you can add swap: followed by a timing value to tell\nhtmx to wait a specific amount of time before it swaps. Let’s update our\nHTML to allow a one second delay before the swap is done for the delete\naction:The existing row actionsA swap delay changes how long htmx waits before it swaps in new\ncontent.With this modification, the existing row will stay in the DOM for an\nadditional second, with the htmx-swapping class on it. This\nwill give the row time to transition to an opacity of zero, giving the\nfade out effect we want.Now, when a user clicks on a “Delete” link and confirms the delete,\nthe row will slowly fade out and then, once it has faded to a 0 opacity,\nit will be removed. Pretty fancy, and all done in a declarative,\nhypermedia-oriented manner, no JavaScript required. (Well, obviously\nhtmx is written in JavaScript, but you know what we mean: we didn’t have\nto write any JavaScript to implement the feature.)The final feature we are going to implement in this chapter is a\n“Bulk Delete.” The current mechanism for deleting users is nice, but it\nwould be annoying if a user wanted to delete five or ten contacts at a\ntime, wouldn’t it? For the bulk delete feature, we want to add the\nability to select rows via a checkbox input and delete them all in a\nsingle go by clicking a “Delete Selected Contacts” button.To get started with this feature, we’ll need to add a checkbox input\nto each row in the rows.html template. This input will have\nthe name selected_contact_ids and its value will be the\nid of the contact for the current row.Here is what the updated code for rows.html looks\nlike:Adding a checkbox to each rowA new cell with the checkbox input whose value is set to the\ncurrent contact’s id.We’ll also need to add an empty column in the header for the table to\naccommodate the checkbox column. With that done we now get a series of\ncheck boxes, one for each row, a pattern no doubt familiar to you from\nthe web ([fig-checkboxes]).Checkboxes for our contact rowsIf you are not familiar with or have forgotten the way checkboxes\nwork in HTML: a checkbox will submit its value associated with the name\nof the input if and only if it is checked. So if, for example, you\nchecked the contacts with the ids 3, 7 and 9, then those three values\nwould all be submitted to the server. Since all the checkboxes in this\ncase have the same name, selected_contact_ids, all three\nvalues would be submitted with the name\nselected_contact_ids.The next step is to add a button below the table that will delete all\nthe selected contacts. We want this button, like our delete links in\neach row, to issue an HTTP DELETE, but rather than issuing\nit to the URL for a given contact, like we do with the inline delete\nlinks and with the delete button on the edit page, here we want to issue\nthe DELETE to the /contacts URL.As with the other delete elements, we want to confirm that the user\nwishes to delete the contacts, and, for this case, we are going to\ntarget the body of page, since we are going to re-render the whole\ntable.Here is what the button code looks like:The “delete selected contacts” buttonIssue a DELETE to /contacts.Confirm that the user wants to delete the selected\ncontacts.Target the body.Pretty easy. One question though: how are we going to include the\nvalues of all the selected checkboxes in the request? As it stands right\nnow, this is just a stand-alone button, and it doesn’t have any\ninformation indicating that it should include any other information in\nthe DELETE request it makes.Fortunately, htmx has a few different ways to include values of\ninputs with a request.One way would be to use the hx-include attribute, which\nallows you to use a CSS selector to specify the elements you want to\ninclude in the request. That would work fine here, but we are going to\nuse another approach that is a bit simpler in this case.By default, if an element is a child of a form element\nand makes a non-GET request, htmx will include all the\nvalues of inputs within that form. In situations like this, where there\nis a bulk operation for a table, it is common to enclose the whole table\nin a form tag, so that it is easy to add buttons that operate on the\nselected items.Let’s add that form tag around the table, and be sure to enclose the\nbutton in it as well:The “delete selected contacts” buttonThe form tag encloses the entire table.The form tag also encloses the button.Now, when the button issues a DELETE, it will include\nall the contact ids that have been selected as the\nselected_contact_ids request variable.The server-side implementation is going to look like our original\nserver-side code for deleting a contact. In fact, once again, we can\njust copy and paste, and make a few fixes:We want to change the URL to /contacts.We want the handler to get all the ids submitted as\nselected_contact_ids and iterate over each one, deleting\nthe given contact.Those are the only changes we need to make! Here is what the\nserver-side code looks like:The “delete selected contacts” buttonWe handle a DELETE request to the\n/contacts/ path.Convert the selected_contact_ids values submitted to\nthe server from a list of strings to a list integers.Iterate over all of the ids.Delete the given contact with each id.Beyond that, it’s the same code as our original delete handler:\nflash a message and render the index.html\ntemplate.So, we took the original delete logic and slightly modified it to\ndeal with an array of ids, rather than a single id.You might notice one other small change: we did away with the\nredirect that was in the original delete code. We did so because we are\nalready on the page we want to re-render, so there is no reason to\nredirect and have the URL update to something new. We can just re-render\nthe page, and the new list of contacts (sans the contacts that were\ndeleted) will be re-rendered.And there we go, we now have a bulk delete feature for our\napplication. Once again, not a huge amount of code, and we are\nimplementing these features entirely by exchanging hypermedia with a\nserver in the traditional, RESTful manner of the web.Accessibility problems can arise when we try to implement controls\nthat aren’t built into HTML.Earlier, in Chapter One, we looked at the example of a \u003cdiv\u003e\nimprovised to work like a button. Let’s look at a different example:\nwhat if you make something that looks like a set of tabs, but you use\nradio buttons and CSS hacks to build it? It’s a neat hack that makes the\nrounds in web development communities from time to time.The problem here is that tabs have requirements beyond clicking to\nchange content. Your improvised tabs may be missing features that will\nlead to user confusion and frustration, as well as some undesirable\nbehaviors. From the ARIA Authoring\nPractices Guide on tabs:Keyboard interactionCan the tabs be focused with the Tab key?ARIA roles, states, and properties“[The element that contains the tabs] has role\ntablist.”“Each [tab] has role tab […​]”“Each element that contains the content panel for a\ntab has role tabpanel.”“Each [tab] has the property aria-controls referring\nto its associated tabpanel element.”“The active tab element has the state\naria-selected set to true and all other\ntab elements have it set to false.”“Each element with role tabpanel has the property\naria-labelledby referring to its associated\ntab element.”You would need to write a lot of code to make your improvised tabs\nfulfill all of these requirements. Some of the ARIA attributes can be\nadded directly in HTML, but they are repetitive and others (like\naria-selected) need to be set through JavaScript since they\nare dynamic. The keyboard interactions can be error-prone too.It’s not impossible, not even that hard, to make your own tab set\nimplementation. However, it’s difficult to trust that a new\nimplementation will work for all users in all environments, since most\nof us have limited resources for testing.Stick with established libraries for UI interactions. If a\nuse case requires a bespoke solution, test exhaustively for\nkeyboard interaction and accessibility. Test manually. Test\nautomatically. Test with screen readers, test with a keyboard, test on\ndifferent browsers and hardware, and run linters (while coding and/or in\nCI). Testing is critical to ensure machine readability, or human\nreadability, or page weight.Also consider: Does the information need to be presented as tabs?\nSometimes the answer is yes, but if not, a sequence of details and\ndisclosures fulfills a very similar purpose.Compromising UX just to avoid JavaScript is bad development. But\nsometimes it’s possible to achieve an equal (or better!) quality of UX\nwhile allowing for a simpler and more robust implementation by changing\nthe design."
 }
 ]